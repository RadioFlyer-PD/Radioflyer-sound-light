            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> Start=========================
            ; C.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlayAdpECABF1D0();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_AA01D89BC_0:;					
            _AA01D89BC_0:
            ; //	
            ; //_AA01D89BC_1:;					
            _AA01D89BC_1:
            ; //_AA01D89BC_2:;					
            _AA01D89BC_2:
            ; //	_InitialDA4A7CC4();			
0011D:      	pch	= _InitialDA4A7CC4
0011E:      	lcall	_InitialDA4A7CC4
            ; //_AA01D89BC_3:;					
            _AA01D89BC_3:
            ; //_AA01D89BC_4:;					
            _AA01D89BC_4:
            ; //	_InitKey3C587B6D();			
0011F:      	pch	= _InitKey3C587B6D
00120:      	lcall	_InitKey3C587B6D
            ; //_AA01D89BC_5:;					
            _AA01D89BC_5:
            ; //_AA01D89BC_6:;					
            _AA01D89BC_6:
            ; //	ADPCM_CHX_Init();			
00121:      	pch	= ADPCM_CHX_Init
00122:      	lcall	ADPCM_CHX_Init
            ; //_AA01D89BC_7:;					
            _AA01D89BC_7:
            ; //	sAX	= 0x0001;			
00123:      	AX	= 0x01
            ; //	asm I1 = CopyToBank+0;			
00124:      	I1 = CopyToBank+0//
            ; //	*(__int16*)sSI	= sAX			
00125:      	rm[I1]	= AX
            ; //_AA01D89BC_8:;					
            _AA01D89BC_8:
            ; //	asm	set io[INTENA].b0		
00126:      	set io[INTENA].b0
            ; //_AA01D89BC_9:;					
            _AA01D89BC_9:
            ; //	asm	eni				
00127:      	eni
            ; //_AA01D89BC_10:;					
            _AA01D89BC_10:
            ; //_AA01D89BC_11:;					
            _AA01D89BC_11:
            ; //	_touch_init378E5983();			
00128:      	pch	= _touch_init378E5983
00129:      	lcall	_touch_init378E5983
            ; //LE6FF7BEA_5:;					
            LE6FF7BEA_5:
            ; //_AA01D89BC_12:;					
            _AA01D89BC_12:
            ; //_AA01D89BC_13:;					
            _AA01D89BC_13:
            ; //	asm	io[ClrWDT] = AR			
0012A:      	io[ClrWDT] = AR
            ; //	
            ; //_AA01D89BC_14:;					
            _AA01D89BC_14:
            ; //_AA01D89BC_15:;					
            _AA01D89BC_15:
            ; //	_PollingKey3B90E3B1();			
0012B:      	pch	= _PollingKey3B90E3B1
0012C:      	lcall	_PollingKey3B90E3B1
            ; //_AA01D89BC_16:;					
            _AA01D89BC_16:
            ; //_AA01D89BC_17:;					
            _AA01D89BC_17:
            ; //	_DoADPCM9CD0E20D();			
0012D:      	pch	= _DoADPCM9CD0E20D
0012E:      	lcall	_DoADPCM9CD0E20D
            ; //_AA01D89BC_18:;					
            _AA01D89BC_18:
            ; //	goto LE6FF7BEA_5;			
0012F:      	jmp	LE6FF7BEA_5
            ; //LE6FF7BEA_4:;					
            LE6FF7BEA_4:
            ; //LE6FF7BEA_3:;					
            LE6FF7BEA_3:
            ; //_AA01D89BC_19:;					
            _AA01D89BC_19:
            ; //	return;					
00130:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_AA01D89BC_20:;					
            _AA01D89BC_20:
            ; //}
            ; //
            ; //rjmp void _KeyPlayAdpECABF1D0()			
            _KeyPlayAdpECABF1D0:
            ; //{
            ; //_AA01D89BC_21:;					
            _AA01D89BC_21:
            ; //	
            ; //_AA01D89BC_22:;					
            _AA01D89BC_22:
            ; //_AA01D89BC_23:;					
            _AA01D89BC_23:
            ; //	asm I1 = _iADPCCACC469+0;		
00131:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00132:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00133:      	push	AX
            ; //	_playADPCMBACD5AFD(STACK[sSP + 0]);	
00134:      	pch	= _playADPCMBACD5AFD
00135:      	lcall	_playADPCMBACD5AFD
            ; //	RESTORESP(1);				
00136:      	pop	AR
            ; //LE6FF7BEA_6:;					
            LE6FF7BEA_6:
            ; //_AA01D89BC_24:;					
            _AA01D89BC_24:
            ; //	return;					
00137:      	rets
            ; //_KeyPlayAdpECABF1D0_end:;			
            _KeyPlayAdpECABF1D0_end:
            ; //_AA01D89BC_25:;					
            _AA01D89BC_25:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_AA01D89BC_26:;					
            _AA01D89BC_26:
            ; //	
            ; //_AA01D89BC_27:;					
            _AA01D89BC_27:
            ; //	asm I1 = _iADPCCACC469+0;		
00138:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00139:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
0013A:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0013B:      	CX	= rm[I1]
            ; //	sCX++;					
0013C:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
0013D:      	rm[I1]	= CX
            ; //_AA01D89BC_28:;					
            _AA01D89BC_28:
            ; //	asm I1 = _iADPCCACC469+0;		
0013E:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0013F:      	AX	= rm[I1]
            ; //	sCX	= 0x0009;			
00140:      	CX	= 0x09
            ; //	sfx_CMP_AX_CX_JGE();			
00141:      	pch	= sfx_CMP_AX_CX_JGE
00142:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto LE6FF7BEA_9;	
00143:      	if ZR	jmp LE6FF7BEA_9
            ; //	goto	LE6FF7BEA_8;			
00144:      	jmp	LE6FF7BEA_8
            ; //LE6FF7BEA_9:;					
            LE6FF7BEA_9:
            ; //_AA01D89BC_29:;					
            _AA01D89BC_29:
            ; //	sAX	= 0x0000;			
00145:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00146:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00147:      	rm[I1]	= AX
            ; //LE6FF7BEA_8:;					
            LE6FF7BEA_8:
            ; //_AA01D89BC_30:;					
            _AA01D89BC_30:
            ; //_AA01D89BC_31:;					
            _AA01D89BC_31:
            ; //_AA01D89BC_32:;					
            _AA01D89BC_32:
            ; //	_KeyPlayAdpECABF1D0();			
00148:      	pch	= _KeyPlayAdpECABF1D0
00149:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_7:;					
            LE6FF7BEA_7:
            ; //_AA01D89BC_33:;					
            _AA01D89BC_33:
            ; //	return;					
0014A:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_AA01D89BC_34:;					
            _AA01D89BC_34:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_AA01D89BC_35:;					
            _AA01D89BC_35:
            ; //	
            ; //_AA01D89BC_36:;					
            _AA01D89BC_36:
            ; //	asm I1 = _iADPCCACC469+0;		
0014B:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0014C:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
0014D:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0014E:      	CX	= rm[I1]
            ; //	sCX--;					
0014F:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
00150:      	rm[I1]	= CX
            ; //_AA01D89BC_37:;					
            _AA01D89BC_37:
            ; //	asm I1 = _iADPCCACC469+0;		
00151:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00152:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
00153:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00154:      	pch	= sfx_CMP_AX_CX_JL
00155:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LE6FF7BEA_12;	
00156:      	if ZR	jmp LE6FF7BEA_12
            ; //	goto	LE6FF7BEA_11;			
00157:      	jmp	LE6FF7BEA_11
            ; //LE6FF7BEA_12:;					
            LE6FF7BEA_12:
            ; //_AA01D89BC_38:;					
            _AA01D89BC_38:
            ; //	sAX	= 0x0005;			
00158:      	AX	= 0x05
            ; //	asm I1 = _iADPCCACC469+0;		
00159:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0015A:      	rm[I1]	= AX
            ; //LE6FF7BEA_11:;					
            LE6FF7BEA_11:
            ; //_AA01D89BC_39:;					
            _AA01D89BC_39:
            ; //_AA01D89BC_40:;					
            _AA01D89BC_40:
            ; //_AA01D89BC_41:;					
            _AA01D89BC_41:
            ; //	_KeyPlayAdpECABF1D0();			
0015B:      	pch	= _KeyPlayAdpECABF1D0
0015C:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_10:;					
            LE6FF7BEA_10:
            ; //_AA01D89BC_42:;					
            _AA01D89BC_42:
            ; //	return;					
0015D:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_AA01D89BC_43:;					
            _AA01D89BC_43:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayPrev8E98A35A[0], 0x0000, 0x0000, (int)&_KeyPlayAdpECABF1D0[0], 0x0000, 0x0000, (int)&_KeyPlayNextAFBA8CED[0], 0x0000, 
0015E:      DW #_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyPlayAdpECABF1D0,0x0000,0x0000,#_KeyPlayNextAFBA8CED,0x0000,
            ; //	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
00166:      DW 0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:127]={
             inbuf,outbuf 
            };
            
            ; //// CODE segment					
            VarRM[0:4095]={
             BaseOn128#PCMY[128] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //interrupt rjmp void _PWM_Entry4EB0B003();
            ; //rjmp void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //interrupt rjmp void _PWM_Entry4EB0B003()	
            _PWM_Entry4EB0B003:
            ; //{						
0016D:      	push ax
0016E:      	push bx
0016F:      	push cx
00170:      	push dx
00171:      	push r0
00172:      	push r1
00173:      	push r2
00174:      	push r3
00175:      	push i1
00176:      	push p1
00177:      	push mx
00178:      	push mr0
00179:      	push mr1
0017A:      	push mr2
0017B:      	ar = p1.hh
0017C:      	push ar
            ; //_AA01D89BC_44:;					
            _AA01D89BC_44:
            ; //	
            ; //_AA01D89BC_45:;					
            _AA01D89BC_45:
            ; //	io[0x02]	= 0x0000;		
0017D:      	AR	= 0x00
0017E:      	io[0x02]	= AR
            ; //_AA01D89BC_46:;					
            _AA01D89BC_46:
            ; //	asm	push AX				
0017F:      	push AX
            ; //_AA01D89BC_47:;					
            _AA01D89BC_47:
            ; //	asm	push I0				
00180:      	push I0
            ; //_AA01D89BC_48:;					
            _AA01D89BC_48:
            ; //	asm	push CBL			
00181:      	push CBL
            ; //_AA01D89BC_49:;					
            _AA01D89BC_49:
            ; //	io[0x3B]	= 0x0007;		
00182:      	AR	= 0x07
00183:      	io[0x3B]	= AR
            ; //	
            ; //_AA01D89BC_50:;					
            _AA01D89BC_50:
            ; //	asm AX = rm[outbuf+0];			
00184:      	AX = rm[outbuf+0]//
            ; //_AA01D89BC_51:;					
            _AA01D89BC_51:
            ; //	asm	AR = AX				
00185:      	AR = AX
            ; //_AA01D89BC_52:;					
            _AA01D89BC_52:
            ; //	asm	I0 = AR				
00186:      	I0 = AR
            ; //	
            ; //_AA01D89BC_53:;					
            _AA01D89BC_53:
            ; //_AA01D89BC_54:;					
            _AA01D89BC_54:
            ; //	read_I0P2();				
00187:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00188:      	AR	= AX
00189:      	io[0x16]	= AR
            ; //_AA01D89BC_55:;					
            _AA01D89BC_55:
            ; //_AA01D89BC_56:;					
            _AA01D89BC_56:
            ; //	read_I0P2();				
0018A:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018B:      	AR	= AX
0018C:      	io[0x16]	= AR
            ; //_AA01D89BC_57:;					
            _AA01D89BC_57:
            ; //_AA01D89BC_58:;					
            _AA01D89BC_58:
            ; //	read_I0P2();				
0018D:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018E:      	AR	= AX
0018F:      	io[0x16]	= AR
            ; //_AA01D89BC_59:;					
            _AA01D89BC_59:
            ; //_AA01D89BC_60:;					
            _AA01D89BC_60:
            ; //	read_I0P2();				
00190:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00191:      	AR	= AX
00192:      	io[0x16]	= AR
            ; //_AA01D89BC_61:;					
            _AA01D89BC_61:
            ; //_AA01D89BC_62:;					
            _AA01D89BC_62:
            ; //	get_I0();				
00193:      	push	I0
00194:      	pop	AX
            ; //	outbuf+0 = sAX				
00195:      	rm[outbuf+0]	= AX
            ; //_AA01D89BC_63:;					
            _AA01D89BC_63:
            ; //	asm	pop CBL				
00196:      	pop CBL
            ; //_AA01D89BC_64:;					
            _AA01D89BC_64:
            ; //	asm	pop I0				
00197:      	pop I0
            ; //_AA01D89BC_65:;					
            _AA01D89BC_65:
            ; //	asm	pop AX				
00198:      	pop AX
            ; //L0E8FA404_15:;					
            L0E8FA404_15:
            ; //_AA01D89BC_66:;					
            _AA01D89BC_66:
            ; //	return;					
00199:      	pop ar
0019A:      	p1.hh = ar
0019B:      	pop mr2
0019C:      	pop mr1
0019D:      	pop mr0
0019E:      	pop mx
0019F:      	pop p1
001A0:      	pop i1
001A1:      	pop r3
001A2:      	pop r2
001A3:      	pop r1
001A4:      	pop r0
001A5:      	pop dx
001A6:      	pop cx
001A7:      	pop bx
001A8:      	pop ax
001A9:      	reti
            ; //_PWM_Entry4EB0B003_end:;			
            _PWM_Entry4EB0B003_end:
            ; //_AA01D89BC_67:;					
            _AA01D89BC_67:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_16()			
            L0E8FA404_16:
            ; //{
            ; //_AA01D89BC_68:;					
            _AA01D89BC_68:
            ; //	
            ; //_AA01D89BC_69:;					
            _AA01D89BC_69:
            ; //	io[0x16]	= 0x0000;		
001AA:      	AR	= 0x00
001AB:      	io[0x16]	= AR
            ; //_AA01D89BC_70:;					
            _AA01D89BC_70:
            ; //	io[0x16]	= 0x0000;		
001AC:      	AR	= 0x00
001AD:      	io[0x16]	= AR
            ; //_AA01D89BC_71:;					
            _AA01D89BC_71:
            ; //	io[0x16]	= 0x0000;		
001AE:      	AR	= 0x00
001AF:      	io[0x16]	= AR
            ; //_AA01D89BC_72:;					
            _AA01D89BC_72:
            ; //	io[0x16]	= 0x0000;		
001B0:      	AR	= 0x00
001B1:      	io[0x16]	= AR
            ; //_AA01D89BC_73:;					
            _AA01D89BC_73:
            ; //	io[0x36]	= 0x0000;		
001B2:      	AR	= 0x00
001B3:      	io[0x36]	= AR
            ; //_AA01D89BC_74:;					
            _AA01D89BC_74:
            ; //	io[0x36]	= 0x0000;		
001B4:      	AR	= 0x00
001B5:      	io[0x36]	= AR
            ; //_AA01D89BC_75:;					
            _AA01D89BC_75:
            ; //	io[0x36]	= 0x0000;		
001B6:      	AR	= 0x00
001B7:      	io[0x36]	= AR
            ; //_AA01D89BC_76:;					
            _AA01D89BC_76:
            ; //	io[0x36]	= 0x0000;		
001B8:      	AR	= 0x00
001B9:      	io[0x36]	= AR
            ; //_AA01D89BC_77:;					
            _AA01D89BC_77:
            ; //	io[0x36]	= 0x0000;		
001BA:      	AR	= 0x00
001BB:      	io[0x36]	= AR
            ; //_AA01D89BC_78:;					
            _AA01D89BC_78:
            ; //	io[0x36]	= 0x0000;		
001BC:      	AR	= 0x00
001BD:      	io[0x36]	= AR
            ; //_AA01D89BC_79:;					
            _AA01D89BC_79:
            ; //	io[0x36]	= 0x0000;		
001BE:      	AR	= 0x00
001BF:      	io[0x36]	= AR
            ; //_AA01D89BC_80:;					
            _AA01D89BC_80:
            ; //	io[0x36]	= 0x0000;		
001C0:      	AR	= 0x00
001C1:      	io[0x36]	= AR
            ; //_AA01D89BC_81:;					
            _AA01D89BC_81:
            ; //	io[0x3C]	= 0x003F;		
001C2:      	AR	= 0x3F
001C3:      	io[0x3C]	= AR
            ; //_AA01D89BC_82:;					
            _AA01D89BC_82:
            ; //	sAX	= io[0x3C];			
001C4:      	AR	= io[0x3C]
001C5:      	AX	= AR
            ; //_AA01D89BC_83:;					
            _AA01D89BC_83:
            ; //	asm	set io[MISC].b9			
001C6:      	set io[MISC].b9
            ; //_AA01D89BC_84:;					
            _AA01D89BC_84:
            ; //	asm	set io[MISC].b8			
001C7:      	set io[MISC].b8
            ; //_AA01D89BC_85:;					
            _AA01D89BC_85:
            ; //	asm	set io[MISC].b4			
001C8:      	set io[MISC].b4
            ; //L0E8FA404_18:;					
            L0E8FA404_18:
            ; //_AA01D89BC_86:;					
            _AA01D89BC_86:
            ; //	return;					
001C9:      	rets
            ; //L0E8FA404_16_end:;				
            L0E8FA404_16_end:
            ; //_AA01D89BC_87:;					
            _AA01D89BC_87:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_19()			
            L0E8FA404_19:
            ; //{
            ; //_AA01D89BC_88:;					
            _AA01D89BC_88:
            ; //	
            ; //_AA01D89BC_89:;					
            _AA01D89BC_89:
            ; //	io[0x05]	= 0xFFFF;		
001CA:      	AR	= 0xFFFF
001CC:      	io[0x05]	= AR
            ; //_AA01D89BC_90:;					
            _AA01D89BC_90:
            ; //	io[0x08]	= 0x0000;		
001CD:      	AR	= 0x00
001CE:      	io[0x08]	= AR
            ; //L0E8FA404_21:;					
            L0E8FA404_21:
            ; //_AA01D89BC_91:;					
            _AA01D89BC_91:
            ; //	return;					
001CF:      	rets
            ; //L0E8FA404_19_end:;				
            L0E8FA404_19_end:
            ; //_AA01D89BC_92:;					
            _AA01D89BC_92:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_AA01D89BC_93:;					
            _AA01D89BC_93:
            ; //	
            ; //_AA01D89BC_94:;					
            _AA01D89BC_94:
            ; //	sAX	= 0xFFFF;			
001D0:      	AX	= 0xFFFF
            ; //	asm I1 = _iADPCCACC469+0;		
001D2:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
001D3:      	rm[I1]	= AX
            ; //_AA01D89BC_95:;					
            _AA01D89BC_95:
            ; //	asm AX = PCMY+0;			
001D4:      	AX = PCMY+0//
            ; //	inbuf+0 = sAX				
001D6:      	rm[inbuf+0]	= AX
            ; //_AA01D89BC_96:;					
            _AA01D89BC_96:
            ; //	asm AX = PCMY+0;			
001D7:      	AX = PCMY+0//
            ; //	outbuf+0 = sAX				
001D9:      	rm[outbuf+0]	= AX
            ; //_AA01D89BC_97:;					
            _AA01D89BC_97:
            ; //_AA01D89BC_98:;					
            _AA01D89BC_98:
            ; //	NEARCALL(L0E8FA404_16);			
001DA:      	call	L0E8FA404_16
            ; //_AA01D89BC_99:;					
            _AA01D89BC_99:
            ; //_AA01D89BC_100:;				
            _AA01D89BC_100:
            ; //	NEARCALL(L0E8FA404_19);			
001DB:      	call	L0E8FA404_19
            ; //L0E8FA404_22:;					
            L0E8FA404_22:
            ; //_AA01D89BC_101:;				
            _AA01D89BC_101:
            ; //	return;					
001DC:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_AA01D89BC_102:;				
            _AA01D89BC_102:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> Start=========================
            ; playadp.c Code Start!!;
            VarRM[0:4095]={
             _iADPCCACC469,_adpch30670376[36],_adpFLTG0FBE3CB5[2] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4);
            ; //rjmp void ADPCM_CHX_Init();
            ; //rjmp void ADPCM_CHXGetBts();
            ; //rjmp void _DoADPCM9CD0E20D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4)
            _playADPCMBACD5AFD:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //	__int16 _q_1_6;
            ; //						
001DD:      	AR	= rm[BP_SAVE]
001DE:      	push	AR
001DF:      	AR	= BP
001E0:      	rm[BP_SAVE]	= AR
001E1:      	AR	 = -3
001E2:      	BP	+= AR
            ; //_AA01D89BC_103:;				
            _AA01D89BC_103:
            ; //	
            ; //_AA01D89BC_104:;				
            _AA01D89BC_104:
            ; //	asm AX = _adpch30670376+0;		
001E3:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
001E4:      	AR	= -1
001E5:      	I1	= rm[BP_SAVE]
001E6:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
001E7:      	rm[I1]	= AX
            ; //_AA01D89BC_105:;				
            _AA01D89BC_105:
            ; //	_i_1_2+0	= 0x00;			
001E8:      	I1	= rm[BP_SAVE]
001E9:      	AX	= 0x00
001EA:      	rm[I1]	= AX
            ; //L7F5A46A0_26:;					
            L7F5A46A0_26:
            ; //	sSI	= (int)&_i_1_2;			
001EB:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001EC:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
001ED:      	CX	= 0x02
            ; //	sfx_CMP_AX_CX_JL();			
001EE:      	pch	= sfx_CMP_AX_CX_JL
001EF:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L7F5A46A0_30;	
001F0:      	if ZR	jmp L7F5A46A0_30
            ; //	goto	L7F5A46A0_28;			
001F1:      	jmp	L7F5A46A0_28
            ; //L7F5A46A0_30:;					
            L7F5A46A0_30:
            ; //	goto L7F5A46A0_27;			
001F2:      	jmp	L7F5A46A0_27
            ; //L7F5A46A0_29:;					
            L7F5A46A0_29:
            ; //	sSI	= (int)&_i_1_2;			
001F3:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F4:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
001F5:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
001F6:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
001F7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
001F8:      	rm[I1] = CX + AR//
            ; //	goto L7F5A46A0_26;			
001F9:      	jmp	L7F5A46A0_26
            ; //L7F5A46A0_27:;					
            L7F5A46A0_27:
            ; //	
            ; //_AA01D89BC_106:;				
            _AA01D89BC_106:
            ; //	sSI	= (int)&_p_1_4;			
001FA:      	AR	= -1
001FB:      	I1	= rm[BP_SAVE]
001FC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
001FD:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
001FE:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
001FF:      	AR	= CX
00200:      	AX	+= AR
            ; //	sSI	= sAX;				
00201:      	AR	= AX
00202:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00203:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00204:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
00205:      	AR	= AX
00206:      	AR	|= DX
            ; //	if(__jz__)	goto L7F5A46A0_32;	
00207:      	if ZR	jmp L7F5A46A0_32
            ; //	goto	L7F5A46A0_31;			
00208:      	jmp	L7F5A46A0_31
            ; //L7F5A46A0_32:;					
            L7F5A46A0_32:
            ; //	
            ; //_AA01D89BC_107:;				
            _AA01D89BC_107:
            ; //_AA01D89BC_108:;				
            _AA01D89BC_108:
            ; //	sAX	= 0x0012;			
00209:      	AX	= 0x12
            ; //	PUSH(sAX);				
0020A:      	push	AX
            ; //	sAX	= 0x0000;			
0020B:      	AX	= 0x00
            ; //	PUSH(sAX);				
0020C:      	push	AX
            ; //	sSI	= (int)&_p_1_4;			
0020D:      	AR	= -1
0020E:      	I1	= rm[BP_SAVE]
0020F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00210:      	AX	= rm[I1]
            ; //	sDX	= 0;				
00211:      	DX	= 0x00
            ; //	PUSH(sDX);				
00212:      	push	DX
            ; //	PUSH(sAX);				
00213:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00214:      	pch	= _memset5A9D755A
00215:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00216:      	AR	= 4
00217:      	BP	+= AR
            ; //_AA01D89BC_109:;				
            _AA01D89BC_109:
            ; //	asm AX = #_adpdata32993E3B+0;		
00218:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
0021A:      	push	AX
            ; //	sSI	= (int)&_index_0_4;		
0021B:      	AR	= 2
0021C:      	I1	= rm[BP_SAVE]
0021D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0021E:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
0021F:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
00220:      	pch	= sfx_IMUL_AX_CX
00221:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
00222:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00223:      	AR	= CX
00224:      	AX	+= AR
            ; //	sSI	= (int)&_q_1_6;			
00225:      	AR	= -2
00226:      	I1	= rm[BP_SAVE]
00227:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00228:      	rm[I1]	= AX
            ; //_AA01D89BC_110:;				
            _AA01D89BC_110:
            ; //	sSI	= (int)&_p_1_4;			
00229:      	AR	= -1
0022A:      	I1	= rm[BP_SAVE]
0022B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0022C:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0022D:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0022E:      	AR	= CX
0022F:      	AX	+= AR
            ; //	PUSH(sAX);				
00230:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00231:      	AR	= -2
00232:      	I1	= rm[BP_SAVE]
00233:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00234:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00235:      	AR	= AX
00236:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
00237:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
00238:      	DX	= pm[P1--]
            ; //	sSI	= POP();			
00239:      	pop	I1
            ; //	sfx_STORSILONG();			
0023A:      	rm[I1++]	= AX
0023B:      	rm[I1--]	= DX
            ; //_AA01D89BC_111:;				
            _AA01D89BC_111:
            ; //	sSI	= (int)&_p_1_4;			
0023C:      	AR	= -1
0023D:      	I1	= rm[BP_SAVE]
0023E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0023F:      	AX	= rm[I1]
            ; //	sCX	= 0x0011;			
00240:      	CX	= 0x11
            ; //	sAX	= sAX + sCX;			
00241:      	AR	= CX
00242:      	AX	+= AR
            ; //	PUSH(sAX);				
00243:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00244:      	AR	= -2
00245:      	I1	= rm[BP_SAVE]
00246:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00247:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00248:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00249:      	AR	= CX
0024A:      	AX	+= AR
            ; //	sDI	= sAX;				
0024B:      	AR	= AX
0024C:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0024D:      	AX	= pm[P1]
            ; //	sSI	= POP();			
0024E:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0024F:      	rm[I1]	= AX
            ; //_AA01D89BC_112:;				
            _AA01D89BC_112:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
00250:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	PUSH(sAX);				
00251:      	push	AX
            ; //	sSI	= (int)&_i_1_2;			
00252:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00253:      	AX	= rm[I1]
            ; //	
            ; //	sCX	= POP();			
00254:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00255:      	AR	= CX
00256:      	AX	+= AR
            ; //	PUSH(sAX);				
00257:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00258:      	AR	= -2
00259:      	I1	= rm[BP_SAVE]
0025A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0025B:      	AX	= rm[I1]
            ; //	sCX	= 0x0003;			
0025C:      	CX	= 0x03
            ; //	sAX	= sAX + sCX;			
0025D:      	AR	= CX
0025E:      	AX	+= AR
            ; //	sDI	= sAX;				
0025F:      	AR	= AX
00260:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00261:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00262:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00263:      	rm[I1]	= AX
            ; //_AA01D89BC_113:;				
            _AA01D89BC_113:
            ; //	sAX	= 0x0001;			
00264:      	AX	= 0x01
            ; //	goto L7F5A46A0_25;			
00265:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_31:;					
            L7F5A46A0_31:
            ; //_AA01D89BC_114:;				
            _AA01D89BC_114:
            ; //_AA01D89BC_115:;				
            _AA01D89BC_115:
            ; //	sSI	= (int)&_p_1_4;			
00266:      	AR	= -1
00267:      	I1	= rm[BP_SAVE]
00268:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00269:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
0026A:      	AR	= -1
0026B:      	I1	= rm[BP_SAVE]
0026C:      	I1	+= AR
            ; //	asm AR = 0x0012;			
0026D:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
0026E:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
0026F:      	rm[I1] = CX + AR//
            ; //_AA01D89BC_116:;				
            _AA01D89BC_116:
            ; //	goto L7F5A46A0_29;			
00270:      	jmp	L7F5A46A0_29
            ; //L7F5A46A0_28:;					
            L7F5A46A0_28:
            ; //_AA01D89BC_117:;				
            _AA01D89BC_117:
            ; //	sAX	= 0x0000;			
00271:      	AX	= 0x00
            ; //	goto L7F5A46A0_25;			
00272:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_25:;					
            L7F5A46A0_25:
            ; //_AA01D89BC_118:;				
            _AA01D89BC_118:
            ; //	return;					
00273:      	AR	= 3
00274:      	BP	+= AR
00275:      	pop	AR
00276:      	rm[BP_SAVE]	= AR
00277:      	rets
            ; //_playADPCMBACD5AFD_end:;			
            _playADPCMBACD5AFD_end:
            ; //_AA01D89BC_119:;				
            _AA01D89BC_119:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHX_Init()			
            ADPCM_CHX_Init:
            ; //{
            ; //_AA01D89BC_120:;				
            _AA01D89BC_120:
            ; //	
            ; //_AA01D89BC_121:;				
            _AA01D89BC_121:
            ; //	sAX	= 0x0000;			
00278:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00279:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0027A:      	rm[I1]	= AX
            ; //_AA01D89BC_122:;				
            _AA01D89BC_122:
            ; //_AA01D89BC_123:;				
            _AA01D89BC_123:
            ; //	sAX	= 0x0024;			
0027B:      	AX	= 0x24
            ; //	PUSH(sAX);				
0027C:      	push	AX
            ; //	sAX	= 0x0000;			
0027D:      	AX	= 0x00
            ; //	PUSH(sAX);				
0027E:      	push	AX
            ; //	asm AX = _adpch30670376+0;		
0027F:      	AX = _adpch30670376+0//
            ; //	sDX	= 0;				
00280:      	DX	= 0x00
            ; //	PUSH(sDX);				
00281:      	push	DX
            ; //	PUSH(sAX);				
00282:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00283:      	pch	= _memset5A9D755A
00284:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00285:      	AR	= 4
00286:      	BP	+= AR
            ; //L7F5A46A0_33:;					
            L7F5A46A0_33:
            ; //_AA01D89BC_124:;				
            _AA01D89BC_124:
            ; //	return;					
00287:      	rets
            ; //ADPCM_CHX_Init_end:;				
            ADPCM_CHX_Init_end:
            ; //_AA01D89BC_125:;				
            _AA01D89BC_125:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHXGetBts()			
            ADPCM_CHXGetBts:
            ; //{
            ; //_AA01D89BC_126:;				
            _AA01D89BC_126:
            ; //_AA01D89BC_127:;				
            _AA01D89BC_127:
            ; //	asm	push AX				
00288:      	push AX
            ; //_AA01D89BC_128:;				
            _AA01D89BC_128:
            ; //	asm	push BX				
00289:      	push BX
            ; //_AA01D89BC_129:;				
            _AA01D89BC_129:
            ; //	asm	push CX				
0028A:      	push CX
            ; //_AA01D89BC_130:;				
            _AA01D89BC_130:
            ; //	asm	push DX				
0028B:      	push DX
            ; //_AA01D89BC_131:;				
            _AA01D89BC_131:
            ; //	asm	push I1				
0028C:      	push I1
            ; //_AA01D89BC_132:;				
            _AA01D89BC_132:
            ; //	asm	push P0				
0028D:      	push P0
            ; //_AA01D89BC_133:;				
            _AA01D89BC_133:
            ; //	asm	AR = P0.hh			
0028E:      	AR = P0.hh
            ; //_AA01D89BC_134:;				
            _AA01D89BC_134:
            ; //	asm	push AR				
0028F:      	push AR
            ; //	
            ; //_AA01D89BC_135:;				
            _AA01D89BC_135:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00290:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00291:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00292:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00293:      	AR	= CX
00294:      	AX	+= AR
            ; //	sSI	= sAX;				
00295:      	AR	= AX
00296:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00297:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00298:      	DX	= rm[I1--]
            ; //	PUSH(sAX);				
00299:      	push	AX
            ; //	PUSH(sDX);				
0029A:      	push	DX
            ; //	sCX	= 0x0001;			
0029B:      	CX	= 0x01
            ; //	sBX	= 0x0000;			
0029C:      	BX	= 0x00
            ; //	sfx_ADDLONG();				
0029D:      	AR	= CX
0029E:      	AX	= AX + AR
0029F:      	AR	= BX
002A0:      	DX	= DX + AR + C
            ; //	sfx_STORSILONG();			
002A1:      	rm[I1++]	= AX
002A2:      	rm[I1--]	= DX
            ; //	sDX	= POP();			
002A3:      	pop	DX
            ; //	sAX	= POP();			
002A4:      	pop	AX
            ; //_AA01D89BC_136:;				
            _AA01D89BC_136:
            ; //	asm	AR = AX				
002A5:      	AR = AX
            ; //_AA01D89BC_137:;				
            _AA01D89BC_137:
            ; //	asm	P0 = AR				
002A6:      	P0 = AR
            ; //_AA01D89BC_138:;				
            _AA01D89BC_138:
            ; //	asm	AR = DX				
002A7:      	AR = DX
            ; //_AA01D89BC_139:;				
            _AA01D89BC_139:
            ; //	asm	P0.hh = AR			
002A8:      	P0.hh = AR
            ; //	
            ; //_AA01D89BC_140:;				
            _AA01D89BC_140:
            ; //_AA01D89BC_141:;				
            _AA01D89BC_141:
            ; //	read_P0();				
002A9:      	AX	= pm[P0]
            ; //_AA01D89BC_142:;				
            _AA01D89BC_142:
            ; //	asm	pop AR				
002AA:      	pop AR
            ; //_AA01D89BC_143:;				
            _AA01D89BC_143:
            ; //	asm	P0.hh = AR			
002AB:      	P0.hh = AR
            ; //_AA01D89BC_144:;				
            _AA01D89BC_144:
            ; //	asm	pop P0				
002AC:      	pop P0
            ; //_AA01D89BC_145:;				
            _AA01D89BC_145:
            ; //	asm	pop I1				
002AD:      	pop I1
            ; //_AA01D89BC_146:;				
            _AA01D89BC_146:
            ; //	asm	pop DX				
002AE:      	pop DX
            ; //_AA01D89BC_147:;				
            _AA01D89BC_147:
            ; //	asm	pop CX				
002AF:      	pop CX
            ; //_AA01D89BC_148:;				
            _AA01D89BC_148:
            ; //	asm	pop BX				
002B0:      	pop BX
            ; //	
            ; //_AA01D89BC_149:;				
            _AA01D89BC_149:
            ; //_AA01D89BC_150:;				
            _AA01D89BC_150:
            ; //	asintax();				
            ; //_AA01D89BC_151:;				
            _AA01D89BC_151:
            ; //	asm	AR = AX				
002B1:      	AR = AX
            ; //_AA01D89BC_152:;				
            _AA01D89BC_152:
            ; //	asm	pop AX				
002B2:      	pop AX
            ; //L7F5A46A0_34:;					
            L7F5A46A0_34:
            ; //_AA01D89BC_153:;				
            _AA01D89BC_153:
            ; //	return;					
002B3:      	rets
            ; //ADPCM_CHXGetBts_end:;				
            ADPCM_CHXGetBts_end:
            ; //_AA01D89BC_154:;				
            _AA01D89BC_154:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_35()			
            L7F5A46A0_35:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
002B4:      	AR	= rm[BP_SAVE]
002B5:      	push	AR
002B6:      	AR	= BP
002B7:      	rm[BP_SAVE]	= AR
002B8:      	AR	 = -1
002B9:      	BP	+= AR
            ; //_AA01D89BC_155:;				
            _AA01D89BC_155:
            ; //	
            ; //_AA01D89BC_156:;				
            _AA01D89BC_156:
            ; //	asm I1 = inbuf+0;			
002BA:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
002BB:      	AX	= rm[I1]
            ; //_AA01D89BC_157:;				
            _AA01D89BC_157:
            ; //	asm	AR = AX				
002BC:      	AR = AX
            ; //_AA01D89BC_158:;				
            _AA01D89BC_158:
            ; //	asm	I0 = AR				
002BD:      	I0 = AR
            ; //	
            ; //	
            ; //_AA01D89BC_159:;				
            _AA01D89BC_159:
            ; //	_i_1_2+0	= 0x40;			
002BE:      	I1	= rm[BP_SAVE]
002BF:      	AX	= 0x40
002C0:      	rm[I1]	= AX
            ; //L7F5A46A0_39:;					
            L7F5A46A0_39:
            ; //_AA01D89BC_160:;				
            _AA01D89BC_160:
            ; //	sSI	= (int)&_i_1_2;			
002C1:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002C2:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
002C3:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_40;	
002C4:      	if NZ	jmp L7F5A46A0_40
            ; //	goto	L7F5A46A0_38;			
002C5:      	jmp	L7F5A46A0_38
            ; //L7F5A46A0_40:;					
            L7F5A46A0_40:
            ; //	
            ; //_AA01D89BC_161:;				
            _AA01D89BC_161:
            ; //	sAX	= 0x0000;			
002C6:      	AX	= 0x00
            ; //_AA01D89BC_162:;				
            _AA01D89BC_162:
            ; //	asm	rm[I0++] = AX			
002C7:      	rm[I0++] = AX
            ; //	
            ; //_AA01D89BC_163:;				
            _AA01D89BC_163:
            ; //	sSI	= (int)&_i_1_2;			
002C8:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002C9:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
002CA:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
002CB:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
002CC:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
002CD:      	rm[I1] = CX - AR//
            ; //_AA01D89BC_164:;				
            _AA01D89BC_164:
            ; //	goto L7F5A46A0_39;			
002CE:      	jmp	L7F5A46A0_39
            ; //L7F5A46A0_38:;					
            L7F5A46A0_38:
            ; //L7F5A46A0_37:;					
            L7F5A46A0_37:
            ; //_AA01D89BC_165:;				
            _AA01D89BC_165:
            ; //	return;					
002CF:      	AR	= 1
002D0:      	BP	+= AR
002D1:      	pop	AR
002D2:      	rm[BP_SAVE]	= AR
002D3:      	rets
            ; //L7F5A46A0_35_end:;				
            L7F5A46A0_35_end:
            ; //_AA01D89BC_166:;				
            _AA01D89BC_166:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_41(__int16 _vol_0_4)	
            L7F5A46A0_41:
            ; //{
            ; //	__int16 _p_1_2;
            ; //	__int16 _i_1_4;
            ; //						
002D4:      	AR	= rm[BP_SAVE]
002D5:      	push	AR
002D6:      	AR	= BP
002D7:      	rm[BP_SAVE]	= AR
002D8:      	AR	 = -2
002D9:      	BP	+= AR
            ; //_AA01D89BC_167:;				
            _AA01D89BC_167:
            ; //	
            ; //_AA01D89BC_168:;				
            _AA01D89BC_168:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002DA:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002DB:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
002DC:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
002DD:      	AR	= CX
002DE:      	AX	+= AR
            ; //	sSI	= sAX;				
002DF:      	AR	= AX
002E0:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
002E1:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
002E2:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
002E3:      	AR	= AX
002E4:      	AR	|= DX
            ; //	if(__jnz__)	goto L7F5A46A0_45;	
002E5:      	if NZ	jmp L7F5A46A0_45
            ; //	goto	L7F5A46A0_44;			
002E6:      	jmp	L7F5A46A0_44
            ; //L7F5A46A0_45:;					
            L7F5A46A0_45:
            ; //	
            ; //_AA01D89BC_169:;				
            _AA01D89BC_169:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002E7:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002E8:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
002E9:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
002EA:      	AR	= CX
002EB:      	AX	+= AR
            ; //_AA01D89BC_170:;				
            _AA01D89BC_170:
            ; //	asm	AR = AX				
002EC:      	AR = AX
            ; //_AA01D89BC_171:;				
            _AA01D89BC_171:
            ; //	asm	I0 = AR				
002ED:      	I0 = AR
            ; //	
            ; //	
            ; //_AA01D89BC_172:;				
            _AA01D89BC_172:
            ; //_AA01D89BC_173:;				
            _AA01D89BC_173:
            ; //	read_I0P();				
002EE:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002EF:      	AR	= AX
002F0:      	io[0x36]	= AR
            ; //_AA01D89BC_174:;				
            _AA01D89BC_174:
            ; //_AA01D89BC_175:;				
            _AA01D89BC_175:
            ; //	read_I0P();				
002F1:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F2:      	AR	= AX
002F3:      	io[0x36]	= AR
            ; //_AA01D89BC_176:;				
            _AA01D89BC_176:
            ; //_AA01D89BC_177:;				
            _AA01D89BC_177:
            ; //	read_I0P();				
002F4:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F5:      	AR	= AX
002F6:      	io[0x36]	= AR
            ; //_AA01D89BC_178:;				
            _AA01D89BC_178:
            ; //_AA01D89BC_179:;				
            _AA01D89BC_179:
            ; //	read_I0P();				
002F7:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F8:      	AR	= AX
002F9:      	io[0x36]	= AR
            ; //_AA01D89BC_180:;				
            _AA01D89BC_180:
            ; //_AA01D89BC_181:;				
            _AA01D89BC_181:
            ; //	read_I0P();				
002FA:      	AX	= rm[I0++]
            ; //	io[0x3D]	= sAX;			
002FB:      	AR	= AX
002FC:      	io[0x3D]	= AR
            ; //_AA01D89BC_182:;				
            _AA01D89BC_182:
            ; //_AA01D89BC_183:;				
            _AA01D89BC_183:
            ; //	read_I0P();				
002FD:      	AX	= rm[I0++]
            ; //	io[0x3E]	= sAX;			
002FE:      	AR	= AX
002FF:      	io[0x3E]	= AR
            ; //_AA01D89BC_184:;				
            _AA01D89BC_184:
            ; //	sSI	= (int)&_vol_0_4;		
00300:      	AR	= 2
00301:      	I1	= rm[BP_SAVE]
00302:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00303:      	AX	= rm[I1]
            ; //	io[0x3C]	= sAX;			
00304:      	AR	= AX
00305:      	io[0x3C]	= AR
            ; //_AA01D89BC_185:;				
            _AA01D89BC_185:
            ; //	sAX	= io[0x3C];			
00306:      	AR	= io[0x3C]
00307:      	AX	= AR
            ; //_AA01D89BC_186:;				
            _AA01D89BC_186:
            ; //	asm I1 = inbuf+0;			
00308:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
00309:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_2;			
0030A:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0030B:      	rm[I1]	= AX
            ; //_AA01D89BC_187:;				
            _AA01D89BC_187:
            ; //	_i_1_4+0	= 0x20;			
0030C:      	AR	= -1
0030D:      	I1	= rm[BP_SAVE]
0030E:      	I1	+= AR
0030F:      	AX	= 0x20
00310:      	rm[I1]	= AX
            ; //L7F5A46A0_47:;					
            L7F5A46A0_47:
            ; //_AA01D89BC_188:;				
            _AA01D89BC_188:
            ; //	sSI	= (int)&_i_1_4;			
00311:      	AR	= -1
00312:      	I1	= rm[BP_SAVE]
00313:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00314:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00315:      	AR	= -1
00316:      	I1	= rm[BP_SAVE]
00317:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00318:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00319:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0031A:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0031B:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_48;	
0031C:      	if NZ	jmp L7F5A46A0_48
            ; //	goto	L7F5A46A0_46;			
0031D:      	jmp	L7F5A46A0_46
            ; //L7F5A46A0_48:;					
            L7F5A46A0_48:
            ; //	
            ; //_AA01D89BC_189:;				
            _AA01D89BC_189:
            ; //	sAX	= 0;				
0031E:      	AX	= 0x00
            ; //	asm test io[0x00].b14;			
0031F:      	test io[0x00].b14//
            ; //	if(__jz__) goto L7F5A46A0_49;		
00320:      	if ZR	jmp L7F5A46A0_49
            ; //	sAX	= 1;				
00321:      	AX	= 0x01
            ; //L7F5A46A0_49:;					
            L7F5A46A0_49:
            ; //	sfx_CHECKZERO();			
00322:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_51;	
00323:      	if ZR	jmp L7F5A46A0_51
            ; //	goto	L7F5A46A0_50;			
00324:      	jmp	L7F5A46A0_50
            ; //L7F5A46A0_51:;					
            L7F5A46A0_51:
            ; //	
            ; //_AA01D89BC_190:;				
            _AA01D89BC_190:
            ; //_AA01D89BC_191:;				
            _AA01D89BC_191:
            ; //	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E();
00325:      	pch	= _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
00326:      	lcall	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
            ; //	sfx_CHECKZERO();			
00327:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_53;	
00328:      	if ZR	jmp L7F5A46A0_53
            ; //	goto	L7F5A46A0_52;			
00329:      	jmp	L7F5A46A0_52
            ; //L7F5A46A0_53:;					
            L7F5A46A0_53:
            ; //	
            ; //_AA01D89BC_192:;				
            _AA01D89BC_192:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0032A:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0032B:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0032C:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0032D:      	AR	= CX
0032E:      	AX	+= AR
            ; //	PUSH(sAX);				
0032F:      	push	AX
            ; //	sAX	= 0x0000;			
00330:      	AX	= 0x00
            ; //	sDX	= 0x0000;			
00331:      	DX	= 0x00
            ; //	sSI	= POP();			
00332:      	pop	I1
            ; //	sfx_STORSILONG();			
00333:      	rm[I1++]	= AX
00334:      	rm[I1--]	= DX
            ; //_AA01D89BC_193:;				
            _AA01D89BC_193:
            ; //	goto L7F5A46A0_43;			
00335:      	jmp	L7F5A46A0_43
            ; //L7F5A46A0_52:;					
            L7F5A46A0_52:
            ; //_AA01D89BC_194:;				
            _AA01D89BC_194:
            ; //_AA01D89BC_195:;				
            _AA01D89BC_195:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00336:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00337:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
00338:      	AR	= AX
00339:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0033A:      	AX	= rm[I1]
            ; //	io[0x36]	= sAX;			
0033B:      	AR	= AX
0033C:      	io[0x36]	= AR
            ; //L7F5A46A0_50:;					
            L7F5A46A0_50:
            ; //_AA01D89BC_196:;				
            _AA01D89BC_196:
            ; //_AA01D89BC_197:;				
            _AA01D89BC_197:
            ; //	sSI	= (int)&_p_1_2;			
0033D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0033E:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0033F:      	push	AX
            ; //	sSI	= (int)&_p_1_2;			
00340:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00341:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
00342:      	AR	= AX
00343:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00344:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00345:      	DX	= rm[I1--]
            ; //	PUSH(sDX);				
00346:      	push	DX
            ; //	PUSH(sAX);				
00347:      	push	AX
            ; //	sAX	= io[0x3C];			
00348:      	AR	= io[0x3C]
00349:      	AX	= AR
            ; //	sfx_INT2LONG_AX();			
0034A:      	DX	= 0
0034B:      	test	AX.b15
0034C:      	if ZR jmp L938F1786_0
0034D:      	DX = -1
            L938F1786_0:
            ; //	sCX	= POP();			
0034E:      	pop	CX
            ; //	sBX	= POP();			
0034F:      	pop	BX
            ; //	sfx_ADDLONG();				
00350:      	AR	= CX
00351:      	AX	= AX + AR
00352:      	AR	= BX
00353:      	DX	= DX + AR + C
            ; //	sSI	= POP();			
00354:      	pop	I1
            ; //	sfx_STORSILONG();			
00355:      	rm[I1++]	= AX
00356:      	rm[I1--]	= DX
            ; //	sSI	= (int)&_p_1_2;			
00357:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0002;			
00358:      	AR = 0x0002//
            ; //	sAX	= *(__int16*)sSI;		
00359:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
0035A:      	rm[I1] = AX + AR//
            ; //_AA01D89BC_198:;				
            _AA01D89BC_198:
            ; //	goto L7F5A46A0_47;			
0035B:      	jmp	L7F5A46A0_47
            ; //L7F5A46A0_46:;					
            L7F5A46A0_46:
            ; //	
            ; //_AA01D89BC_199:;				
            _AA01D89BC_199:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0035C:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0035D:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
0035E:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
0035F:      	AR	= CX
00360:      	AX	+= AR
            ; //_AA01D89BC_200:;				
            _AA01D89BC_200:
            ; //	asm	AR = AX				
00361:      	AR = AX
            ; //_AA01D89BC_201:;				
            _AA01D89BC_201:
            ; //	asm	I0 = AR				
00362:      	I0 = AR
            ; //	
            ; //	
            ; //_AA01D89BC_202:;				
            _AA01D89BC_202:
            ; //	sAX	= io[0x36];			
00363:      	AR	= io[0x36]
00364:      	AX	= AR
            ; //_AA01D89BC_203:;				
            _AA01D89BC_203:
            ; //	asm	rm[I0++] = AX			
00365:      	rm[I0++] = AX
            ; //	
            ; //_AA01D89BC_204:;				
            _AA01D89BC_204:
            ; //	sAX	= io[0x36];			
00366:      	AR	= io[0x36]
00367:      	AX	= AR
            ; //_AA01D89BC_205:;				
            _AA01D89BC_205:
            ; //	asm	rm[I0++] = AX			
00368:      	rm[I0++] = AX
            ; //	
            ; //_AA01D89BC_206:;				
            _AA01D89BC_206:
            ; //	sAX	= io[0x36];			
00369:      	AR	= io[0x36]
0036A:      	AX	= AR
            ; //_AA01D89BC_207:;				
            _AA01D89BC_207:
            ; //	asm	rm[I0++] = AX			
0036B:      	rm[I0++] = AX
            ; //	
            ; //_AA01D89BC_208:;				
            _AA01D89BC_208:
            ; //	sAX	= io[0x36];			
0036C:      	AR	= io[0x36]
0036D:      	AX	= AR
            ; //_AA01D89BC_209:;				
            _AA01D89BC_209:
            ; //	asm	rm[I0++] = AX			
0036E:      	rm[I0++] = AX
            ; //	
            ; //_AA01D89BC_210:;				
            _AA01D89BC_210:
            ; //	sAX	= io[0x3D];			
0036F:      	AR	= io[0x3D]
00370:      	AX	= AR
            ; //_AA01D89BC_211:;				
            _AA01D89BC_211:
            ; //	asm	rm[I0++] = AX			
00371:      	rm[I0++] = AX
            ; //L7F5A46A0_44:;					
            L7F5A46A0_44:
            ; //_AA01D89BC_212:;				
            _AA01D89BC_212:
            ; //L7F5A46A0_43:;					
            L7F5A46A0_43:
            ; //_AA01D89BC_213:;				
            _AA01D89BC_213:
            ; //	return;					
00372:      	AR	= 2
00373:      	BP	+= AR
00374:      	pop	AR
00375:      	rm[BP_SAVE]	= AR
00376:      	rets
            ; //L7F5A46A0_41_end:;				
            L7F5A46A0_41_end:
            ; //_AA01D89BC_214:;				
            _AA01D89BC_214:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_54()			
            L7F5A46A0_54:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00377:      	AR	= rm[BP_SAVE]
00378:      	push	AR
00379:      	AR	= BP
0037A:      	rm[BP_SAVE]	= AR
0037B:      	AR	 = -1
0037C:      	BP	+= AR
            ; //_AA01D89BC_215:;				
            _AA01D89BC_215:
            ; //	
            ; //_AA01D89BC_216:;				
            _AA01D89BC_216:
            ; //	asm I1 = inbuf+0;			
0037D:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
0037E:      	AX	= rm[I1]
            ; //_AA01D89BC_217:;				
            _AA01D89BC_217:
            ; //	asm	AR = AX				
0037F:      	AR = AX
            ; //_AA01D89BC_218:;				
            _AA01D89BC_218:
            ; //	asm	I0 = AR				
00380:      	I0 = AR
            ; //	
            ; //	
            ; //_AA01D89BC_219:;				
            _AA01D89BC_219:
            ; //	sAX	= io[0x33];			
00381:      	AR	= io[0x33]
00382:      	AX	= AR
            ; //_AA01D89BC_220:;				
            _AA01D89BC_220:
            ; //	_i_1_2+0	= 0x20;			
00383:      	I1	= rm[BP_SAVE]
00384:      	AX	= 0x20
00385:      	rm[I1]	= AX
            ; //L7F5A46A0_58:;					
            L7F5A46A0_58:
            ; //_AA01D89BC_221:;				
            _AA01D89BC_221:
            ; //	sSI	= (int)&_i_1_2;			
00386:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00387:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
00388:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00389:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0038A:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0038B:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0038C:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_59;	
0038D:      	if NZ	jmp L7F5A46A0_59
            ; //	goto	L7F5A46A0_57;			
0038E:      	jmp	L7F5A46A0_57
            ; //L7F5A46A0_59:;					
            L7F5A46A0_59:
            ; //	
            ; //_AA01D89BC_222:;				
            _AA01D89BC_222:
            ; //_AA01D89BC_223:;				
            _AA01D89BC_223:
            ; //	read_I0P();				
0038F:      	AX	= rm[I0++]
            ; //	io[0x33]	= sAX;			
00390:      	AR	= AX
00391:      	io[0x33]	= AR
            ; //_AA01D89BC_224:;				
            _AA01D89BC_224:
            ; //_AA01D89BC_225:;				
            _AA01D89BC_225:
            ; //	read_I0M();				
00392:      	AX	= rm[I0--]
            ; //	io[0x33]	= sAX;			
00393:      	AR	= AX
00394:      	io[0x33]	= AR
            ; //	
            ; //_AA01D89BC_226:;				
            _AA01D89BC_226:
            ; //	sAX	= io[0x33];			
00395:      	AR	= io[0x33]
00396:      	AX	= AR
            ; //_AA01D89BC_227:;				
            _AA01D89BC_227:
            ; //	asm	rm[I0++2] = AX			
00397:      	rm[I0++2] = AX
            ; //_AA01D89BC_228:;				
            _AA01D89BC_228:
            ; //	goto L7F5A46A0_58;			
00398:      	jmp	L7F5A46A0_58
            ; //L7F5A46A0_57:;					
            L7F5A46A0_57:
            ; //_AA01D89BC_229:;				
            _AA01D89BC_229:
            ; //	asm I1 = inbuf+0;			
00399:      	I1 = inbuf+0//
            ; //	asm AR = rm[I1];			
0039A:      	AR = rm[I1]//
            ; //	asm not AR.b6;				
0039B:      	not AR.b6//
            ; //	asm rm[I1] = AR;			
0039C:      	rm[I1] = AR//
            ; //L7F5A46A0_56:;					
            L7F5A46A0_56:
            ; //_AA01D89BC_230:;				
            _AA01D89BC_230:
            ; //	return;					
0039D:      	AR	= 1
0039E:      	BP	+= AR
0039F:      	pop	AR
003A0:      	rm[BP_SAVE]	= AR
003A1:      	rets
            ; //L7F5A46A0_54_end:;				
            L7F5A46A0_54_end:
            ; //_AA01D89BC_231:;				
            _AA01D89BC_231:
            ; //}
            ; //
            ; //rjmp void _DoADPCM9CD0E20D()			
            _DoADPCM9CD0E20D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //						
003A2:      	AR	= rm[BP_SAVE]
003A3:      	push	AR
003A4:      	AR	= BP
003A5:      	rm[BP_SAVE]	= AR
003A6:      	AR	 = -2
003A7:      	BP	+= AR
            ; //_AA01D89BC_232:;				
            _AA01D89BC_232:
            ; //	
            ; //_AA01D89BC_233:;				
            _AA01D89BC_233:
            ; //	asm I1 = inbuf+0;			
003A8:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
003A9:      	AX	= rm[I1]
            ; //	asm I1 = outbuf+0;			
003AA:      	I1 = outbuf+0//
            ; //	asm AR = rm[I1];			
003AB:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
003AC:      	AX = AX ^ AR//
            ; //	asm AR = 0x0040;			
003AD:      	AR = 0x0040//
            ; //	asm AX = AX & AR;			
003AE:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003AF:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_62;	
003B0:      	if ZR	jmp L7F5A46A0_62
            ; //	goto	L7F5A46A0_61;			
003B1:      	jmp	L7F5A46A0_61
            ; //L7F5A46A0_62:;					
            L7F5A46A0_62:
            ; //_AA01D89BC_234:;				
            _AA01D89BC_234:
            ; //	goto L7F5A46A0_60;			
003B2:      	jmp	L7F5A46A0_60
            ; //L7F5A46A0_61:;					
            L7F5A46A0_61:
            ; //_AA01D89BC_235:;				
            _AA01D89BC_235:
            ; //_AA01D89BC_236:;				
            _AA01D89BC_236:
            ; //	asm set io[0x09].b0;			
003B3:      	set io[0x09].b0//
            ; //_AA01D89BC_237:;				
            _AA01D89BC_237:
            ; //_AA01D89BC_238:;				
            _AA01D89BC_238:
            ; //	L7F5A46A0_35();				
003B4:      	pch	= L7F5A46A0_35
003B5:      	lcall	L7F5A46A0_35
            ; //_AA01D89BC_239:;				
            _AA01D89BC_239:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
003B6:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	sSI	= (int)&_p_1_4;			
003B7:      	AR	= -1
003B8:      	I1	= rm[BP_SAVE]
003B9:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003BA:      	rm[I1]	= AX
            ; //_AA01D89BC_240:;				
            _AA01D89BC_240:
            ; //	asm AX = _adpch30670376+0;		
003BB:      	AX = _adpch30670376+0//
            ; //	asm I1 = ADPCM_Tmpi+0;			
003BC:      	I1 = ADPCM_Tmpi+0//
            ; //	*(__int16*)sSI	= sAX			
003BD:      	rm[I1]	= AX
            ; //_AA01D89BC_241:;				
            _AA01D89BC_241:
            ; //	_i_1_2+0	= 0x02;			
003BE:      	I1	= rm[BP_SAVE]
003BF:      	AX	= 0x02
003C0:      	rm[I1]	= AX
            ; //L7F5A46A0_64:;					
            L7F5A46A0_64:
            ; //_AA01D89BC_242:;				
            _AA01D89BC_242:
            ; //	sSI	= (int)&_i_1_2;			
003C1:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003C2:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003C3:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003C4:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003C5:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003C6:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003C7:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_65;	
003C8:      	if NZ	jmp L7F5A46A0_65
            ; //	goto	L7F5A46A0_63;			
003C9:      	jmp	L7F5A46A0_63
            ; //L7F5A46A0_65:;					
            L7F5A46A0_65:
            ; //	
            ; //_AA01D89BC_243:;				
            _AA01D89BC_243:
            ; //_AA01D89BC_244:;				
            _AA01D89BC_244:
            ; //	sSI	= (int)&_p_1_4;			
003CA:      	AR	= -1
003CB:      	I1	= rm[BP_SAVE]
003CC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003CD:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
003CE:      	AR	= -1
003CF:      	I1	= rm[BP_SAVE]
003D0:      	I1	+= AR
            ; //	asm AR = 0x0001;			
003D1:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003D2:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003D3:      	rm[I1] = CX + AR//
            ; //	sSI	= sAX;				
003D4:      	AR	= AX
003D5:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
003D6:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
003D7:      	push	AX
            ; //	L7F5A46A0_41(STACK[sSP + 0]);		
003D8:      	pch	= L7F5A46A0_41
003D9:      	lcall	L7F5A46A0_41
            ; //	RESTORESP(1);				
003DA:      	pop	AR
            ; //_AA01D89BC_245:;				
            _AA01D89BC_245:
            ; //	asm I1 = ADPCM_Tmpi+0;			
003DB:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
003DC:      	AX	= rm[I1]
            ; //	sSI	= (int)&ADPCM_Tmpi;		
003DD:      	I1	= ADPCM_Tmpi
            ; //	sCX	= *(__int16*)sSI;		
003DE:      	CX	= rm[I1]
            ; //	asm AR = 0x0012;			
003DF:      	AR = 0x0012//
            ; //	asm rm[I1] = CX + AR;			
003E0:      	rm[I1] = CX + AR//
            ; //_AA01D89BC_246:;				
            _AA01D89BC_246:
            ; //	asm set io[0x09].b0;			
003E1:      	set io[0x09].b0//
            ; //_AA01D89BC_247:;				
            _AA01D89BC_247:
            ; //	goto L7F5A46A0_64;			
003E2:      	jmp	L7F5A46A0_64
            ; //L7F5A46A0_63:;					
            L7F5A46A0_63:
            ; //_AA01D89BC_248:;				
            _AA01D89BC_248:
            ; //_AA01D89BC_249:;				
            _AA01D89BC_249:
            ; //	L7F5A46A0_54();				
003E3:      	pch	= L7F5A46A0_54
003E4:      	lcall	L7F5A46A0_54
            ; //_AA01D89BC_250:;				
            _AA01D89BC_250:
            ; //	asm clr io[0x09].b0;			
003E5:      	clr io[0x09].b0//
            ; //_AA01D89BC_251:;				
            _AA01D89BC_251:
            ; //	asm clr io[0x09].b0;			
003E6:      	clr io[0x09].b0//
            ; //L7F5A46A0_60:;					
            L7F5A46A0_60:
            ; //_AA01D89BC_252:;				
            _AA01D89BC_252:
            ; //	return;					
003E7:      	AR	= 2
003E8:      	BP	+= AR
003E9:      	pop	AR
003EA:      	rm[BP_SAVE]	= AR
003EB:      	rets
            ; //_DoADPCM9CD0E20D_end:;				
            _DoADPCM9CD0E20D_end:
            ; //_AA01D89BC_253:;				
            _AA01D89BC_253:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_67,L5589D4CE_68,L5589D4CE_69 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_AA01D89BC_254:;				
            _AA01D89BC_254:
            ; //	
            ; //_AA01D89BC_255:;				
            _AA01D89BC_255:
            ; //	asm clr io[0x04].b0;			
003EC:      	clr io[0x04].b0//
            ; //_AA01D89BC_256:;				
            _AA01D89BC_256:
            ; //	asm clr io[0x04].b1;			
003ED:      	clr io[0x04].b1//
            ; //_AA01D89BC_257:;				
            _AA01D89BC_257:
            ; //	asm clr io[0x04].b2;			
003EE:      	clr io[0x04].b2//
            ; //_AA01D89BC_258:;				
            _AA01D89BC_258:
            ; //	io[0x1E]	= 0x0005;		
003EF:      	AR	= 0x05
003F0:      	io[0x1E]	= AR
            ; //_AA01D89BC_259:;				
            _AA01D89BC_259:
            ; //	sAX	= 0x0007;			
003F1:      	AX	= 0x07
            ; //	sAX	= sAX | io[0x1F];		
003F2:      	AR	= io[0x1F]
003F3:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
003F4:      	AR	= AX
003F5:      	io[0x1F]	= AR
            ; //_AA01D89BC_260:;				
            _AA01D89BC_260:
            ; //	sAX	= 0x0000;			
003F6:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_67;		
003F7:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
003F8:      	rm[I1]	= AX
            ; //_AA01D89BC_261:;				
            _AA01D89BC_261:
            ; //	sAX	= 0x0000;			
003F9:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_68;		
003FA:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
003FB:      	rm[I1]	= AX
            ; //_AA01D89BC_262:;				
            _AA01D89BC_262:
            ; //	sAX	= 0x0200;			
003FC:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
003FE:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
003FF:      	rm[I1]	= AX
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //_AA01D89BC_263:;				
            _AA01D89BC_263:
            ; //	return;					
00400:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_AA01D89BC_264:;				
            _AA01D89BC_264:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_71()			
            L5589D4CE_71:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
00401:      	AR	= rm[BP_SAVE]
00402:      	push	AR
00403:      	AR	= BP
00404:      	rm[BP_SAVE]	= AR
00405:      	AR	 = -1
00406:      	BP	+= AR
            ; //_AA01D89BC_265:;				
            _AA01D89BC_265:
            ; //	
            ; //_AA01D89BC_266:;				
            _AA01D89BC_266:
            ; //	sAX	= 0x000F;			
00407:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
00408:      	AR	= io[0x07]
00409:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
0040A:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0040B:      	rm[I1]	= AX
            ; //_AA01D89BC_267:;				
            _AA01D89BC_267:
            ; //	sSI	= (int)&_btn_1_2;		
0040C:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0040D:      	AX	= rm[I1]
            ; //	goto L5589D4CE_73;			
0040E:      	jmp	L5589D4CE_73
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //_AA01D89BC_268:;				
            _AA01D89BC_268:
            ; //	return;					
0040F:      	AR	= 1
00410:      	BP	+= AR
00411:      	pop	AR
00412:      	rm[BP_SAVE]	= AR
00413:      	rets
            ; //L5589D4CE_71_end:;				
            L5589D4CE_71_end:
            ; //_AA01D89BC_269:;				
            _AA01D89BC_269:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
00414:      	AR	= rm[BP_SAVE]
00415:      	push	AR
00416:      	AR	= BP
00417:      	rm[BP_SAVE]	= AR
00418:      	AR	 = -5
00419:      	BP	+= AR
            ; //_AA01D89BC_270:;				
            _AA01D89BC_270:
            ; //	
            ; //_AA01D89BC_271:;				
            _AA01D89BC_271:
            ; //_AA01D89BC_272:;				
            _AA01D89BC_272:
            ; //	NEARCALL(L5589D4CE_71);			
0041A:      	call	L5589D4CE_71
            ; //	sSI	= (int)&_keynow_1_2;		
0041B:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0041C:      	rm[I1]	= AX
            ; //_AA01D89BC_273:;				
            _AA01D89BC_273:
            ; //	asm I1 = L5589D4CE_67+0;		
0041D:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
0041E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
0041F:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00420:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00421:      	pch	= sfx_CMP_AX_CX_JNE
00422:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_76;	
00423:      	if ZR	jmp L5589D4CE_76
            ; //	goto	L5589D4CE_75;			
00424:      	jmp	L5589D4CE_75
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //	
            ; //_AA01D89BC_274:;				
            _AA01D89BC_274:
            ; //	sSI	= (int)&_keynow_1_2;		
00425:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00426:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_67;		
00427:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
00428:      	rm[I1]	= AX
            ; //_AA01D89BC_275:;				
            _AA01D89BC_275:
            ; //	sAX	= 0x0200;			
00429:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
0042B:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
0042C:      	rm[I1]	= AX
            ; //_AA01D89BC_276:;				
            _AA01D89BC_276:
            ; //	goto L5589D4CE_74;			
0042D:      	jmp	L5589D4CE_74
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //_AA01D89BC_277:;				
            _AA01D89BC_277:
            ; //_AA01D89BC_278:;				
            _AA01D89BC_278:
            ; //	asm I1 = L5589D4CE_69+0;		
0042E:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
0042F:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00430:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_78;	
00431:      	if NZ	jmp L5589D4CE_78
            ; //	goto	L5589D4CE_77;			
00432:      	jmp	L5589D4CE_77
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //	
            ; //_AA01D89BC_279:;				
            _AA01D89BC_279:
            ; //	asm I1 = L5589D4CE_69+0;		
00433:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
00434:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00435:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
00436:      	AR	= CX
00437:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_69;		
00438:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00439:      	rm[I1]	= AX
            ; //_AA01D89BC_280:;				
            _AA01D89BC_280:
            ; //	goto L5589D4CE_74;			
0043A:      	jmp	L5589D4CE_74
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //_AA01D89BC_281:;				
            _AA01D89BC_281:
            ; //_AA01D89BC_282:;				
            _AA01D89BC_282:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
0043B:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
0043D:      	AR	= -4
0043E:      	I1	= rm[BP_SAVE]
0043F:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00440:      	rm[I1]	= AX
            ; //_AA01D89BC_283:;				
            _AA01D89BC_283:
            ; //	sAX	= 0x0200;			
00441:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
00443:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00444:      	rm[I1]	= AX
            ; //_AA01D89BC_284:;				
            _AA01D89BC_284:
            ; //	asm I1 = L5589D4CE_68+0;		
00445:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
00446:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_67+0;		
00447:      	I1 = L5589D4CE_67+0//
            ; //	asm AR = rm[I1];			
00448:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
00449:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0044A:      	AR	= -2
0044B:      	I1	= rm[BP_SAVE]
0044C:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0044D:      	rm[I1]	= AX
            ; //_AA01D89BC_285:;				
            _AA01D89BC_285:
            ; //	asm I1 = L5589D4CE_68+0;		
0044E:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
0044F:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00450:      	AR	= -3
00451:      	I1	= rm[BP_SAVE]
00452:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00453:      	rm[I1]	= AX
            ; //_AA01D89BC_286:;				
            _AA01D89BC_286:
            ; //	asm I1 = L5589D4CE_67+0;		
00454:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
00455:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_68;		
00456:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
00457:      	rm[I1]	= AX
            ; //_AA01D89BC_287:;				
            _AA01D89BC_287:
            ; //	_i_1_4+0	= 0x05;			
00458:      	AR	= -1
00459:      	I1	= rm[BP_SAVE]
0045A:      	I1	+= AR
0045B:      	AX	= 0x05
0045C:      	rm[I1]	= AX
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //_AA01D89BC_288:;				
            _AA01D89BC_288:
            ; //	sSI	= (int)&_i_1_4;			
0045D:      	AR	= -1
0045E:      	I1	= rm[BP_SAVE]
0045F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00460:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00461:      	AR	= -1
00462:      	I1	= rm[BP_SAVE]
00463:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00464:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00465:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00466:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00467:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_81;	
00468:      	if NZ	jmp L5589D4CE_81
            ; //	goto	L5589D4CE_79;			
00469:      	jmp	L5589D4CE_79
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	
            ; //_AA01D89BC_289:;				
            _AA01D89BC_289:
            ; //	sAX	= 0;				
0046A:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
0046B:      	AR	= -2
0046C:      	I1	= rm[BP_SAVE]
0046D:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0046E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0046F:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_83;		
00470:      	if ZR	jmp L5589D4CE_83
            ; //	sAX	= 1;				
00471:      	AX	= 0x01
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //	sfx_CHECKZERO();			
00472:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_84;	
00473:      	if NZ	jmp L5589D4CE_84
            ; //	goto	L5589D4CE_82;			
00474:      	jmp	L5589D4CE_82
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //	
            ; //_AA01D89BC_290:;				
            _AA01D89BC_290:
            ; //	sAX	= 0;				
00475:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
00476:      	AR	= -3
00477:      	I1	= rm[BP_SAVE]
00478:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00479:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0047A:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_86;		
0047B:      	if ZR	jmp L5589D4CE_86
            ; //	sAX	= 1;				
0047C:      	AX	= 0x01
            ; //L5589D4CE_86:;					
            L5589D4CE_86:
            ; //	sfx_CHECKZERO();			
0047D:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_87;	
0047E:      	if NZ	jmp L5589D4CE_87
            ; //	goto	L5589D4CE_85;			
0047F:      	jmp	L5589D4CE_85
            ; //L5589D4CE_87:;					
            L5589D4CE_87:
            ; //	
            ; //_AA01D89BC_291:;				
            _AA01D89BC_291:
            ; //	sSI	= (int)&_pkey_1_10;		
00480:      	AR	= -4
00481:      	I1	= rm[BP_SAVE]
00482:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00483:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00484:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00485:      	AR	= CX
00486:      	AX	+= AR
            ; //	sDI	= sAX;				
00487:      	AR	= AX
00488:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00489:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0048A:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_89;	
0048B:      	if NZ	jmp L5589D4CE_89
            ; //	goto	L5589D4CE_88;			
0048C:      	jmp	L5589D4CE_88
            ; //L5589D4CE_89:;					
            L5589D4CE_89:
            ; //_AA01D89BC_292:;				
            _AA01D89BC_292:
            ; //_AA01D89BC_293:;				
            _AA01D89BC_293:
            ; //	sSI	= (int)&_pkey_1_10;		
0048D:      	AR	= -4
0048E:      	I1	= rm[BP_SAVE]
0048F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00490:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00491:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00492:      	AR	= CX
00493:      	AX	+= AR
            ; //	sDI	= sAX;				
00494:      	AR	= AX
00495:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00496:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00497:      	AR	= AX
00498:      	P1	= AR
00499:      	P1.hh	= 0
0049A:      	fcall	pm[P1]
            ; //L5589D4CE_88:;					
            L5589D4CE_88:
            ; //_AA01D89BC_294:;				
            _AA01D89BC_294:
            ; //	goto L5589D4CE_90;			
0049B:      	jmp	L5589D4CE_90
            ; //L5589D4CE_85:;					
            L5589D4CE_85:
            ; //	
            ; //_AA01D89BC_295:;				
            _AA01D89BC_295:
            ; //	sSI	= (int)&_pkey_1_10;		
0049C:      	AR	= -4
0049D:      	I1	= rm[BP_SAVE]
0049E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0049F:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004A0:      	AR	= AX
004A1:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004A2:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004A3:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_92;	
004A4:      	if NZ	jmp L5589D4CE_92
            ; //	goto	L5589D4CE_91;			
004A5:      	jmp	L5589D4CE_91
            ; //L5589D4CE_92:;					
            L5589D4CE_92:
            ; //_AA01D89BC_296:;				
            _AA01D89BC_296:
            ; //_AA01D89BC_297:;				
            _AA01D89BC_297:
            ; //	sSI	= (int)&_pkey_1_10;		
004A6:      	AR	= -4
004A7:      	I1	= rm[BP_SAVE]
004A8:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004A9:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004AA:      	AR	= AX
004AB:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004AC:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004AD:      	AR	= AX
004AE:      	P1	= AR
004AF:      	P1.hh	= 0
004B0:      	fcall	pm[P1]
            ; //L5589D4CE_91:;					
            L5589D4CE_91:
            ; //_AA01D89BC_298:;				
            _AA01D89BC_298:
            ; //L5589D4CE_90:;					
            L5589D4CE_90:
            ; //_AA01D89BC_299:;				
            _AA01D89BC_299:
            ; //	goto L5589D4CE_93;			
004B1:      	jmp	L5589D4CE_93
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //	
            ; //_AA01D89BC_300:;				
            _AA01D89BC_300:
            ; //	sAX	= 0;				
004B2:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
004B3:      	AR	= -3
004B4:      	I1	= rm[BP_SAVE]
004B5:      	I1	+= AR
            ; //	asm AR = rm[I1];			
004B6:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
004B7:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_95;		
004B8:      	if ZR	jmp L5589D4CE_95
            ; //	sAX	= 1;				
004B9:      	AX	= 0x01
            ; //L5589D4CE_95:;					
            L5589D4CE_95:
            ; //	sfx_CHECKZERO();			
004BA:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_96;	
004BB:      	if NZ	jmp L5589D4CE_96
            ; //	goto	L5589D4CE_94;			
004BC:      	jmp	L5589D4CE_94
            ; //L5589D4CE_96:;					
            L5589D4CE_96:
            ; //	
            ; //_AA01D89BC_301:;				
            _AA01D89BC_301:
            ; //	sSI	= (int)&_pkey_1_10;		
004BD:      	AR	= -4
004BE:      	I1	= rm[BP_SAVE]
004BF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004C0:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004C1:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004C2:      	AR	= CX
004C3:      	AX	+= AR
            ; //	sDI	= sAX;				
004C4:      	AR	= AX
004C5:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004C6:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004C7:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_98;	
004C8:      	if NZ	jmp L5589D4CE_98
            ; //	goto	L5589D4CE_97;			
004C9:      	jmp	L5589D4CE_97
            ; //L5589D4CE_98:;					
            L5589D4CE_98:
            ; //_AA01D89BC_302:;				
            _AA01D89BC_302:
            ; //_AA01D89BC_303:;				
            _AA01D89BC_303:
            ; //	sSI	= (int)&_pkey_1_10;		
004CA:      	AR	= -4
004CB:      	I1	= rm[BP_SAVE]
004CC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004CD:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004CE:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004CF:      	AR	= CX
004D0:      	AX	+= AR
            ; //	sDI	= sAX;				
004D1:      	AR	= AX
004D2:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004D3:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004D4:      	AR	= AX
004D5:      	P1	= AR
004D6:      	P1.hh	= 0
004D7:      	fcall	pm[P1]
            ; //L5589D4CE_97:;					
            L5589D4CE_97:
            ; //_AA01D89BC_304:;				
            _AA01D89BC_304:
            ; //L5589D4CE_94:;					
            L5589D4CE_94:
            ; //_AA01D89BC_305:;				
            _AA01D89BC_305:
            ; //L5589D4CE_93:;					
            L5589D4CE_93:
            ; //_AA01D89BC_306:;				
            _AA01D89BC_306:
            ; //_AA01D89BC_307:;				
            _AA01D89BC_307:
            ; //	sSI	= (int)&_bits_1_6;		
004D8:      	AR	= -2
004D9:      	I1	= rm[BP_SAVE]
004DA:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004DB:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004DC:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
004DD:      	AR	= -2
004DE:      	I1	= rm[BP_SAVE]
004DF:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004E0:      	rm[I1]	= AX
            ; //_AA01D89BC_308:;				
            _AA01D89BC_308:
            ; //	sSI	= (int)&_bitp_1_8;		
004E1:      	AR	= -3
004E2:      	I1	= rm[BP_SAVE]
004E3:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004E4:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004E5:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
004E6:      	AR	= -3
004E7:      	I1	= rm[BP_SAVE]
004E8:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004E9:      	rm[I1]	= AX
            ; //_AA01D89BC_309:;				
            _AA01D89BC_309:
            ; //	sSI	= (int)&_pkey_1_10;		
004EA:      	AR	= -4
004EB:      	I1	= rm[BP_SAVE]
004EC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004ED:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
004EE:      	AR	= -4
004EF:      	I1	= rm[BP_SAVE]
004F0:      	I1	+= AR
            ; //	asm AR = 0x0003;			
004F1:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
004F2:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
004F3:      	rm[I1] = CX + AR//
            ; //_AA01D89BC_310:;				
            _AA01D89BC_310:
            ; //	goto L5589D4CE_80;			
004F4:      	jmp	L5589D4CE_80
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //_AA01D89BC_311:;				
            _AA01D89BC_311:
            ; //	return;					
004F5:      	AR	= 5
004F6:      	BP	+= AR
004F7:      	pop	AR
004F8:      	rm[BP_SAVE]	= AR
004F9:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_AA01D89BC_312:;				
            _AA01D89BC_312:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> Start=========================
            ; linkfile.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void ADPCM_CH0_Data();
            ; //naked void ADPCM_CH1_Data();
            ; //naked void ADPCM_CH2_Data();
            ; //naked void ADPCM_CH3_Data();
            ; //naked void ADPCM_CH4_Data();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _adpdata32993E3B[24] = {		
            _adpdata32993E3B:
            ; //	(int)&ADPCM_CH0_Data, (int)&ADPCM_CH0_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH1_Data, (int)&ADPCM_CH1_Data.h|0x0800, 0x3FFF, 0x003F, 
004FA:      DW #ADPCM_CH0_Data,#ADPCM_CH0_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH1_Data,#ADPCM_CH1_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH2_Data, (int)&ADPCM_CH2_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH3_Data, (int)&ADPCM_CH3_Data.h|0x0800, 0x3FFF, 0x003F, 
00502:      DW #ADPCM_CH2_Data,#ADPCM_CH2_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH3_Data,#ADPCM_CH3_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH4_Data, (int)&ADPCM_CH4_Data.h|0x0800, 0x3FFF, 0x003F, 0x0000, 0x0000, 0x0000, 0x0000
0050A:      DW #ADPCM_CH4_Data,#ADPCM_CH4_Data.h|0x0800,0x3FFF,0x003F,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void ADPCM_CH0_Data()			
            ADPCM_CH0_Data:
            ; //{
            ; //	asm	DW "adpcm\bird_8000_4-12.xam"	
00D9D:      DW "adpcm\bird_8000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH1_Data()			
            ADPCM_CH1_Data:
            ; //{
            ; //	asm	DW "adpcm\horse_16000_4-12.xam"	
030E1:      DW "adpcm\horse_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH2_Data()			
            ADPCM_CH2_Data:
            ; //{
            ; //	asm	DW "adpcm\2cat_16000_4-12.xam"	
048B3:      DW "adpcm\2cat_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH3_Data()			
            ADPCM_CH3_Data:
            ; //{
            ; //	asm	DW "adpcm\cat_16000_4-12.xam"	
050F8:      DW "adpcm\cat_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH4_Data()			
            ADPCM_CH4_Data:
            ; //{
            ; //	asm	DW "adpcm\Dog_Barking_002_16000_4-12.xam"
06432:      DW "adpcm\Dog_Barking_002_16000_4-12.xam"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\TOUCH_AB036625.S.CODE.ASM> Start=========================
            ; touch.c Code Start!!;
            VarRM[0:4095]={
             L0DC315BC_101,_pE0B41DE7 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //void _touch_init378E5983();
            ; //interrupt void _Touch_entry886E03ED();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //void _touch_init378E5983()			
            _touch_init378E5983:
            ; //{
            ; //_AA01D89BC_313:;				
            _AA01D89BC_313:
            ; //	
            ; //_AA01D89BC_314:;				
            _AA01D89BC_314:
            ; //	io[0x19]	= 0x007C;		
00512:      	AR	= 0x7C
00513:      	io[0x19]	= AR
            ; //_AA01D89BC_315:;				
            _AA01D89BC_315:
            ; //	asm clr io[0x19].b0;			
00514:      	clr io[0x19].b0//
            ; //_AA01D89BC_316:;				
            _AA01D89BC_316:
            ; //	asm clr io[0x19].b1;			
00515:      	clr io[0x19].b1//
            ; //_AA01D89BC_317:;				
            _AA01D89BC_317:
            ; //	asm set io[0x19].b2;			
00516:      	set io[0x19].b2//
            ; //_AA01D89BC_318:;				
            _AA01D89BC_318:
            ; //	asm clr io[0x19].b3;			
00517:      	clr io[0x19].b3//
            ; //_AA01D89BC_319:;				
            _AA01D89BC_319:
            ; //	asm set io[0x19].b4;			
00518:      	set io[0x19].b4//
            ; //_AA01D89BC_320:;				
            _AA01D89BC_320:
            ; //	asm clr io[0x19].b5;			
00519:      	clr io[0x19].b5//
            ; //_AA01D89BC_321:;				
            _AA01D89BC_321:
            ; //	asm set io[0x19].b6;			
0051A:      	set io[0x19].b6//
            ; //_AA01D89BC_322:;				
            _AA01D89BC_322:
            ; //	asm set io[0x19].b7;			
0051B:      	set io[0x19].b7//
            ; //_AA01D89BC_323:;				
            _AA01D89BC_323:
            ; //	io[0x1E]	= 0x000E;		
0051C:      	AR	= 0x0E
0051D:      	io[0x1E]	= AR
            ; //_AA01D89BC_324:;				
            _AA01D89BC_324:
            ; //	io[0x1F]	= 0x000F;		
0051E:      	AR	= 0x0F
0051F:      	io[0x1F]	= AR
            ; //_AA01D89BC_325:;				
            _AA01D89BC_325:
            ; //	asm	set io[INTENA].b5		
00520:      	set io[INTENA].b5
            ; //L0DC315BC_102:;					
            L0DC315BC_102:
            ; //_AA01D89BC_326:;				
            _AA01D89BC_326:
            ; //	return;					
00521:      	rets
            ; //_touch_init378E5983_end:;			
            _touch_init378E5983_end:
            ; //_AA01D89BC_327:;				
            _AA01D89BC_327:
            ; //}
            ; //
            ; //interrupt void _Touch_entry886E03ED()		
            _Touch_entry886E03ED:
            ; //{						
00522:      	push ax
00523:      	push bx
00524:      	push cx
00525:      	push dx
00526:      	push r0
00527:      	push r1
00528:      	push r2
00529:      	push r3
0052A:      	push i1
0052B:      	push p1
0052C:      	push mx
0052D:      	push mr0
0052E:      	push mr1
0052F:      	push mr2
00530:      	ar = p1.hh
00531:      	push ar
            ; //_AA01D89BC_328:;				
            _AA01D89BC_328:
            ; //	
            ; //_AA01D89BC_329:;				
            _AA01D89BC_329:
            ; //	sAX	= 0;				
00532:      	AX	= 0x00
            ; //	asm test io[0x02].b5;			
00533:      	test io[0x02].b5//
            ; //	if(__jz__) goto L0DC315BC_104;		
00534:      	if ZR	jmp L0DC315BC_104
            ; //	sAX	= 1;				
00535:      	AX	= 0x01
            ; //L0DC315BC_104:;					
            L0DC315BC_104:
            ; //	sCX	= 0x0001;			
00536:      	CX	= 0x01
            ; //	sfx_CMP_AX_CX_JE();			
00537:      	AR	= AX
00538:      	SF = AR - CX
            ; //	if(__je__)	goto L0DC315BC_106;	
00539:      	if ZR	jmp L0DC315BC_106
            ; //	goto	L0DC315BC_105;			
0053A:      	pch =	L0DC315BC_105
0053B:      	ljmp	L0DC315BC_105
            ; //L0DC315BC_106:;					
            L0DC315BC_106:
            ; //_AA01D89BC_330:;				
            _AA01D89BC_330:
            ; //	asm	clr io[INTREQ].b5		
0053C:      	clr io[INTREQ].b5
            ; //	
            ; //L0DC315BC_105:;					
            L0DC315BC_105:
            ; //_AA01D89BC_331:;				
            _AA01D89BC_331:
            ; //_AA01D89BC_332:;				
            _AA01D89BC_332:
            ; //	asm I1 = L0DC315BC_101+0;		
0053D:      	I1 = L0DC315BC_101+0//
            ; //	sAX	= *(__int16*)sSI;		
0053E:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
0053F:      	CX	= 0x01
            ; //	sfx_CMP_AX_CX_JE();			
00540:      	AR	= AX
00541:      	SF = AR - CX
            ; //	if(__je__)	goto L0DC315BC_108;	
00542:      	if ZR	jmp L0DC315BC_108
            ; //	goto	L0DC315BC_107;			
00543:      	pch =	L0DC315BC_107
00544:      	ljmp	L0DC315BC_107
            ; //L0DC315BC_108:;					
            L0DC315BC_108:
            ; //	
            ; //_AA01D89BC_333:;				
            _AA01D89BC_333:
            ; //	io[0x08]	= 0x000F;		
00545:      	AR	= 0x0F
00546:      	io[0x08]	= AR
            ; //_AA01D89BC_334:;				
            _AA01D89BC_334:
            ; //	sAX	= 0x0000;			
00547:      	AX	= 0x00
            ; //	sSI	= (int)&L0DC315BC_101;		
00548:      	I1	= L0DC315BC_101
            ; //	*(__int16*)sSI	= sAX			
00549:      	rm[I1]	= AX
            ; //	goto L0DC315BC_109;			
0054A:      	pch =	L0DC315BC_109
0054B:      	ljmp	L0DC315BC_109
            ; //L0DC315BC_107:;					
            L0DC315BC_107:
            ; //	
            ; //_AA01D89BC_335:;				
            _AA01D89BC_335:
            ; //	asm I1 = L0DC315BC_101+0;		
0054C:      	I1 = L0DC315BC_101+0//
            ; //	sAX	= *(__int16*)sSI;		
0054D:      	AX	= rm[I1]
            ; //	sSI	= (int)&L0DC315BC_101;		
0054E:      	I1	= L0DC315BC_101
            ; //	PUSH(sAX);				
0054F:      	push	AX
            ; //	sAX	= 0x0001;			
00550:      	AX	= 0x01
            ; //	sCX	= *(__int16*)sSI;		
00551:      	CX	= rm[I1]
            ; //	sCX	= sCX + sAX;			
00552:      	AR	= AX
00553:      	CX	+= AR
            ; //	*(__int16*)sSI	= sCX;			
00554:      	rm[I1]	= CX
            ; //	sAX	= POP();			
00555:      	pop	AX
            ; //_AA01D89BC_336:;				
            _AA01D89BC_336:
            ; //	io[0x08]	= 0x0000;		
00556:      	AR	= 0x00
00557:      	io[0x08]	= AR
            ; //L0DC315BC_109:;					
            L0DC315BC_109:
            ; //_AA01D89BC_337:;				
            _AA01D89BC_337:
            ; //L0DC315BC_103:;					
            L0DC315BC_103:
            ; //_AA01D89BC_338:;				
            _AA01D89BC_338:
            ; //	return;					
00558:      	pop ar
00559:      	p1.hh = ar
0055A:      	pop mr2
0055B:      	pop mr1
0055C:      	pop mr0
0055D:      	pop mx
0055E:      	pop p1
0055F:      	pop i1
00560:      	pop r3
00561:      	pop r2
00562:      	pop r1
00563:      	pop r0
00564:      	pop dx
00565:      	pop cx
00566:      	pop bx
00567:      	pop ax
00568:      	reti
            ; //_Touch_entry886E03ED_end:;			
            _Touch_entry886E03ED_end:
            ; //_AA01D89BC_339:;				
            _AA01D89BC_339:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_touch_AB036625_s(void)	
            ginit_code_touch_AB036625_s:
            ; //{
            ; //	asm P1 = #ginit_seg_touch_AB036625_s+0;	
00569:      	P1 = #ginit_seg_touch_AB036625_s+0//
            ; //	asm I1 = L0DC315BC_101;			
0056C:      	I1 = L0DC315BC_101//
            ; //	sCX = 1;				
0056D:      	CX	= 0x01
            ; //	sfx_GLOBALINIT();			
0056E:      	pch	= sfx_GLOBALINIT
0056F:      	lcall	sfx_GLOBALINIT
            ; //
            ; //	return;					
00570:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 ginit_seg_touch_AB036625_s[1] = {	
            ginit_seg_touch_AB036625_s:
            ; //						
            DW 
            ; //	0x0000					
00571:      DW 0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\TOUCH_AB036625.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
00572:      	AR=		BP
00573:      	AR=		AR + 1		; ~~ value
00574:      	I1=		AR
00575:      	AR=		SATV
00576:      	AR=		rm[I1++]
00577:      	SATV=		AR
00578:      	AR=		rm[I1++]
00579:      	SATV=		AR
0057A:      	AR=		SATV
0057B:      	AX=		AR
0057C:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
0057D:      	AR=		BP
0057E:      	AR=		AR + 1		; ~~ value
0057F:      	I1=		AR
00580:      	ADPHD=		rm[I1]
00581:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
00582:      	AR=		ADPHD
00583:      	AX=		AR
00584:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
00585:      	AR=		BP
00586:      	AR=		AR + 1		; ~~ value
00587:      	I1=		AR
00588:      	ADPDAT=		rm[I1]
00589:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
0058A:      	AR=		ADPDAT
0058B:      	AX=		AR
0058C:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
0058D:      	AR=		ADPPCM
0058E:      	AX=		AR
0058F:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
00590:      	AR=		CBL
00591:      	AX=		AR
00592:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
00593:      	AR=		FLTO
00594:      	AX=		AR
00595:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
00596:      	AR=		FLTA
00597:      	AX=		AR
00598:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
00599:      	AR=		FLTP
0059A:      	AX=		AR
0059B:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
0059C:      	set		io[STATUS].b5
0059D:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
0059E:      	clr		io[STATUS].b5
0059F:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
005A0:      	set		io[STATUS].b8
005A1:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
005A2:      	clr		io[STATUS].b8
005A3:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
005A4:      	set		io[STATUS].b9
005A5:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
005A6:      	clr		io[STATUS].b9
005A7:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
005A8:      	set		io[STATUS].b11
005A9:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
005AA:      	clr		io[STATUS].b11
005AB:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
005AC:      	set		io[STATUS].b12
005AD:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
005AE:      	clr		io[STATUS].b12
005AF:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
005B0:      	set		io[STATUS].b13
005B1:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
005B2:      	clr		io[STATUS].b13
005B3:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
005B4:      	AR=		BP
005B5:      	AR=		AR + 1		; ~~ value
005B6:      	I1=		AR
005B7:      	AR=		rm[I1]
005B8:      	io[INTENA]=	AR
005B9:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
005BA:      	AR=		io[INTENA]
005BB:      	AX=		AR
005BC:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
005BD:      	AR=		BP
005BE:      	AR=		AR + 1		; ~~ value
005BF:      	I1=		AR
005C0:      	AR=		rm[I1]
005C1:      	io[INTREQ]	=AR
005C2:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
005C3:      	AR=		io[INTREQ]
005C4:      	AX=		AR
005C5:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
005C6:      	AR=		BP
005C7:      	AR=		AR + 1		; ~~ value
005C8:      	I1=		AR
005C9:      	AR=		rm[I1]
005CA:      	io[IntVect]	=AR
005CB:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
005CC:      	AR=		io[IntVect]
005CD:      	AX=		AR
005CE:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
005CF:      	AR=		io[IOC_PA]
005D0:      	AX=		AR
005D1:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
005D2:      	AR=		io[IOC_PB]
005D3:      	AX=		AR
005D4:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
005D5:      	AR=		io[IOC_PC]
005D6:      	AX=		AR
005D7:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
005D8:      	AR=		io[PortA]
005D9:      	AX=		AR
005DA:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
005DB:      	AR=		io[PortB]
005DC:      	AX=		AR
005DD:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
005DE:      	AR=		io[PortC]
005DF:      	AX=		AR
005E0:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
005E1:      	AR=		BP
005E2:      	AR=		AR + 1		; ~~ value
005E3:      	I1=		AR
005E4:      	AR=		rm[I1]
005E5:      	io[SPI_CTL]=	AR
005E6:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
005E7:      	AR=		io[SPI_CTL]
005E8:      	AX=		AR
005E9:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
005EA:      	AR=		BP
005EB:      	AR=		AR + 1		; ~~ value
005EC:      	I1=		AR
005ED:      	AR=		rm[I1]
005EE:      	io[SPI_DAT]=	AR
005EF:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
005F0:      	AR=		io[SPI_DAT]
005F1:      	AX=		AR
005F2:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
005F3:      	AR=		BP
005F4:      	AR=		AR + 1		; ~~ value
005F5:      	I1=		AR
005F6:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
005F7:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
005F8:      	AR=		io[MISC]
005F9:      	AX=		AR
005FA:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
005FB:      	AX=		AR
005FC:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
005FD:      	AR=		MACOP
005FE:      	AX=		AR
005FF:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
00600:      	AR=		BP
00601:      	AR=		AR + 1
00602:      	I1=		AR
00603:      	AR=		rm[I1]
00604:      	xchg		AR
00605:      	AX=		AR
00606:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
00607:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
00608:      	AX=		rm[I0]
00609:      	rets
            
            read_I0P:
0060A:      	AX=		rm[I0++]
0060B:      	rets
            
            read_I0P2:
0060C:      	AX=		rm[I0++2]
0060D:      	rets
            
            read_I0M:
0060E:      	AX=		rm[I0--]
0060F:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
00610:      	AR=		I0
00611:      	AX=		AR
00612:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
00613:      	AX=		pm[P0]
00614:      	rets
            
            read_P0P:
00615:      	AX=		pm[P0++]
00616:      	rets
            
            read_P0M:
00617:      	AX=		pm[P0--]
00618:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
00619:      	AR=		P0
0061A:      	AX=		AR
0061B:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
0061C:      	AX=		1
0061D:      	if FA jmp	@fa_label_1504
0061E:      	AX=		0
            @fa_label_1504:
0061F:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libc\memset.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_sC3E11DB1:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
00620:      	AR	= rm[BP_SAVE]
00621:      	push	AR
00622:      	AR	= BP
00623:      	rm[BP_SAVE]	= AR
00624:      	AR	 = -1
00625:      	BP	+= AR
            ; //_AA01D89BC_340:;				
            _AA01D89BC_340:
            ; //	
            ; //_AA01D89BC_341:;				
            _AA01D89BC_341:
            ; //	sSI	= (int)&_s_0_4;			
00626:      	AR	= 2
00627:      	I1	= rm[BP_SAVE]
00628:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00629:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
0062A:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0062B:      	rm[I1]	= AX
            ; //LF2D2B0F3_112:;					
            LF2D2B0F3_112:
            ; //_AA01D89BC_342:;				
            _AA01D89BC_342:
            ; //	sSI	= (int)&_n_0_8;			
0062C:      	AR	= 4
0062D:      	I1	= rm[BP_SAVE]
0062E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0062F:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00630:      	AR	= 4
00631:      	I1	= rm[BP_SAVE]
00632:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00633:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00634:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00635:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00636:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_113;	
00637:      	if NZ	jmp LF2D2B0F3_113
            ; //	goto	LF2D2B0F3_111;			
00638:      	jmp	LF2D2B0F3_111
            ; //LF2D2B0F3_113:;					
            LF2D2B0F3_113:
            ; //_AA01D89BC_343:;				
            _AA01D89BC_343:
            ; //	sSI	= (int)&_ret_1_2;		
00639:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0063A:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0063B:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
0063C:      	AR	= 3
0063D:      	I1	= rm[BP_SAVE]
0063E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0063F:      	AX	= rm[I1]
            ; //	sSI	= POP();			
00640:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00641:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00642:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00643:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
00644:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
00645:      	rm[I1] = AX + AR//
            ; //_AA01D89BC_344:;				
            _AA01D89BC_344:
            ; //	goto LF2D2B0F3_112;			
00646:      	jmp	LF2D2B0F3_112
            ; //LF2D2B0F3_111:;					
            LF2D2B0F3_111:
            ; //_AA01D89BC_345:;				
            _AA01D89BC_345:
            ; //	sSI	= (int)&_s_0_4;			
00647:      	AR	= 2
00648:      	I1	= rm[BP_SAVE]
00649:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0064A:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_110;			
0064B:      	jmp	LF2D2B0F3_110
            ; //LF2D2B0F3_110:;					
            LF2D2B0F3_110:
            ; //_AA01D89BC_346:;				
            _AA01D89BC_346:
            ; //	return;					
0064C:      	AR	= 1
0064D:      	BP	+= AR
0064E:      	pop	AR
0064F:      	rm[BP_SAVE]	= AR
00650:      	rets
            ; //_memset_sC3E11DB1_end:;				
            _memset_sC3E11DB1_end:
            ; //_AA01D89BC_347:;				
            _AA01D89BC_347:
            ; //}
            ; //
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_rC7200006:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
00651:      	AR	= rm[BP_SAVE]
00652:      	push	AR
00653:      	AR	= BP
00654:      	rm[BP_SAVE]	= AR
00655:      	AR	 = -1
00656:      	BP	+= AR
            ; //_AA01D89BC_348:;				
            _AA01D89BC_348:
            ; //	
            ; //_AA01D89BC_349:;				
            _AA01D89BC_349:
            ; //	sSI	= (int)&_s_0_4;			
00657:      	AR	= 2
00658:      	I1	= rm[BP_SAVE]
00659:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0065A:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
0065B:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0065C:      	rm[I1]	= AX
            ; //LF2D2B0F3_116:;					
            LF2D2B0F3_116:
            ; //_AA01D89BC_350:;				
            _AA01D89BC_350:
            ; //	sSI	= (int)&_n_0_8;			
0065D:      	AR	= 4
0065E:      	I1	= rm[BP_SAVE]
0065F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00660:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00661:      	AR	= 4
00662:      	I1	= rm[BP_SAVE]
00663:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00664:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00665:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00666:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00667:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_117;	
00668:      	if NZ	jmp LF2D2B0F3_117
            ; //	goto	LF2D2B0F3_115;			
00669:      	jmp	LF2D2B0F3_115
            ; //LF2D2B0F3_117:;					
            LF2D2B0F3_117:
            ; //_AA01D89BC_351:;				
            _AA01D89BC_351:
            ; //	sSI	= (int)&_ret_1_2;		
0066A:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0066B:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0066C:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
0066D:      	AR	= 3
0066E:      	I1	= rm[BP_SAVE]
0066F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00670:      	AX	= rm[I1]
            ; //	sSI	= POP();			
00671:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00672:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00673:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00674:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
00675:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
00676:      	rm[I1] = AX + AR//
            ; //_AA01D89BC_352:;				
            _AA01D89BC_352:
            ; //	goto LF2D2B0F3_116;			
00677:      	jmp	LF2D2B0F3_116
            ; //LF2D2B0F3_115:;					
            LF2D2B0F3_115:
            ; //_AA01D89BC_353:;				
            _AA01D89BC_353:
            ; //	sSI	= (int)&_s_0_4;			
00678:      	AR	= 2
00679:      	I1	= rm[BP_SAVE]
0067A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0067B:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_114;			
0067C:      	jmp	LF2D2B0F3_114
            ; //LF2D2B0F3_114:;					
            LF2D2B0F3_114:
            ; //_AA01D89BC_354:;				
            _AA01D89BC_354:
            ; //	return;					
0067D:      	AR	= 1
0067E:      	BP	+= AR
0067F:      	pop	AR
00680:      	rm[BP_SAVE]	= AR
00681:      	rets
            ; //_memset_rC7200006_end:;				
            _memset_rC7200006_end:
            ; //_AA01D89BC_355:;				
            _AA01D89BC_355:
            ; //}
            ; //
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10)
            _memset5A9D755A:
            ; //{						
00682:      	AR	= rm[BP_SAVE]
00683:      	push	AR
00684:      	AR	= BP
00685:      	rm[BP_SAVE]	= AR
            ; //_AA01D89BC_356:;				
            _AA01D89BC_356:
            ; //	
            ; //_AA01D89BC_357:;				
            _AA01D89BC_357:
            ; //	sAX	= (int)&_s_0_4_0;		
00686:      	AR	= 2
00687:      	AX	= rm[BP_SAVE]
00688:      	AX	+= AR
            ; //	sCX	= 0x0001;			
00689:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
0068A:      	AR	= CX
0068B:      	AX	+= AR
            ; //	sSI	= sAX;				
0068C:      	AR	= AX
0068D:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0068E:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
0068F:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_120;	
00690:      	if NZ	jmp LF2D2B0F3_120
            ; //	goto	LF2D2B0F3_119;			
00691:      	jmp	LF2D2B0F3_119
            ; //LF2D2B0F3_120:;					
            LF2D2B0F3_120:
            ; //_AA01D89BC_358:;				
            _AA01D89BC_358:
            ; //_AA01D89BC_359:;				
            _AA01D89BC_359:
            ; //	sSI	= (int)&_n_0_10;		
00692:      	AR	= 5
00693:      	I1	= rm[BP_SAVE]
00694:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00695:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00696:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
00697:      	AR	= 4
00698:      	I1	= rm[BP_SAVE]
00699:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0069A:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0069B:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
0069C:      	AR	= 2
0069D:      	AX	= rm[BP_SAVE]
0069E:      	AX	+= AR
            ; //	sSI	= sAX;				
0069F:      	AR	= AX
006A0:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006A1:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006A2:      	push	AX
            ; //	_memset_rC7200006(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
006A3:      	call	_memset_rC7200006
            ; //	RESTORESP(3);				
006A4:      	AR	= 3
006A5:      	BP	+= AR
            ; //	sDX	= 0x0800;			
006A6:      	DX	= 0x0800
            ; //	goto LF2D2B0F3_118;			
006A8:      	jmp	LF2D2B0F3_118
            ; //LF2D2B0F3_119:;					
            LF2D2B0F3_119:
            ; //_AA01D89BC_360:;				
            _AA01D89BC_360:
            ; //_AA01D89BC_361:;				
            _AA01D89BC_361:
            ; //_AA01D89BC_362:;				
            _AA01D89BC_362:
            ; //	sSI	= (int)&_n_0_10;		
006A9:      	AR	= 5
006AA:      	I1	= rm[BP_SAVE]
006AB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006AC:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006AD:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
006AE:      	AR	= 4
006AF:      	I1	= rm[BP_SAVE]
006B0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006B1:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006B2:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
006B3:      	AR	= 2
006B4:      	AX	= rm[BP_SAVE]
006B5:      	AX	+= AR
            ; //	sSI	= sAX;				
006B6:      	AR	= AX
006B7:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006B8:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006B9:      	push	AX
            ; //	_memset_sC3E11DB1(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
006BA:      	call	_memset_sC3E11DB1
            ; //	RESTORESP(3);				
006BB:      	AR	= 3
006BC:      	BP	+= AR
            ; //	sDX	= 0;				
006BD:      	DX	= 0x00
            ; //	goto LF2D2B0F3_118;			
006BE:      	jmp	LF2D2B0F3_118
            ; //LF2D2B0F3_118:;					
            LF2D2B0F3_118:
            ; //_AA01D89BC_363:;				
            _AA01D89BC_363:
            ; //	return;					
006BF:      	pop	AR
006C0:      	rm[BP_SAVE]	= AR
006C1:      	rets
            ; //_memset5A9D755A_end:;				
            _memset5A9D755A_end:
            ; //_AA01D89BC_364:;				
            _AA01D89BC_364:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libadpcm\adp12.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> Start=========================
            
            
            
            
            
            _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E:
            ; {
006C2:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
006C3:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder	; Z fail
006C4:              AX=		1
006C5:              if NZ jmp	L9E1082DD_0
006C6:              AX=		0
            L9E1082DD_0:
006C7:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\XDSP_ADPCM_4BIT_DECV04.OBJ"
            ;
            
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> Start=========================
            ; 3D044B19_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_touch_AB036625_s();		
009FD:      	pch	= ginit_code_touch_AB036625_s
009FE:      	lcall	ginit_code_touch_AB036625_s
            ; //	return;					
009FF:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
00A00:      	P1.hh=		0
00A01:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
00A02:      	AR=		pm[P1++]
00A03:      	rm[I1++]=	AR
            @glinit_label_1409:
00A04:      	loop		@glinit_loop_1409
00A05:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
00A06:      	AR=		AX
00A07:      	MX=		AR
00A08:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A09:      	MACOP=		3
00A0A:      	MR=		MX * AR
            #endif
            
00A0B:      	AR=		MR0
00A0C:      	AX=		AR
00A0D:      	AR=		MR1
00A0E:      	DX=		AR
00A0F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
00A10:      	AR=		AX
00A11:      	MX=		AR
00A12:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00A13:      	MACOP=		0
00A14:      	MR=		MX * AR
            #endif
            
00A15:      	AR=		MR0
00A16:      	AX=		AR
00A17:      	AR=		MR1
00A18:      	DX=		AR
00A19:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
00A1A:      	AR=		rm[BP_SAVE]
00A1B:      	push		AR
00A1C:      	AR=		BP
00A1D:      	rm[BP_SAVE]=	AR
00A1E:      	AR=		AR - 3
00A1F:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00A20:      	AR=		CX
00A21:      	MX=		AR
00A22:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A23:      	MACOP=		3		; unsigned
00A24:      	MR=		MX * AR
            #endif
            
00A25:      	I1=		rm[BP_SAVE]
00A26:      	AR=		2
00A27:      	I1=		I1 - AR
00A28:      	rm[I1++]=	MR0
00A29:      	rm[I1++]=	MR1
00A2A:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00A2B:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
00A2C:      	MACOP=		1		; mx:unsigned / my:signed
00A2D:      	MR=		MX * AR
            #endif
            
00A2E:      	AR=		rm[I1]
00A2F:      	AR=		AR + MR0
00A30:      	rm[I1++]=	AR
00A31:      	AR=		rm[I1]
00A32:      	AR=		AR + MR1 + C
00A33:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00A34:      	AR=		BX
00A35:      	MX=		AR
00A36:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
00A37:      	MACOP=		2		; mx:signed / my:unsigned
00A38:      	MR=		MX * AR
            #endif
            
00A39:      	AR=		rm[I1]
00A3A:      	AR=		AR + MR0
00A3B:      	rm[I1++]=	AR
00A3C:      	AR=		rm[I1]
00A3D:      	AR=		AR + MR1 + C
00A3E:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00A3F:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00A40:      	MACOP=		0		; mx:signed / my:signed
00A41:      	MR=		MX * AR
            #endif
            
00A42:      	AR=		rm[I1]
00A43:      	AR=		AR + MR0
00A44:      	rm[I1]=		AR
            
00A45:      	I1=		rm[BP_SAVE]
00A46:      	CX=		rm[I1--]
00A47:      	DX=		rm[I1--]
00A48:      	AX=		rm[I1]
            
00A49:      	AR=		3
00A4A:      	BP=		BP + AR
00A4B:      	pop		AR
00A4C:      	rm[BP_SAVE]=	AR
            
00A4D:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
00A4E:      	AR=		rm[BP_SAVE]
00A4F:      	push		AR
00A50:      	AR=		BP
00A51:      	rm[BP_SAVE]=	AR
00A52:      	AR=		AR - 3
00A53:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00A54:      	AR=		CX
00A55:      	MX=		AR
00A56:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A57:      	MACOP=		3		; unsigned
00A58:      	MR=		MX * AR
            #endif
            
00A59:      	I1=		rm[BP_SAVE]
00A5A:      	AR=		2
00A5B:      	I1=		I1 - AR
00A5C:      	rm[I1++]=	MR0
00A5D:      	rm[I1++]=	MR1
00A5E:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00A5F:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A60:      	MR=		MX * AR
            #endif
            
00A61:      	AR=		rm[I1]
00A62:      	AR=		AR + MR0
00A63:      	rm[I1++]=	AR
00A64:      	AR=		rm[I1]
00A65:      	AR=		AR + MR1 + C
00A66:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00A67:      	AR=		BX
00A68:      	MX=		AR
00A69:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A6A:      	MR=		MX * AR
            #endif
            
00A6B:      	AR=		rm[I1]
00A6C:      	AR=		AR + MR0
00A6D:      	rm[I1++]=	AR
00A6E:      	AR=		rm[I1]
00A6F:      	AR=		AR + MR1 + C
00A70:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00A71:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A72:      	MR=		MX * AR
            #endif
            
00A73:      	AR=		rm[I1]
00A74:      	AR=		AR + MR0
00A75:      	rm[I1]=		AR
            
00A76:      	I1=		rm[BP_SAVE]
00A77:      	CX=		rm[I1--]
00A78:      	DX=		rm[I1--]
00A79:      	AX=		rm[I1]
            
00A7A:      	AR=		3
00A7B:      	BP=		BP + AR
00A7C:      	pop		AR
00A7D:      	rm[BP_SAVE]=	AR
            
00A7E:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
00A7F:      		DX=		0
            	; unsigned char count = 16;
00A80:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00A81:      			slz		AX, 1
            		; reste <<= 1;
00A82:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00A83:      			AR=		DX
00A84:      			AR-=		CX
00A85:      			AR=		0
00A86:      			AR=		AR - 0 + C - 1
00A87:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
00A88:      				AR=		CX
00A89:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00A8A:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
00A8B:      		R0--
00A8C:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
00A8D:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
00A8E:      		R1=		0
00A8F:      		AR=		0
00A90:      		test		AX.b15
00A91:      		if ZR jmp	@divsword_label_1833
00A92:      			AX=		AR - AX
00A93:      			set		R1.b0
            		@divsword_label_1833:
00A94:      		test		CX.b15
00A95:      		if ZR jmp	@divsword_label_1834
00A96:      			CX=		AR - CX
00A97:      			set		R1.b1
            		@divsword_label_1834:
00A98:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
00A99:      		AR=		R1
00A9A:      		slz		AR, 1
00A9B:      		AR^=		R1
00A9C:      		test		AR.b1
00A9D:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
00A9E:      			AR=		0
00A9F:      			AX=		AR - AX
00AA0:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
00AA1:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
00AA2:      		R0=		0	; L
00AA3:      		R1=		0	; H
            	; unsigned char count = 32;
00AA4:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00AA5:      			slz		AX, 1
00AA6:      			slc		DX, 1
            		; reste <<= 1;
00AA7:      			slc		R0, 1
00AA8:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
00AA9:      			AR=		R0
00AAA:      			AR-=		CX
00AAB:      			AR=		R1
00AAC:      			AR=		AR - BX + C - 1
00AAD:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
00AAE:      				AR=		CX
00AAF:      				R0=		R0 - AR
00AB0:      				AR=		BX
00AB1:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
00AB2:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
00AB3:      		R2--
00AB4:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
00AB5:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
00AB6:      		R3=		0
00AB7:      		AR=		0
00AB8:      		test		DX.b15
00AB9:      		if ZR jmp	@divslong_label_1759
00ABA:      			AX=		AR - AX
00ABB:      			DX=		AR - DX + C - 1
00ABC:      			set		R3.b0
            		@divslong_label_1759:
00ABD:      		test		BX.b15
00ABE:      		if ZR jmp	@divslong_label_1800
00ABF:      			CX=		AR - CX
00AC0:      			BX=		AR - BX + C - 1
00AC1:      			set		R3.b1
            		@divslong_label_1800:
00AC2:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
00AC3:      		AR=		R3
00AC4:      		slz		AR, 1
00AC5:      		AR^=		R3
00AC6:      		test		AR.b1
00AC7:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
00AC8:      			AR=		0
00AC9:      			AX=		AR - AX
00ACA:      			DX=		AR - DX + C - 1
00ACB:      			R0=		AR - R0
00ACC:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
00ACD:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
00ACE:      	call		sfx_DIV_AX_CX
00ACF:      	AR=		DX
00AD0:      	AX=		AR
00AD1:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
00AD2:      	call		sfx_IDIV_AX_CX
00AD3:      	AR=		DX
00AD4:      	AX=		AR
00AD5:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
00AD6:      	call		sfx_DIVLONG
00AD7:      	AR=		R0
00AD8:      	AX=		AR
00AD9:      	AR=		R1
00ADA:      	DX=		AR
00ADB:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
00ADC:      	call		sfx_IDIVLONG
00ADD:      	AR=		R0
00ADE:      	AX=		AR
00ADF:      	AR=		R1
00AE0:      	DX=		AR
00AE1:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
00AE2:      	AR=		AX
00AE3:      	P1=		P1 + AR
00AE4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
00AE5:      	AR=		AX
00AE6:      	I1=		I1 + AR
00AE7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
00AE8:      	AR=		CX
00AE9:      	AX=		AX + AR
00AEA:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
00AEB:      	AR=		AX
00AEC:      	P1=		P1 - AR
00AED:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
00AEE:      	AR=		AX
00AEF:      	I1=		I1 - AR
00AF0:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
00AF1:      	AR=		CX
00AF2:      	AX=		AX + AR
00AF3:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
00AF4:      	pm[P1++]=	AX
00AF5:      	pm[P1--]=	DX
00AF6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
00AF7:      	pm[P1++]=	CX
00AF8:      	pm[P1--]=	BX
00AF9:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
00AFA:      	BX=		0
00AFB:      	CX.h=		0
00AFC:      	test		CX.b7
00AFD:      	if ZR jmp	@c2lcx_label_1800
00AFE:      	CX.h=		0xFF
00AFF:      	BX=		-1
            @c2lcx_label_1800:
00B00:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
00B01:      	DX=		0
00B02:      	AX.h=		0
00B03:      	test		AX.b7
00B04:      	if ZR jmp	@c2lax_label_1800
00B05:      	AX.h=		0xFF
00B06:      	DX=		-1
            @c2lax_label_1800:
00B07:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
00B08:      	push		AX
00B09:      	push		CX
00B0A:      	pop		AX
00B0B:      	pop		CX
00B0C:      	push		DX
00B0D:      	push		BX
00B0E:      	pop		DX
00B0F:      	pop		BX
00B10:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
00B11:      	AR=		DX
00B12:      	DX=		0
00B13:      	AR=		AR | AX
00B14:      	AX=		1
00B15:      	if ZR jmp	@longnotl_label_1120
00B16:      	AX=		0
            @longnotl_label_1120:
00B17:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
00B18:      	DX=		0
00B19:      	BX=		0
            sfx_CMPLONG_JNE:
00B1A:      	AR=		CX
00B1B:      	AX=		AX - AR
00B1C:      	AR=		BX
00B1D:      	AR=		DX - AR + C - 1
00B1E:      	AR=		AR | AX
00B1F:      	if EQ jmp	@sfx_cl_jne_f
00B20:      	set		Z		; true
00B21:      	rets
            @sfx_cl_jne_f:
00B22:      	clr		Z		; false
00B23:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
00B24:      	DX=		0
00B25:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
00B26:      	AR=		AX
00B27:      	CX=		CX - AR
00B28:      	AR=		DX
00B29:      	AR=		BX - AR + C - 1
00B2A:      	AR=		AR | CX
00B2B:      	if EQ jmp	@sfx_clbcda_jne_f
00B2C:      	set		Z		; true
00B2D:      	rets
            @sfx_clbcda_jne_f:
00B2E:      	clr		Z		; false
00B2F:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
00B30:      	AR=		CX
00B31:      	SF=		AX - AR
00B32:      	if EQ jmp	@sfx_ac_jne_f
00B33:      	set		Z
00B34:      	rets
            @sfx_ac_jne_f:
00B35:      	clr		Z
00B36:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
00B37:      	AR=		AX
00B38:      	SF=		CX - AR
00B39:      	if EQ jmp	@sfx_ca_jne_f
00B3A:      	set		Z
00B3B:      	rets
            @sfx_ca_jne_f:
00B3C:      	clr		Z
00B3D:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
00B3E:      	DX=		0
00B3F:      	BX=		0
            sfx_CMPLONG_JE:
00B40:      	AR=		CX
00B41:      	AX=		AX - AR
00B42:      	AR=		BX
00B43:      	AR=		DX - AR + C - 1
00B44:      	AR=		AR | AX
00B45:      	if NE jmp	@sfx_cl_jz_f
00B46:      	set		Z		; true
00B47:      	rets
            @sfx_cl_jz_f:
00B48:      	clr		Z		; false
00B49:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00B4A:      	DX=		0
00B4B:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
00B4C:      	AR=		AX
00B4D:      	CX=		CX - AR
00B4E:      	AR=		DX
00B4F:      	AR=		BX - AR + C - 1
00B50:      	AR=		AR | CX
00B51:      	if NE jmp	@sfx_clbcda_jz_f
00B52:      	set		Z		; true
00B53:      	rets
            @sfx_clbcda_jz_f:
00B54:      	clr		Z		; false
00B55:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
00B56:      	DX=		0
00B57:      	BX=		0
            sfx_CMPLONG_JG:
00B58:      	AR=		CX
00B59:      	AX=		AX - AR
00B5A:      	AR=		BX
00B5B:      	AR=		DX - AR + C - 1
00B5C:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
00B5D:      	AR=		AR | AX
00B5E:      	if ZR jmp	@sfx_cl_jg_f
            
00B5F:      	set		Z		; true
00B60:      	rets
            @sfx_cl_jg_f:
00B61:      	clr		Z		; false
00B62:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
00B63:      	AR=		CX
00B64:      	AX=		AX - AR
00B65:      	AR=		BX
00B66:      	DX=		DX - AR + C - 1
00B67:      	AR=		0
00B68:      	AR=		AR - 0 + C - 1
00B69:      	if AN jmp	@sfx_cl_jg_f
            
00B6A:      	AR=		AR | DX		; exclude EQU condition
00B6B:      	AR=		AR | AX
00B6C:      	if ZR jmp	@sfx_cl_jg_f
            
00B6D:      	set		Z		; true
00B6E:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
00B6F:      	DX=		0
00B70:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
00B71:      	AR=		AX
00B72:      	CX=		CX - AR
00B73:      	AR=		DX
00B74:      	AR=		BX - AR + C - 1
00B75:      	if AN jmp	@sfx_clbcda_jg_f
            
00B76:      	AR=		AR | CX		; exclude EQU condition
00B77:      	if ZR jmp	@sfx_clbcda_jg_f
            
00B78:      	set		Z		; true
00B79:      	rets
            @sfx_clbcda_jg_f:
00B7A:      	clr		Z		; false
00B7B:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00B7C:      	AR=		AX
00B7D:      	CX=		CX - AR
00B7E:      	AR=		DX
00B7F:      	BX=		BX - AR + C - 1
00B80:      	AR=		0
00B81:      	AR=		AR - 0 + C - 1
00B82:      	if AN jmp	@sfx_clbcda_jg_f
            
00B83:      	AR=		AR | BX		; exclude EQU condition
00B84:      	AR=		AR | CX
00B85:      	if ZR jmp	@sfx_clbcda_jg_f
            
00B86:      	set		Z		; true
00B87:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
00B88:      	AR=		CX
00B89:      	SF=		AX - AR
00B8A:      	if LE jmp	@sfx_cmp_ac_jg_f
00B8B:      	set		Z
00B8C:      	rets
            @sfx_cmp_ac_jg_f:
00B8D:      	clr		Z
00B8E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
00B8F:      	AR=		AX
00B90:      	SF=		CX - AR
00B91:      	if LE jmp	@sfx_cmp_ca_jg_f
00B92:      	set		Z
00B93:      	rets
            @sfx_cmp_ca_jg_f:
00B94:      	clr		Z
00B95:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
00B96:      	DX=		0
00B97:      	BX=		0
            sfx_CMPLONG_JGE:
00B98:      	AR=		CX
00B99:      	AX=		AX - AR
00B9A:      	AR=		BX
00B9B:      	DX=		DX - AR + C - 1
00B9C:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
00B9D:      	set		Z		; true
00B9E:      	rets
            @sfx_cl_jge_f:
00B9F:      	clr		Z		; false
00BA0:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
00BA1:      	AR=		CX
00BA2:      	AX=		AX - AR
00BA3:      	AR=		BX
00BA4:      	DX=		DX - AR + C - 1
00BA5:      	AR=		0
00BA6:      	AR=		AR - 0 + C - 1
00BA7:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
00BA8:      	set		Z		; true
00BA9:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
00BAA:      	DX=		0
00BAB:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
00BAC:      	AR=		AX
00BAD:      	CX=		CX - AR
00BAE:      	AR=		DX
00BAF:      	BX=		BX - AR + C - 1
00BB0:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
00BB1:      	set		Z		; true
00BB2:      	rets
            @sfx_clbcda_jge_f:
00BB3:      	clr		Z		; false
00BB4:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
00BB5:      	AR=		AX
00BB6:      	CX=		CX - AR
00BB7:      	AR=		DX
00BB8:      	BX=		BX - AR + C - 1
00BB9:      	AR=		0
00BBA:      	AR=		AR - 0 + C - 1
00BBB:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
00BBC:      	set		Z		; true
00BBD:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
00BBE:      	AR=		CX
00BBF:      	SF=		AX - AR
00BC0:      	if AN jmp	@sfx_cmp_ac_jge_f
00BC1:      	set		Z
00BC2:      	rets
            @sfx_cmp_ac_jge_f:
00BC3:      	clr		Z
00BC4:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
00BC5:      	AR=		AX
00BC6:      	SF=		CX - AR
00BC7:      	if AN jmp	@sfx_cmp_ca_jge_f
00BC8:      	set		Z
00BC9:      	rets
            @sfx_cmp_ca_jge_f:
00BCA:      	clr		Z
00BCB:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
00BCC:      	DX=		0
00BCD:      	BX=		0
            sfx_CMPLONG_JL:
00BCE:      	AR=		CX
00BCF:      	AX=		AX - AR
00BD0:      	AR=		BX
00BD1:      	AR=		DX - AR + C - 1
00BD2:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
00BD3:      	clr		Z		; false
00BD4:      	rets
            
            @sfx_cl_jl_chk:
00BD5:      	AR=		AR | AX		; exclude EQU condition
00BD6:      	if ZR jmp	@sfx_cl_jl_f
00BD7:      	set		Z
00BD8:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
00BD9:      	AR=		CX
00BDA:      	AX=		AX - AR
00BDB:      	AR=		BX
00BDC:      	DX=		DX - AR + C - 1
00BDD:      	AR=		0
00BDE:      	AR=		AR - 0 + C - 1
00BDF:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
00BE0:      	clr		Z		; false
00BE1:      	rets
            
            @sfx_cl_jb_chk:
00BE2:      	AR=		AR | DX
00BE3:      	AR=		AR | AX		; exclude EQU condition
00BE4:      	if ZR jmp	@sfx_cl_jb_f
00BE5:      	set		Z
00BE6:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
00BE7:      	DX=		0
00BE8:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
00BE9:      	AR=		AX
00BEA:      	CX=		CX - AR
00BEB:      	AR=		DX
00BEC:      	AR=		BX - AR + C - 1
00BED:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
00BEE:      	clr		Z		; false
00BEF:      	rets
            
            @sfx_clbcda_jl_chk:
00BF0:      	AR=		AR | CX		; exclude EQU condition
00BF1:      	if ZR jmp	@sfx_clbcda_jl_f
00BF2:      	set		Z		; true
00BF3:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
00BF4:      	AR=		AX
00BF5:      	CX=		CX - AR
00BF6:      	AR=		DX
00BF7:      	BX=		BX - AR + C - 1
00BF8:      	AR=		0
00BF9:      	AR=		AR - 0 + C - 1
00BFA:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
00BFB:      	clr		Z		; false
00BFC:      	rets
            
            @sfx_clbcda_jb_chk:
00BFD:      	AR=		AR | CX
00BFE:      	AR=		AR | BX
00BFF:      	if ZR jmp	@sfx_clbcda_jb_f
00C00:      	set		Z		; true
00C01:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
00C02:      	AR=		CX
00C03:      	SF=		AX - AR
00C04:      	if GE jmp	@sfx_cmp_ac_jl_f
00C05:      	set		Z
00C06:      	rets
            @sfx_cmp_ac_jl_f:
00C07:      	clr		Z
00C08:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
00C09:      	AR=		AX
00C0A:      	SF=		CX - AR
00C0B:      	if GE jmp	@sfx_cmp_ca_jl_f
00C0C:      	set		Z
00C0D:      	rets
            @sfx_cmp_ca_jl_f:
00C0E:      	clr		Z
00C0F:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
00C10:      	DX=		0
00C11:      	BX=		0
            sfx_CMPLONG_JLE:
00C12:      	AR=		CX
00C13:      	AX=		AX - AR
00C14:      	AR=		BX
00C15:      	AR=		DX - AR + C - 1
00C16:      	if AN jmp	@sfx_cl_jle_t
            
00C17:      	AR=		AR | AX		; include EQU condition
00C18:      	if ZR jmp	@sfx_cl_jle_t
            
00C19:      	clr		Z		; false
00C1A:      	rets
            @sfx_cl_jle_t:
00C1B:      	set		Z		; true
00C1C:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
00C1D:      	AR=		CX
00C1E:      	AX=		AX - AR
00C1F:      	AR=		BX
00C20:      	DX=		DX - AR + C - 1
00C21:      	AR=		0
00C22:      	AR=		AR - 0 + C - 1
00C23:      	if AN jmp	@sfx_cl_jle_t
            
00C24:      	AR=		AR | DX
00C25:      	AR=		AR | AX
00C26:      	if ZR jmp	@sfx_cl_jle_t
            
00C27:      	clr		Z		; false
00C28:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
00C29:      	DX=		0
00C2A:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00C2B:      	AR=		AX
00C2C:      	CX=		CX - AR
00C2D:      	AR=		DX
00C2E:      	AR=		BX - AR + C - 1
00C2F:      	if AN jmp	@sfx_clbcda_jle_t
            
00C30:      	AR=		AR | CX		; include EQU condition
00C31:      	if ZR jmp	@sfx_clbcda_jle_t
            
00C32:      	clr		Z		; false
00C33:      	rets
            @sfx_clbcda_jle_t:
00C34:      	set		Z		; true
00C35:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
00C36:      	AR=		AX
00C37:      	CX=		CX - AR
00C38:      	AR=		DX
00C39:      	BX=		BX - AR + C - 1
00C3A:      	AR=		0
00C3B:      	AR=		AR - 0 + C - 1
00C3C:      	if AN jmp	@sfx_clbcda_jle_t
            
00C3D:      	AR=		AR | BX
00C3E:      	AR=		AR | CX
00C3F:      	if ZR jmp	@sfx_clbcda_jle_t
            
00C40:      	clr		Z		; false
00C41:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
00C42:      	AR=		CX
00C43:      	SF=		AX - AR
00C44:      	if LE jmp	@sfx_cmp_ac_jl_t
00C45:      	clr		Z
00C46:      	rets
            @sfx_cmp_ac_jl_t:
00C47:      	set		Z
00C48:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
00C49:      	AR=		AX
00C4A:      	SF=		CX - AR
00C4B:      	if LE jmp	@sfx_cmp_ca_jl_t
00C4C:      	clr		Z
00C4D:      	rets
            @sfx_cmp_ca_jl_t:
00C4E:      	set		Z
00C4F:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
00C50:      	DW 0xFFFE
            @sfx_ortable_1:
00C51:      	DW 0xFFFC
            @sfx_ortable_2:
00C52:      	DW 0xFFF8
            @sfx_ortable_3:
00C53:      	DW 0xFFF0
            @sfx_ortable_4:
00C54:      	DW 0xFFE0
            @sfx_ortable_5:
00C55:      	DW 0xFFC0
            @sfx_ortable_6:
00C56:      	DW 0xFF80
            @sfx_ortable_7:
00C57:      	DW 0xFF00
            @sfx_ortable_8:
00C58:      	DW 0xFE00
            @sfx_ortable_9:
00C59:      	DW 0xFC00
            @sfx_ortable_10:
00C5A:      	DW 0xF800
            @sfx_ortable_11:
00C5B:      	DW 0xF000
            @sfx_ortable_12:
00C5C:      	DW 0xE000
            @sfx_ortable_13:
00C5D:      	DW 0xC000
            @sfx_ortable_14:
00C5E:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
00C5F:      	AR=		pm[P1]
00C60:      	DX=		DX | AR
00C61:      	rets
            
            @sfx_orhigh_dx:
00C62:      	DX=		-1
            @sfx_orlow:
00C63:      	AR=		pm[P1]
00C64:      	AX=		AX | AR
            @sfx_sextw_rets:
00C65:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
00C66:      	P1=		#@sfx_ortable_0
00C69:      	test		AX.b0
00C6A:      	if ZR jmp	@sfx_sextw_rets
00C6B:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00C6C:      	P1=		#@sfx_ortable_1
00C6F:      	test		AX.b1
00C70:      	if ZR jmp	@sfx_sextw_rets
00C71:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
00C72:      	P1=		#@sfx_ortable_2
00C75:      	test		AX.b2
00C76:      	if ZR jmp	@sfx_sextw_rets
00C77:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
00C78:      	P1=		#@sfx_ortable_3
00C7B:      	test		AX.b3
00C7C:      	if ZR jmp	@sfx_sextw_rets
00C7D:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
00C7E:      	P1=		#@sfx_ortable_4
00C81:      	test		AX.b4
00C82:      	if ZR jmp	@sfx_sextw_rets
00C83:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
00C84:      	P1=		#@sfx_ortable_5
00C87:      	test		AX.b5
00C88:      	if ZR jmp	@sfx_sextw_rets
00C89:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00C8A:      	P1=		#@sfx_ortable_6
00C8D:      	test		AX.b6
00C8E:      	if ZR jmp	@sfx_sextw_rets
00C8F:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
00C90:      	P1=		#@sfx_ortable_7
00C93:      	test		AX.b7
00C94:      	if ZR jmp	@sfx_sextw_rets
00C95:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
00C96:      	P1=		#@sfx_ortable_8
00C99:      	test		AX.b8
00C9A:      	if ZR jmp	@sfx_sextw_rets
00C9B:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
00C9C:      	P1=		#@sfx_ortable_9
00C9F:      	test		AX.b9
00CA0:      	if ZR jmp	@sfx_sextw_rets
00CA1:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
00CA2:      	P1=		#@sfx_ortable_10
00CA5:      	test		AX.b10
00CA6:      	if ZR jmp	@sfx_sextw_rets
00CA7:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
00CA8:      	P1=		#@sfx_ortable_11
00CAB:      	test		AX.b11
00CAC:      	if ZR jmp	@sfx_sextw_rets
00CAD:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
00CAE:      	P1=		#@sfx_ortable_12
00CB1:      	test		AX.b12
00CB2:      	if ZR jmp	@sfx_sextw_rets
00CB3:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
00CB4:      	P1=		#@sfx_ortable_13
00CB7:      	test		AX.b13
00CB8:      	if ZR jmp	@sfx_sextw_rets
00CB9:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
00CBA:      	P1=		#@sfx_ortable_14
00CBD:      	test		AX.b14
00CBE:      	if ZR jmp	@sfx_sextw_rets
00CBF:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
00CC0:      	P1=		#@sfx_ortable_0
00CC3:      	test		AX.b0
00CC4:      	if ZR jmp	@sfx_sextw_rets
00CC5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
00CC6:      	P1=		#@sfx_ortable_1
00CC9:      	test		AX.b1
00CCA:      	if ZR jmp	@sfx_sextw_rets
00CCB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
00CCC:      	P1=		#@sfx_ortable_2
00CCF:      	test		AX.b2
00CD0:      	if ZR jmp	@sfx_sextw_rets
00CD1:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
00CD2:      	P1=		#@sfx_ortable_3
00CD5:      	test		AX.b3
00CD6:      	if ZR jmp	@sfx_sextw_rets
00CD7:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
00CD8:      	P1=		#@sfx_ortable_4
00CDB:      	test		AX.b4
00CDC:      	if ZR jmp	@sfx_sextw_rets
00CDD:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
00CDE:      	P1=		#@sfx_ortable_5
00CE1:      	test		AX.b5
00CE2:      	if ZR jmp	@sfx_sextw_rets
00CE3:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
00CE4:      	P1=		#@sfx_ortable_6
00CE7:      	test		AX.b6
00CE8:      	if ZR jmp	@sfx_sextw_rets
00CE9:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
00CEA:      	P1=		#@sfx_ortable_7
00CED:      	test		AX.b7
00CEE:      	if ZR jmp	@sfx_sextw_rets
00CEF:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
00CF0:      	P1=		#@sfx_ortable_8
00CF3:      	test		AX.b8
00CF4:      	if ZR jmp	@sfx_sextw_rets
00CF5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
00CF6:      	P1=		#@sfx_ortable_9
00CF9:      	test		AX.b9
00CFA:      	if ZR jmp	@sfx_sextw_rets
00CFB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
00CFC:      	P1=		#@sfx_ortable_10
00CFF:      	test		AX.b10
00D00:      	if ZR jmp	@sfx_sextw_rets
00D01:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
00D02:      	P1=		#@sfx_ortable_11
00D05:      	test		AX.b11
00D06:      	if ZR jmp	@sfx_sextw_rets
00D07:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
00D08:      	P1=		#@sfx_ortable_12
00D0B:      	test		AX.b12
00D0C:      	if ZR jmp	@sfx_sextw_rets
00D0D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
00D0E:      	P1=		#@sfx_ortable_13
00D11:      	test		AX.b13
00D12:      	if ZR jmp	@sfx_sextw_rets
00D13:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
00D14:      	P1=		#@sfx_ortable_14
00D17:      	test		AX.b14
00D18:      	if ZR jmp	@sfx_sextw_rets
00D19:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
00D1A:      	test		AX.b15
00D1B:      	if ZR jmp	@sfx_sextw_rets
00D1C:      	DX=		-1
00D1D:      	rets
            
            sfx_SignExtL16:
00D1E:      	P1=		#@sfx_ortable_0
00D21:      	test		DX.b0
00D22:      	if ZR jmp	@sfx_sextw_rets
00D23:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
00D24:      	P1=		#@sfx_ortable_1
00D27:      	test		DX.b1
00D28:      	if ZR jmp	@sfx_sextw_rets
00D29:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00D2A:      	P1=		#@sfx_ortable_2
00D2D:      	test		DX.b2
00D2E:      	if ZR jmp	@sfx_sextw_rets
00D2F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
00D30:      	P1=		#@sfx_ortable_3
00D33:      	test		DX.b3
00D34:      	if ZR jmp	@sfx_sextw_rets
00D35:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
00D36:      	P1=		#@sfx_ortable_4
00D39:      	test		DX.b4
00D3A:      	if ZR jmp	@sfx_sextw_rets
00D3B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00D3C:      	P1=		#@sfx_ortable_5
00D3F:      	test		DX.b5
00D40:      	if ZR jmp	@sfx_sextw_rets
00D41:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
00D42:      	P1=		#@sfx_ortable_6
00D45:      	test		DX.b6
00D46:      	if ZR jmp	@sfx_sextw_rets
00D47:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
00D48:      	P1=		#@sfx_ortable_7
00D4B:      	test		DX.b7
00D4C:      	if ZR jmp	@sfx_sextw_rets
00D4D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
00D4E:      	P1=		#@sfx_ortable_8
00D51:      	test		DX.b8
00D52:      	if ZR jmp	@sfx_sextw_rets
00D53:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
00D54:      	P1=		#@sfx_ortable_9
00D57:      	test		DX.b9
00D58:      	if ZR jmp	@sfx_sextw_rets
00D59:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00D5A:      	P1=		#@sfx_ortable_10
00D5D:      	test		DX.b10
00D5E:      	if ZR jmp	@sfx_sextw_rets
00D5F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
00D60:      	P1=		#@sfx_ortable_11
00D63:      	test		DX.b11
00D64:      	if ZR jmp	@sfx_sextw_rets
00D65:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
00D66:      	P1=		#@sfx_ortable_12
00D69:      	test		DX.b12
00D6A:      	if ZR jmp	@sfx_sextw_rets
00D6B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00D6C:      	P1=		#@sfx_ortable_13
00D6F:      	test		DX.b13
00D70:      	if ZR jmp	@sfx_sextw_rets
00D71:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
00D72:      	P1=		#@sfx_ortable_14
00D75:      	test		DX.b14
00D76:      	if ZR jmp	@sfx_sextw_rets
00D77:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
00D78:      	push		I1
00D79:      	AR=		AX
00D7A:      	I1=		AR
00D7B:      	AR=		rm[I1]
00D7C:      	pop		I1
00D7D:      	rm[I1++]=	AR
00D7E:      	AX++
00D7F:      	loop		@sfx_repmov_ss_loop_1804
00D80:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
00D81:      	AR=		AX
00D82:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00D83:      	rm[I1++]=	pm[P1++]
00D84:      	loop		@sfx_repmov_sr_loop_1804
00D85:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
00D86:      	AR=		AX
00D87:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
00D88:      	AR=		rm[I1++]
00D89:      	pm[P1++]=	AR
00D8A:      	loop		@sfx_repmov_rs_loop_1804
00D8B:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00D8C:      	push		P1
00D8D:      	AR=		AX
00D8E:      	P1=		AR
00D8F:      	AR=		pm[P1]
00D90:      	pop		P1
00D91:      	pm[P1++]=	AR
00D92:      	AX++
00D93:      	loop		@sfx_repmov_rr_loop_1804
00D94:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00D95:      	PCH=	SYS_PROG_ENTRY
00D96:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
00D97:      	DW #_Touch_entry886E03ED
00D98:      	DW #EMPTY_INTENTRY
00D99:      	DW #EMPTY_INTENTRY
00D9A:      	DW #EMPTY_INTENTRY
00D9B:      	DW #EMPTY_INTENTRY
00D9C:      	DW #_PWM_Entry4EB0B003
            
            // .code ends
            ;;FDSP-IDE V2.64
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
