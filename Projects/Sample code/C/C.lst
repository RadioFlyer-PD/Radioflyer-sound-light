            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> Start=========================
            ; C.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlayAdpECABF1D0();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_AE3845712_0:;					
            _AE3845712_0:
            ; //	
            ; //_AE3845712_1:;					
            _AE3845712_1:
            ; //_AE3845712_2:;					
            _AE3845712_2:
            ; //	_InitialDA4A7CC4();			
0011D:      	pch	= _InitialDA4A7CC4
0011E:      	lcall	_InitialDA4A7CC4
            ; //_AE3845712_3:;					
            _AE3845712_3:
            ; //_AE3845712_4:;					
            _AE3845712_4:
            ; //	_InitKey3C587B6D();			
0011F:      	pch	= _InitKey3C587B6D
00120:      	lcall	_InitKey3C587B6D
            ; //_AE3845712_5:;					
            _AE3845712_5:
            ; //_AE3845712_6:;					
            _AE3845712_6:
            ; //	ADPCM_CHX_Init();			
00121:      	pch	= ADPCM_CHX_Init
00122:      	lcall	ADPCM_CHX_Init
            ; //_AE3845712_7:;					
            _AE3845712_7:
            ; //	asm set io[0x06].b0;			
00123:      	set io[0x06].b0//
            ; //_AE3845712_8:;					
            _AE3845712_8:
            ; //	sAX	= 0x0001;			
00124:      	AX	= 0x01
            ; //	asm I1 = CopyToBank+0;			
00125:      	I1 = CopyToBank+0//
            ; //	*(__int16*)sSI	= sAX			
00126:      	rm[I1]	= AX
            ; //_AE3845712_9:;					
            _AE3845712_9:
            ; //	asm	set io[INTENA].b0		
00127:      	set io[INTENA].b0
            ; //_AE3845712_10:;					
            _AE3845712_10:
            ; //	asm	eni				
00128:      	eni
            ; //LE6FF7BEA_5:;					
            LE6FF7BEA_5:
            ; //_AE3845712_11:;					
            _AE3845712_11:
            ; //_AE3845712_12:;					
            _AE3845712_12:
            ; //	asm	io[ClrWDT] = AR			
00129:      	io[ClrWDT] = AR
            ; //	
            ; //_AE3845712_13:;					
            _AE3845712_13:
            ; //_AE3845712_14:;					
            _AE3845712_14:
            ; //	_PollingKey3B90E3B1();			
0012A:      	pch	= _PollingKey3B90E3B1
0012B:      	lcall	_PollingKey3B90E3B1
            ; //_AE3845712_15:;					
            _AE3845712_15:
            ; //_AE3845712_16:;					
            _AE3845712_16:
            ; //	_DoADPCM9CD0E20D();			
0012C:      	pch	= _DoADPCM9CD0E20D
0012D:      	lcall	_DoADPCM9CD0E20D
            ; //_AE3845712_17:;					
            _AE3845712_17:
            ; //	goto LE6FF7BEA_5;			
0012E:      	jmp	LE6FF7BEA_5
            ; //LE6FF7BEA_4:;					
            LE6FF7BEA_4:
            ; //LE6FF7BEA_3:;					
            LE6FF7BEA_3:
            ; //_AE3845712_18:;					
            _AE3845712_18:
            ; //	return;					
0012F:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_AE3845712_19:;					
            _AE3845712_19:
            ; //}
            ; //
            ; //rjmp void _KeyPlayAdpECABF1D0()			
            _KeyPlayAdpECABF1D0:
            ; //{
            ; //_AE3845712_20:;					
            _AE3845712_20:
            ; //	
            ; //_AE3845712_21:;					
            _AE3845712_21:
            ; //_AE3845712_22:;					
            _AE3845712_22:
            ; //	asm I1 = _iADPCCACC469+0;		
00130:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00131:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00132:      	push	AX
            ; //	_playADPCMBACD5AFD(STACK[sSP + 0]);	
00133:      	pch	= _playADPCMBACD5AFD
00134:      	lcall	_playADPCMBACD5AFD
            ; //	RESTORESP(1);				
00135:      	pop	AR
            ; //LE6FF7BEA_6:;					
            LE6FF7BEA_6:
            ; //_AE3845712_23:;					
            _AE3845712_23:
            ; //	return;					
00136:      	rets
            ; //_KeyPlayAdpECABF1D0_end:;			
            _KeyPlayAdpECABF1D0_end:
            ; //_AE3845712_24:;					
            _AE3845712_24:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_AE3845712_25:;					
            _AE3845712_25:
            ; //	
            ; //_AE3845712_26:;					
            _AE3845712_26:
            ; //	asm I1 = _iADPCCACC469+0;		
00137:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00138:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
00139:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0013A:      	CX	= rm[I1]
            ; //	sCX++;					
0013B:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
0013C:      	rm[I1]	= CX
            ; //_AE3845712_27:;					
            _AE3845712_27:
            ; //	asm I1 = _iADPCCACC469+0;		
0013D:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0013E:      	AX	= rm[I1]
            ; //	sCX	= 0x0009;			
0013F:      	CX	= 0x09
            ; //	sfx_CMP_AX_CX_JGE();			
00140:      	pch	= sfx_CMP_AX_CX_JGE
00141:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto LE6FF7BEA_9;	
00142:      	if ZR	jmp LE6FF7BEA_9
            ; //	goto	LE6FF7BEA_8;			
00143:      	jmp	LE6FF7BEA_8
            ; //LE6FF7BEA_9:;					
            LE6FF7BEA_9:
            ; //_AE3845712_28:;					
            _AE3845712_28:
            ; //	sAX	= 0x0000;			
00144:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00145:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00146:      	rm[I1]	= AX
            ; //LE6FF7BEA_8:;					
            LE6FF7BEA_8:
            ; //_AE3845712_29:;					
            _AE3845712_29:
            ; //_AE3845712_30:;					
            _AE3845712_30:
            ; //_AE3845712_31:;					
            _AE3845712_31:
            ; //	_KeyPlayAdpECABF1D0();			
00147:      	pch	= _KeyPlayAdpECABF1D0
00148:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_7:;					
            LE6FF7BEA_7:
            ; //_AE3845712_32:;					
            _AE3845712_32:
            ; //	return;					
00149:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_AE3845712_33:;					
            _AE3845712_33:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_AE3845712_34:;					
            _AE3845712_34:
            ; //	
            ; //_AE3845712_35:;					
            _AE3845712_35:
            ; //	asm I1 = _iADPCCACC469+0;		
0014A:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0014B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
0014C:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0014D:      	CX	= rm[I1]
            ; //	sCX--;					
0014E:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
0014F:      	rm[I1]	= CX
            ; //_AE3845712_36:;					
            _AE3845712_36:
            ; //	asm I1 = _iADPCCACC469+0;		
00150:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00151:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
00152:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00153:      	pch	= sfx_CMP_AX_CX_JL
00154:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LE6FF7BEA_12;	
00155:      	if ZR	jmp LE6FF7BEA_12
            ; //	goto	LE6FF7BEA_11;			
00156:      	jmp	LE6FF7BEA_11
            ; //LE6FF7BEA_12:;					
            LE6FF7BEA_12:
            ; //_AE3845712_37:;					
            _AE3845712_37:
            ; //	sAX	= 0x0005;			
00157:      	AX	= 0x05
            ; //	asm I1 = _iADPCCACC469+0;		
00158:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00159:      	rm[I1]	= AX
            ; //LE6FF7BEA_11:;					
            LE6FF7BEA_11:
            ; //_AE3845712_38:;					
            _AE3845712_38:
            ; //_AE3845712_39:;					
            _AE3845712_39:
            ; //_AE3845712_40:;					
            _AE3845712_40:
            ; //	_KeyPlayAdpECABF1D0();			
0015A:      	pch	= _KeyPlayAdpECABF1D0
0015B:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_10:;					
            LE6FF7BEA_10:
            ; //_AE3845712_41:;					
            _AE3845712_41:
            ; //	return;					
0015C:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_AE3845712_42:;					
            _AE3845712_42:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayPrev8E98A35A[0], 0x0000, 0x0000, (int)&_KeyPlayAdpECABF1D0[0], 0x0000, 0x0000, (int)&_KeyPlayNextAFBA8CED[0], 0x0000, 
0015D:      DW #_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyPlayAdpECABF1D0,0x0000,0x0000,#_KeyPlayNextAFBA8CED,0x0000,
            ; //	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
00165:      DW 0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:127]={
             inbuf,outbuf 
            };
            
            ; //// CODE segment					
            VarRM[0:4095]={
             BaseOn128#PCMY[128] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //interrupt rjmp void _PWM_Entry4EB0B003();
            ; //rjmp void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //interrupt rjmp void _PWM_Entry4EB0B003()	
            _PWM_Entry4EB0B003:
            ; //{						
0016C:      	push ax
0016D:      	push bx
0016E:      	push cx
0016F:      	push dx
00170:      	push r0
00171:      	push r1
00172:      	push r2
00173:      	push r3
00174:      	push i1
00175:      	push p1
00176:      	push mx
00177:      	push mr0
00178:      	push mr1
00179:      	push mr2
0017A:      	ar = p1.hh
0017B:      	push ar
            ; //_AE3845712_43:;					
            _AE3845712_43:
            ; //_AE3845712_44:;					
            _AE3845712_44:
            ; //	asm	clr io[INTREQ].b0		
0017C:      	clr io[INTREQ].b0
            ; //_AE3845712_45:;					
            _AE3845712_45:
            ; //	asm	push AX				
0017D:      	push AX
            ; //_AE3845712_46:;					
            _AE3845712_46:
            ; //	asm	push I0				
0017E:      	push I0
            ; //_AE3845712_47:;					
            _AE3845712_47:
            ; //	asm	push CBL			
0017F:      	push CBL
            ; //	
            ; //_AE3845712_48:;					
            _AE3845712_48:
            ; //	io[0x3B]	= 0x0007;		
00180:      	AR	= 0x07
00181:      	io[0x3B]	= AR
            ; //	
            ; //_AE3845712_49:;					
            _AE3845712_49:
            ; //	asm AX = rm[outbuf+0];			
00182:      	AX = rm[outbuf+0]//
            ; //_AE3845712_50:;					
            _AE3845712_50:
            ; //	asm	AR = AX				
00183:      	AR = AX
            ; //_AE3845712_51:;					
            _AE3845712_51:
            ; //	asm	I0 = AR				
00184:      	I0 = AR
            ; //	
            ; //_AE3845712_52:;					
            _AE3845712_52:
            ; //_AE3845712_53:;					
            _AE3845712_53:
            ; //	read_I0P2();				
00185:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00186:      	AR	= AX
00187:      	io[0x16]	= AR
            ; //_AE3845712_54:;					
            _AE3845712_54:
            ; //_AE3845712_55:;					
            _AE3845712_55:
            ; //	read_I0P2();				
00188:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00189:      	AR	= AX
0018A:      	io[0x16]	= AR
            ; //_AE3845712_56:;					
            _AE3845712_56:
            ; //_AE3845712_57:;					
            _AE3845712_57:
            ; //	read_I0P2();				
0018B:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018C:      	AR	= AX
0018D:      	io[0x16]	= AR
            ; //_AE3845712_58:;					
            _AE3845712_58:
            ; //_AE3845712_59:;					
            _AE3845712_59:
            ; //	read_I0P2();				
0018E:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018F:      	AR	= AX
00190:      	io[0x16]	= AR
            ; //_AE3845712_60:;					
            _AE3845712_60:
            ; //_AE3845712_61:;					
            _AE3845712_61:
            ; //	get_I0();				
00191:      	push	I0
00192:      	pop	AX
            ; //	outbuf+0 = sAX				
00193:      	rm[outbuf+0]	= AX
            ; //_AE3845712_62:;					
            _AE3845712_62:
            ; //	asm	pop CBL				
00194:      	pop CBL
            ; //_AE3845712_63:;					
            _AE3845712_63:
            ; //	asm	pop I0				
00195:      	pop I0
            ; //_AE3845712_64:;					
            _AE3845712_64:
            ; //	asm	pop AX				
00196:      	pop AX
            ; //L0E8FA404_15:;					
            L0E8FA404_15:
            ; //_AE3845712_65:;					
            _AE3845712_65:
            ; //	return;					
00197:      	pop ar
00198:      	p1.hh = ar
00199:      	pop mr2
0019A:      	pop mr1
0019B:      	pop mr0
0019C:      	pop mx
0019D:      	pop p1
0019E:      	pop i1
0019F:      	pop r3
001A0:      	pop r2
001A1:      	pop r1
001A2:      	pop r0
001A3:      	pop dx
001A4:      	pop cx
001A5:      	pop bx
001A6:      	pop ax
001A7:      	reti
            ; //_PWM_Entry4EB0B003_end:;			
            _PWM_Entry4EB0B003_end:
            ; //_AE3845712_66:;					
            _AE3845712_66:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_16()			
            L0E8FA404_16:
            ; //{
            ; //_AE3845712_67:;					
            _AE3845712_67:
            ; //	
            ; //_AE3845712_68:;					
            _AE3845712_68:
            ; //	io[0x16]	= 0x0000;		
001A8:      	AR	= 0x00
001A9:      	io[0x16]	= AR
            ; //_AE3845712_69:;					
            _AE3845712_69:
            ; //	io[0x16]	= 0x0000;		
001AA:      	AR	= 0x00
001AB:      	io[0x16]	= AR
            ; //_AE3845712_70:;					
            _AE3845712_70:
            ; //	io[0x16]	= 0x0000;		
001AC:      	AR	= 0x00
001AD:      	io[0x16]	= AR
            ; //_AE3845712_71:;					
            _AE3845712_71:
            ; //	io[0x16]	= 0x0000;		
001AE:      	AR	= 0x00
001AF:      	io[0x16]	= AR
            ; //_AE3845712_72:;					
            _AE3845712_72:
            ; //	io[0x36]	= 0x0000;		
001B0:      	AR	= 0x00
001B1:      	io[0x36]	= AR
            ; //_AE3845712_73:;					
            _AE3845712_73:
            ; //	io[0x36]	= 0x0000;		
001B2:      	AR	= 0x00
001B3:      	io[0x36]	= AR
            ; //_AE3845712_74:;					
            _AE3845712_74:
            ; //	io[0x36]	= 0x0000;		
001B4:      	AR	= 0x00
001B5:      	io[0x36]	= AR
            ; //_AE3845712_75:;					
            _AE3845712_75:
            ; //	io[0x36]	= 0x0000;		
001B6:      	AR	= 0x00
001B7:      	io[0x36]	= AR
            ; //_AE3845712_76:;					
            _AE3845712_76:
            ; //	io[0x36]	= 0x0000;		
001B8:      	AR	= 0x00
001B9:      	io[0x36]	= AR
            ; //_AE3845712_77:;					
            _AE3845712_77:
            ; //	io[0x36]	= 0x0000;		
001BA:      	AR	= 0x00
001BB:      	io[0x36]	= AR
            ; //_AE3845712_78:;					
            _AE3845712_78:
            ; //	io[0x36]	= 0x0000;		
001BC:      	AR	= 0x00
001BD:      	io[0x36]	= AR
            ; //_AE3845712_79:;					
            _AE3845712_79:
            ; //	io[0x36]	= 0x0000;		
001BE:      	AR	= 0x00
001BF:      	io[0x36]	= AR
            ; //_AE3845712_80:;					
            _AE3845712_80:
            ; //	io[0x3C]	= 0x003F;		
001C0:      	AR	= 0x3F
001C1:      	io[0x3C]	= AR
            ; //_AE3845712_81:;					
            _AE3845712_81:
            ; //	sAX	= io[0x3C];			
001C2:      	AR	= io[0x3C]
001C3:      	AX	= AR
            ; //_AE3845712_82:;					
            _AE3845712_82:
            ; //	asm	set io[MISC].b9			
001C4:      	set io[MISC].b9
            ; //_AE3845712_83:;					
            _AE3845712_83:
            ; //	asm	set io[MISC].b8			
001C5:      	set io[MISC].b8
            ; //_AE3845712_84:;					
            _AE3845712_84:
            ; //	asm	set io[MISC].b4			
001C6:      	set io[MISC].b4
            ; //L0E8FA404_18:;					
            L0E8FA404_18:
            ; //_AE3845712_85:;					
            _AE3845712_85:
            ; //	return;					
001C7:      	rets
            ; //L0E8FA404_16_end:;				
            L0E8FA404_16_end:
            ; //_AE3845712_86:;					
            _AE3845712_86:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_19()			
            L0E8FA404_19:
            ; //{
            ; //_AE3845712_87:;					
            _AE3845712_87:
            ; //	
            ; //_AE3845712_88:;					
            _AE3845712_88:
            ; //	io[0x04]	= 0x000F;		
001C8:      	AR	= 0x0F
001C9:      	io[0x04]	= AR
            ; //_AE3845712_89:;					
            _AE3845712_89:
            ; //	io[0x05]	= 0xFFFF;		
001CA:      	AR	= 0xFFFF
001CC:      	io[0x05]	= AR
            ; //_AE3845712_90:;					
            _AE3845712_90:
            ; //	io[0x07]	= 0x0000;		
001CD:      	AR	= 0x00
001CE:      	io[0x07]	= AR
            ; //_AE3845712_91:;					
            _AE3845712_91:
            ; //	io[0x08]	= 0x0000;		
001CF:      	AR	= 0x00
001D0:      	io[0x08]	= AR
            ; //L0E8FA404_21:;					
            L0E8FA404_21:
            ; //_AE3845712_92:;					
            _AE3845712_92:
            ; //	return;					
001D1:      	rets
            ; //L0E8FA404_19_end:;				
            L0E8FA404_19_end:
            ; //_AE3845712_93:;					
            _AE3845712_93:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_AE3845712_94:;					
            _AE3845712_94:
            ; //	
            ; //_AE3845712_95:;					
            _AE3845712_95:
            ; //	sAX	= 0xFFFF;			
001D2:      	AX	= 0xFFFF
            ; //	asm I1 = _iADPCCACC469+0;		
001D4:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
001D5:      	rm[I1]	= AX
            ; //_AE3845712_96:;					
            _AE3845712_96:
            ; //	asm AX = PCMY+0;			
001D6:      	AX = PCMY+0//
            ; //	inbuf+0 = sAX				
001D8:      	rm[inbuf+0]	= AX
            ; //_AE3845712_97:;					
            _AE3845712_97:
            ; //	asm AX = PCMY+0;			
001D9:      	AX = PCMY+0//
            ; //	outbuf+0 = sAX				
001DB:      	rm[outbuf+0]	= AX
            ; //_AE3845712_98:;					
            _AE3845712_98:
            ; //_AE3845712_99:;					
            _AE3845712_99:
            ; //	NEARCALL(L0E8FA404_16);			
001DC:      	call	L0E8FA404_16
            ; //_AE3845712_100:;				
            _AE3845712_100:
            ; //_AE3845712_101:;				
            _AE3845712_101:
            ; //	NEARCALL(L0E8FA404_19);			
001DD:      	call	L0E8FA404_19
            ; //L0E8FA404_22:;					
            L0E8FA404_22:
            ; //_AE3845712_102:;				
            _AE3845712_102:
            ; //	return;					
001DE:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_AE3845712_103:;				
            _AE3845712_103:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> Start=========================
            ; playadp.c Code Start!!;
            VarRM[0:4095]={
             _iADPCCACC469,_adpch30670376[36],_adpFLTG0FBE3CB5[2] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4);
            ; //rjmp void ADPCM_CHX_Init();
            ; //rjmp void ADPCM_CHXGetBts();
            ; //rjmp void _DoADPCM9CD0E20D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4)
            _playADPCMBACD5AFD:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //	__int16 _q_1_6;
            ; //						
001DF:      	AR	= rm[BP_SAVE]
001E0:      	push	AR
001E1:      	AR	= BP
001E2:      	rm[BP_SAVE]	= AR
001E3:      	AR	 = -3
001E4:      	BP	+= AR
            ; //_AE3845712_104:;				
            _AE3845712_104:
            ; //	
            ; //_AE3845712_105:;				
            _AE3845712_105:
            ; //	asm AX = _adpch30670376+0;		
001E5:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
001E6:      	AR	= -1
001E7:      	I1	= rm[BP_SAVE]
001E8:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
001E9:      	rm[I1]	= AX
            ; //_AE3845712_106:;				
            _AE3845712_106:
            ; //	_i_1_2+0	= 0x00;			
001EA:      	I1	= rm[BP_SAVE]
001EB:      	AX	= 0x00
001EC:      	rm[I1]	= AX
            ; //L7F5A46A0_26:;					
            L7F5A46A0_26:
            ; //	sSI	= (int)&_i_1_2;			
001ED:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001EE:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
001EF:      	CX	= 0x02
            ; //	sfx_CMP_AX_CX_JL();			
001F0:      	pch	= sfx_CMP_AX_CX_JL
001F1:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L7F5A46A0_30;	
001F2:      	if ZR	jmp L7F5A46A0_30
            ; //	goto	L7F5A46A0_28;			
001F3:      	jmp	L7F5A46A0_28
            ; //L7F5A46A0_30:;					
            L7F5A46A0_30:
            ; //	goto L7F5A46A0_27;			
001F4:      	jmp	L7F5A46A0_27
            ; //L7F5A46A0_29:;					
            L7F5A46A0_29:
            ; //	sSI	= (int)&_i_1_2;			
001F5:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F6:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
001F7:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
001F8:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
001F9:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
001FA:      	rm[I1] = CX + AR//
            ; //	goto L7F5A46A0_26;			
001FB:      	jmp	L7F5A46A0_26
            ; //L7F5A46A0_27:;					
            L7F5A46A0_27:
            ; //	
            ; //_AE3845712_107:;				
            _AE3845712_107:
            ; //	sSI	= (int)&_p_1_4;			
001FC:      	AR	= -1
001FD:      	I1	= rm[BP_SAVE]
001FE:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
001FF:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00200:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00201:      	AR	= CX
00202:      	AX	+= AR
            ; //	sSI	= sAX;				
00203:      	AR	= AX
00204:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00205:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00206:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
00207:      	AR	= AX
00208:      	AR	|= DX
            ; //	if(__jz__)	goto L7F5A46A0_32;	
00209:      	if ZR	jmp L7F5A46A0_32
            ; //	goto	L7F5A46A0_31;			
0020A:      	jmp	L7F5A46A0_31
            ; //L7F5A46A0_32:;					
            L7F5A46A0_32:
            ; //	
            ; //_AE3845712_108:;				
            _AE3845712_108:
            ; //_AE3845712_109:;				
            _AE3845712_109:
            ; //	sAX	= 0x0012;			
0020B:      	AX	= 0x12
            ; //	PUSH(sAX);				
0020C:      	push	AX
            ; //	sAX	= 0x0000;			
0020D:      	AX	= 0x00
            ; //	PUSH(sAX);				
0020E:      	push	AX
            ; //	sSI	= (int)&_p_1_4;			
0020F:      	AR	= -1
00210:      	I1	= rm[BP_SAVE]
00211:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00212:      	AX	= rm[I1]
            ; //	sDX	= 0;				
00213:      	DX	= 0x00
            ; //	PUSH(sDX);				
00214:      	push	DX
            ; //	PUSH(sAX);				
00215:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00216:      	pch	= _memset5A9D755A
00217:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00218:      	AR	= 4
00219:      	BP	+= AR
            ; //_AE3845712_110:;				
            _AE3845712_110:
            ; //	asm AX = #_adpdata32993E3B+0;		
0021A:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
0021C:      	push	AX
            ; //	sSI	= (int)&_index_0_4;		
0021D:      	AR	= 2
0021E:      	I1	= rm[BP_SAVE]
0021F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00220:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
00221:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
00222:      	pch	= sfx_IMUL_AX_CX
00223:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
00224:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00225:      	AR	= CX
00226:      	AX	+= AR
            ; //	sSI	= (int)&_q_1_6;			
00227:      	AR	= -2
00228:      	I1	= rm[BP_SAVE]
00229:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0022A:      	rm[I1]	= AX
            ; //_AE3845712_111:;				
            _AE3845712_111:
            ; //	sSI	= (int)&_p_1_4;			
0022B:      	AR	= -1
0022C:      	I1	= rm[BP_SAVE]
0022D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0022E:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0022F:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00230:      	AR	= CX
00231:      	AX	+= AR
            ; //	PUSH(sAX);				
00232:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00233:      	AR	= -2
00234:      	I1	= rm[BP_SAVE]
00235:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00236:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00237:      	AR	= AX
00238:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
00239:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
0023A:      	DX	= pm[P1--]
            ; //	sSI	= POP();			
0023B:      	pop	I1
            ; //	sfx_STORSILONG();			
0023C:      	rm[I1++]	= AX
0023D:      	rm[I1--]	= DX
            ; //_AE3845712_112:;				
            _AE3845712_112:
            ; //	sSI	= (int)&_p_1_4;			
0023E:      	AR	= -1
0023F:      	I1	= rm[BP_SAVE]
00240:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00241:      	AX	= rm[I1]
            ; //	sCX	= 0x0011;			
00242:      	CX	= 0x11
            ; //	sAX	= sAX + sCX;			
00243:      	AR	= CX
00244:      	AX	+= AR
            ; //	PUSH(sAX);				
00245:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00246:      	AR	= -2
00247:      	I1	= rm[BP_SAVE]
00248:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00249:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
0024A:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0024B:      	AR	= CX
0024C:      	AX	+= AR
            ; //	sDI	= sAX;				
0024D:      	AR	= AX
0024E:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0024F:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00250:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00251:      	rm[I1]	= AX
            ; //_AE3845712_113:;				
            _AE3845712_113:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
00252:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	PUSH(sAX);				
00253:      	push	AX
            ; //	sSI	= (int)&_i_1_2;			
00254:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00255:      	AX	= rm[I1]
            ; //	
            ; //	sCX	= POP();			
00256:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00257:      	AR	= CX
00258:      	AX	+= AR
            ; //	PUSH(sAX);				
00259:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
0025A:      	AR	= -2
0025B:      	I1	= rm[BP_SAVE]
0025C:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0025D:      	AX	= rm[I1]
            ; //	sCX	= 0x0003;			
0025E:      	CX	= 0x03
            ; //	sAX	= sAX + sCX;			
0025F:      	AR	= CX
00260:      	AX	+= AR
            ; //	sDI	= sAX;				
00261:      	AR	= AX
00262:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00263:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00264:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00265:      	rm[I1]	= AX
            ; //_AE3845712_114:;				
            _AE3845712_114:
            ; //	sAX	= 0x0001;			
00266:      	AX	= 0x01
            ; //	goto L7F5A46A0_25;			
00267:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_31:;					
            L7F5A46A0_31:
            ; //_AE3845712_115:;				
            _AE3845712_115:
            ; //_AE3845712_116:;				
            _AE3845712_116:
            ; //	sSI	= (int)&_p_1_4;			
00268:      	AR	= -1
00269:      	I1	= rm[BP_SAVE]
0026A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0026B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
0026C:      	AR	= -1
0026D:      	I1	= rm[BP_SAVE]
0026E:      	I1	+= AR
            ; //	asm AR = 0x0012;			
0026F:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
00270:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
00271:      	rm[I1] = CX + AR//
            ; //_AE3845712_117:;				
            _AE3845712_117:
            ; //	goto L7F5A46A0_29;			
00272:      	jmp	L7F5A46A0_29
            ; //L7F5A46A0_28:;					
            L7F5A46A0_28:
            ; //_AE3845712_118:;				
            _AE3845712_118:
            ; //	sAX	= 0x0000;			
00273:      	AX	= 0x00
            ; //	goto L7F5A46A0_25;			
00274:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_25:;					
            L7F5A46A0_25:
            ; //_AE3845712_119:;				
            _AE3845712_119:
            ; //	return;					
00275:      	AR	= 3
00276:      	BP	+= AR
00277:      	pop	AR
00278:      	rm[BP_SAVE]	= AR
00279:      	rets
            ; //_playADPCMBACD5AFD_end:;			
            _playADPCMBACD5AFD_end:
            ; //_AE3845712_120:;				
            _AE3845712_120:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHX_Init()			
            ADPCM_CHX_Init:
            ; //{
            ; //_AE3845712_121:;				
            _AE3845712_121:
            ; //	
            ; //_AE3845712_122:;				
            _AE3845712_122:
            ; //	sAX	= 0x0000;			
0027A:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
0027B:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0027C:      	rm[I1]	= AX
            ; //_AE3845712_123:;				
            _AE3845712_123:
            ; //_AE3845712_124:;				
            _AE3845712_124:
            ; //	sAX	= 0x0024;			
0027D:      	AX	= 0x24
            ; //	PUSH(sAX);				
0027E:      	push	AX
            ; //	sAX	= 0x0000;			
0027F:      	AX	= 0x00
            ; //	PUSH(sAX);				
00280:      	push	AX
            ; //	asm AX = _adpch30670376+0;		
00281:      	AX = _adpch30670376+0//
            ; //	sDX	= 0;				
00282:      	DX	= 0x00
            ; //	PUSH(sDX);				
00283:      	push	DX
            ; //	PUSH(sAX);				
00284:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00285:      	pch	= _memset5A9D755A
00286:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00287:      	AR	= 4
00288:      	BP	+= AR
            ; //L7F5A46A0_33:;					
            L7F5A46A0_33:
            ; //_AE3845712_125:;				
            _AE3845712_125:
            ; //	return;					
00289:      	rets
            ; //ADPCM_CHX_Init_end:;				
            ADPCM_CHX_Init_end:
            ; //_AE3845712_126:;				
            _AE3845712_126:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHXGetBts()			
            ADPCM_CHXGetBts:
            ; //{
            ; //_AE3845712_127:;				
            _AE3845712_127:
            ; //_AE3845712_128:;				
            _AE3845712_128:
            ; //	asm	push AX				
0028A:      	push AX
            ; //_AE3845712_129:;				
            _AE3845712_129:
            ; //	asm	push BX				
0028B:      	push BX
            ; //_AE3845712_130:;				
            _AE3845712_130:
            ; //	asm	push CX				
0028C:      	push CX
            ; //_AE3845712_131:;				
            _AE3845712_131:
            ; //	asm	push DX				
0028D:      	push DX
            ; //_AE3845712_132:;				
            _AE3845712_132:
            ; //	asm	push I1				
0028E:      	push I1
            ; //_AE3845712_133:;				
            _AE3845712_133:
            ; //	asm	push P0				
0028F:      	push P0
            ; //_AE3845712_134:;				
            _AE3845712_134:
            ; //	asm	AR = P0.hh			
00290:      	AR = P0.hh
            ; //_AE3845712_135:;				
            _AE3845712_135:
            ; //	asm	push AR				
00291:      	push AR
            ; //	
            ; //_AE3845712_136:;				
            _AE3845712_136:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00292:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00293:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00294:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00295:      	AR	= CX
00296:      	AX	+= AR
            ; //	sSI	= sAX;				
00297:      	AR	= AX
00298:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00299:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
0029A:      	DX	= rm[I1--]
            ; //	PUSH(sAX);				
0029B:      	push	AX
            ; //	PUSH(sDX);				
0029C:      	push	DX
            ; //	sCX	= 0x0001;			
0029D:      	CX	= 0x01
            ; //	sBX	= 0x0000;			
0029E:      	BX	= 0x00
            ; //	sfx_ADDLONG();				
0029F:      	AR	= CX
002A0:      	AX	= AX + AR
002A1:      	AR	= BX
002A2:      	DX	= DX + AR + C
            ; //	sfx_STORSILONG();			
002A3:      	rm[I1++]	= AX
002A4:      	rm[I1--]	= DX
            ; //	sDX	= POP();			
002A5:      	pop	DX
            ; //	sAX	= POP();			
002A6:      	pop	AX
            ; //_AE3845712_137:;				
            _AE3845712_137:
            ; //	asm	AR = AX				
002A7:      	AR = AX
            ; //_AE3845712_138:;				
            _AE3845712_138:
            ; //	asm	P0 = AR				
002A8:      	P0 = AR
            ; //_AE3845712_139:;				
            _AE3845712_139:
            ; //	asm	AR = DX				
002A9:      	AR = DX
            ; //_AE3845712_140:;				
            _AE3845712_140:
            ; //	asm	P0.hh = AR			
002AA:      	P0.hh = AR
            ; //	
            ; //_AE3845712_141:;				
            _AE3845712_141:
            ; //_AE3845712_142:;				
            _AE3845712_142:
            ; //	read_P0();				
002AB:      	AX	= pm[P0]
            ; //_AE3845712_143:;				
            _AE3845712_143:
            ; //	asm	pop AR				
002AC:      	pop AR
            ; //_AE3845712_144:;				
            _AE3845712_144:
            ; //	asm	P0.hh = AR			
002AD:      	P0.hh = AR
            ; //_AE3845712_145:;				
            _AE3845712_145:
            ; //	asm	pop P0				
002AE:      	pop P0
            ; //_AE3845712_146:;				
            _AE3845712_146:
            ; //	asm	pop I1				
002AF:      	pop I1
            ; //_AE3845712_147:;				
            _AE3845712_147:
            ; //	asm	pop DX				
002B0:      	pop DX
            ; //_AE3845712_148:;				
            _AE3845712_148:
            ; //	asm	pop CX				
002B1:      	pop CX
            ; //_AE3845712_149:;				
            _AE3845712_149:
            ; //	asm	pop BX				
002B2:      	pop BX
            ; //	
            ; //_AE3845712_150:;				
            _AE3845712_150:
            ; //_AE3845712_151:;				
            _AE3845712_151:
            ; //	asintax();				
            ; //_AE3845712_152:;				
            _AE3845712_152:
            ; //	asm	AR = AX				
002B3:      	AR = AX
            ; //_AE3845712_153:;				
            _AE3845712_153:
            ; //	asm	pop AX				
002B4:      	pop AX
            ; //L7F5A46A0_34:;					
            L7F5A46A0_34:
            ; //_AE3845712_154:;				
            _AE3845712_154:
            ; //	return;					
002B5:      	rets
            ; //ADPCM_CHXGetBts_end:;				
            ADPCM_CHXGetBts_end:
            ; //_AE3845712_155:;				
            _AE3845712_155:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_35()			
            L7F5A46A0_35:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
002B6:      	AR	= rm[BP_SAVE]
002B7:      	push	AR
002B8:      	AR	= BP
002B9:      	rm[BP_SAVE]	= AR
002BA:      	AR	 = -1
002BB:      	BP	+= AR
            ; //_AE3845712_156:;				
            _AE3845712_156:
            ; //	
            ; //_AE3845712_157:;				
            _AE3845712_157:
            ; //	asm I1 = inbuf+0;			
002BC:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
002BD:      	AX	= rm[I1]
            ; //_AE3845712_158:;				
            _AE3845712_158:
            ; //	asm	AR = AX				
002BE:      	AR = AX
            ; //_AE3845712_159:;				
            _AE3845712_159:
            ; //	asm	I0 = AR				
002BF:      	I0 = AR
            ; //	
            ; //	
            ; //_AE3845712_160:;				
            _AE3845712_160:
            ; //	_i_1_2+0	= 0x40;			
002C0:      	I1	= rm[BP_SAVE]
002C1:      	AX	= 0x40
002C2:      	rm[I1]	= AX
            ; //L7F5A46A0_39:;					
            L7F5A46A0_39:
            ; //_AE3845712_161:;				
            _AE3845712_161:
            ; //	sSI	= (int)&_i_1_2;			
002C3:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002C4:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
002C5:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_40;	
002C6:      	if NZ	jmp L7F5A46A0_40
            ; //	goto	L7F5A46A0_38;			
002C7:      	jmp	L7F5A46A0_38
            ; //L7F5A46A0_40:;					
            L7F5A46A0_40:
            ; //	
            ; //_AE3845712_162:;				
            _AE3845712_162:
            ; //	sAX	= 0x0000;			
002C8:      	AX	= 0x00
            ; //_AE3845712_163:;				
            _AE3845712_163:
            ; //	asm	rm[I0++] = AX			
002C9:      	rm[I0++] = AX
            ; //	
            ; //_AE3845712_164:;				
            _AE3845712_164:
            ; //	sSI	= (int)&_i_1_2;			
002CA:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002CB:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
002CC:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
002CD:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
002CE:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
002CF:      	rm[I1] = CX - AR//
            ; //_AE3845712_165:;				
            _AE3845712_165:
            ; //	goto L7F5A46A0_39;			
002D0:      	jmp	L7F5A46A0_39
            ; //L7F5A46A0_38:;					
            L7F5A46A0_38:
            ; //L7F5A46A0_37:;					
            L7F5A46A0_37:
            ; //_AE3845712_166:;				
            _AE3845712_166:
            ; //	return;					
002D1:      	AR	= 1
002D2:      	BP	+= AR
002D3:      	pop	AR
002D4:      	rm[BP_SAVE]	= AR
002D5:      	rets
            ; //L7F5A46A0_35_end:;				
            L7F5A46A0_35_end:
            ; //_AE3845712_167:;				
            _AE3845712_167:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_41(__int16 _vol_0_4)	
            L7F5A46A0_41:
            ; //{
            ; //	__int16 _p_1_2;
            ; //	__int16 _i_1_4;
            ; //						
002D6:      	AR	= rm[BP_SAVE]
002D7:      	push	AR
002D8:      	AR	= BP
002D9:      	rm[BP_SAVE]	= AR
002DA:      	AR	 = -2
002DB:      	BP	+= AR
            ; //_AE3845712_168:;				
            _AE3845712_168:
            ; //	
            ; //_AE3845712_169:;				
            _AE3845712_169:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002DC:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002DD:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
002DE:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
002DF:      	AR	= CX
002E0:      	AX	+= AR
            ; //	sSI	= sAX;				
002E1:      	AR	= AX
002E2:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
002E3:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
002E4:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
002E5:      	AR	= AX
002E6:      	AR	|= DX
            ; //	if(__jnz__)	goto L7F5A46A0_45;	
002E7:      	if NZ	jmp L7F5A46A0_45
            ; //	goto	L7F5A46A0_44;			
002E8:      	jmp	L7F5A46A0_44
            ; //L7F5A46A0_45:;					
            L7F5A46A0_45:
            ; //	
            ; //_AE3845712_170:;				
            _AE3845712_170:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002E9:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002EA:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
002EB:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
002EC:      	AR	= CX
002ED:      	AX	+= AR
            ; //_AE3845712_171:;				
            _AE3845712_171:
            ; //	asm	AR = AX				
002EE:      	AR = AX
            ; //_AE3845712_172:;				
            _AE3845712_172:
            ; //	asm	I0 = AR				
002EF:      	I0 = AR
            ; //	
            ; //	
            ; //_AE3845712_173:;				
            _AE3845712_173:
            ; //_AE3845712_174:;				
            _AE3845712_174:
            ; //	read_I0P();				
002F0:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F1:      	AR	= AX
002F2:      	io[0x36]	= AR
            ; //_AE3845712_175:;				
            _AE3845712_175:
            ; //_AE3845712_176:;				
            _AE3845712_176:
            ; //	read_I0P();				
002F3:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F4:      	AR	= AX
002F5:      	io[0x36]	= AR
            ; //_AE3845712_177:;				
            _AE3845712_177:
            ; //_AE3845712_178:;				
            _AE3845712_178:
            ; //	read_I0P();				
002F6:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F7:      	AR	= AX
002F8:      	io[0x36]	= AR
            ; //_AE3845712_179:;				
            _AE3845712_179:
            ; //_AE3845712_180:;				
            _AE3845712_180:
            ; //	read_I0P();				
002F9:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002FA:      	AR	= AX
002FB:      	io[0x36]	= AR
            ; //_AE3845712_181:;				
            _AE3845712_181:
            ; //_AE3845712_182:;				
            _AE3845712_182:
            ; //	read_I0P();				
002FC:      	AX	= rm[I0++]
            ; //	io[0x3D]	= sAX;			
002FD:      	AR	= AX
002FE:      	io[0x3D]	= AR
            ; //_AE3845712_183:;				
            _AE3845712_183:
            ; //_AE3845712_184:;				
            _AE3845712_184:
            ; //	read_I0P();				
002FF:      	AX	= rm[I0++]
            ; //	io[0x3E]	= sAX;			
00300:      	AR	= AX
00301:      	io[0x3E]	= AR
            ; //_AE3845712_185:;				
            _AE3845712_185:
            ; //	sSI	= (int)&_vol_0_4;		
00302:      	AR	= 2
00303:      	I1	= rm[BP_SAVE]
00304:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00305:      	AX	= rm[I1]
            ; //	io[0x3C]	= sAX;			
00306:      	AR	= AX
00307:      	io[0x3C]	= AR
            ; //_AE3845712_186:;				
            _AE3845712_186:
            ; //	sAX	= io[0x3C];			
00308:      	AR	= io[0x3C]
00309:      	AX	= AR
            ; //_AE3845712_187:;				
            _AE3845712_187:
            ; //	asm I1 = inbuf+0;			
0030A:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
0030B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_2;			
0030C:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0030D:      	rm[I1]	= AX
            ; //_AE3845712_188:;				
            _AE3845712_188:
            ; //	_i_1_4+0	= 0x20;			
0030E:      	AR	= -1
0030F:      	I1	= rm[BP_SAVE]
00310:      	I1	+= AR
00311:      	AX	= 0x20
00312:      	rm[I1]	= AX
            ; //L7F5A46A0_47:;					
            L7F5A46A0_47:
            ; //_AE3845712_189:;				
            _AE3845712_189:
            ; //	sSI	= (int)&_i_1_4;			
00313:      	AR	= -1
00314:      	I1	= rm[BP_SAVE]
00315:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00316:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00317:      	AR	= -1
00318:      	I1	= rm[BP_SAVE]
00319:      	I1	+= AR
            ; //	asm AR = 0x0001;			
0031A:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0031B:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0031C:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0031D:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_48;	
0031E:      	if NZ	jmp L7F5A46A0_48
            ; //	goto	L7F5A46A0_46;			
0031F:      	jmp	L7F5A46A0_46
            ; //L7F5A46A0_48:;					
            L7F5A46A0_48:
            ; //	
            ; //_AE3845712_190:;				
            _AE3845712_190:
            ; //	sAX	= 0;				
00320:      	AX	= 0x00
            ; //	asm test io[0x00].b14;			
00321:      	test io[0x00].b14//
            ; //	if(__jz__) goto L7F5A46A0_49;		
00322:      	if ZR	jmp L7F5A46A0_49
            ; //	sAX	= 1;				
00323:      	AX	= 0x01
            ; //L7F5A46A0_49:;					
            L7F5A46A0_49:
            ; //	sfx_CHECKZERO();			
00324:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_51;	
00325:      	if ZR	jmp L7F5A46A0_51
            ; //	goto	L7F5A46A0_50;			
00326:      	jmp	L7F5A46A0_50
            ; //L7F5A46A0_51:;					
            L7F5A46A0_51:
            ; //	
            ; //_AE3845712_191:;				
            _AE3845712_191:
            ; //_AE3845712_192:;				
            _AE3845712_192:
            ; //	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E();
00327:      	pch	= _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
00328:      	lcall	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
            ; //	sfx_CHECKZERO();			
00329:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_53;	
0032A:      	if ZR	jmp L7F5A46A0_53
            ; //	goto	L7F5A46A0_52;			
0032B:      	jmp	L7F5A46A0_52
            ; //L7F5A46A0_53:;					
            L7F5A46A0_53:
            ; //	
            ; //_AE3845712_193:;				
            _AE3845712_193:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0032C:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0032D:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0032E:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0032F:      	AR	= CX
00330:      	AX	+= AR
            ; //	PUSH(sAX);				
00331:      	push	AX
            ; //	sAX	= 0x0000;			
00332:      	AX	= 0x00
            ; //	sDX	= 0x0000;			
00333:      	DX	= 0x00
            ; //	sSI	= POP();			
00334:      	pop	I1
            ; //	sfx_STORSILONG();			
00335:      	rm[I1++]	= AX
00336:      	rm[I1--]	= DX
            ; //_AE3845712_194:;				
            _AE3845712_194:
            ; //	goto L7F5A46A0_43;			
00337:      	jmp	L7F5A46A0_43
            ; //L7F5A46A0_52:;					
            L7F5A46A0_52:
            ; //_AE3845712_195:;				
            _AE3845712_195:
            ; //_AE3845712_196:;				
            _AE3845712_196:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00338:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00339:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
0033A:      	AR	= AX
0033B:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0033C:      	AX	= rm[I1]
            ; //	io[0x36]	= sAX;			
0033D:      	AR	= AX
0033E:      	io[0x36]	= AR
            ; //L7F5A46A0_50:;					
            L7F5A46A0_50:
            ; //_AE3845712_197:;				
            _AE3845712_197:
            ; //_AE3845712_198:;				
            _AE3845712_198:
            ; //	sSI	= (int)&_p_1_2;			
0033F:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00340:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00341:      	push	AX
            ; //	sSI	= (int)&_p_1_2;			
00342:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00343:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
00344:      	AR	= AX
00345:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00346:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00347:      	DX	= rm[I1--]
            ; //	PUSH(sDX);				
00348:      	push	DX
            ; //	PUSH(sAX);				
00349:      	push	AX
            ; //	sAX	= io[0x3C];			
0034A:      	AR	= io[0x3C]
0034B:      	AX	= AR
            ; //	sfx_INT2LONG_AX();			
0034C:      	DX	= 0
0034D:      	test	AX.b15
0034E:      	if ZR jmp LFE021D20_0
0034F:      	DX = -1
            LFE021D20_0:
            ; //	sCX	= POP();			
00350:      	pop	CX
            ; //	sBX	= POP();			
00351:      	pop	BX
            ; //	sfx_ADDLONG();				
00352:      	AR	= CX
00353:      	AX	= AX + AR
00354:      	AR	= BX
00355:      	DX	= DX + AR + C
            ; //	sSI	= POP();			
00356:      	pop	I1
            ; //	sfx_STORSILONG();			
00357:      	rm[I1++]	= AX
00358:      	rm[I1--]	= DX
            ; //	sSI	= (int)&_p_1_2;			
00359:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0002;			
0035A:      	AR = 0x0002//
            ; //	sAX	= *(__int16*)sSI;		
0035B:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
0035C:      	rm[I1] = AX + AR//
            ; //_AE3845712_199:;				
            _AE3845712_199:
            ; //	goto L7F5A46A0_47;			
0035D:      	jmp	L7F5A46A0_47
            ; //L7F5A46A0_46:;					
            L7F5A46A0_46:
            ; //	
            ; //_AE3845712_200:;				
            _AE3845712_200:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0035E:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0035F:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
00360:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
00361:      	AR	= CX
00362:      	AX	+= AR
            ; //_AE3845712_201:;				
            _AE3845712_201:
            ; //	asm	AR = AX				
00363:      	AR = AX
            ; //_AE3845712_202:;				
            _AE3845712_202:
            ; //	asm	I0 = AR				
00364:      	I0 = AR
            ; //	
            ; //	
            ; //_AE3845712_203:;				
            _AE3845712_203:
            ; //	sAX	= io[0x36];			
00365:      	AR	= io[0x36]
00366:      	AX	= AR
            ; //_AE3845712_204:;				
            _AE3845712_204:
            ; //	asm	rm[I0++] = AX			
00367:      	rm[I0++] = AX
            ; //	
            ; //_AE3845712_205:;				
            _AE3845712_205:
            ; //	sAX	= io[0x36];			
00368:      	AR	= io[0x36]
00369:      	AX	= AR
            ; //_AE3845712_206:;				
            _AE3845712_206:
            ; //	asm	rm[I0++] = AX			
0036A:      	rm[I0++] = AX
            ; //	
            ; //_AE3845712_207:;				
            _AE3845712_207:
            ; //	sAX	= io[0x36];			
0036B:      	AR	= io[0x36]
0036C:      	AX	= AR
            ; //_AE3845712_208:;				
            _AE3845712_208:
            ; //	asm	rm[I0++] = AX			
0036D:      	rm[I0++] = AX
            ; //	
            ; //_AE3845712_209:;				
            _AE3845712_209:
            ; //	sAX	= io[0x36];			
0036E:      	AR	= io[0x36]
0036F:      	AX	= AR
            ; //_AE3845712_210:;				
            _AE3845712_210:
            ; //	asm	rm[I0++] = AX			
00370:      	rm[I0++] = AX
            ; //	
            ; //_AE3845712_211:;				
            _AE3845712_211:
            ; //	sAX	= io[0x3D];			
00371:      	AR	= io[0x3D]
00372:      	AX	= AR
            ; //_AE3845712_212:;				
            _AE3845712_212:
            ; //	asm	rm[I0++] = AX			
00373:      	rm[I0++] = AX
            ; //L7F5A46A0_44:;					
            L7F5A46A0_44:
            ; //_AE3845712_213:;				
            _AE3845712_213:
            ; //L7F5A46A0_43:;					
            L7F5A46A0_43:
            ; //_AE3845712_214:;				
            _AE3845712_214:
            ; //	return;					
00374:      	AR	= 2
00375:      	BP	+= AR
00376:      	pop	AR
00377:      	rm[BP_SAVE]	= AR
00378:      	rets
            ; //L7F5A46A0_41_end:;				
            L7F5A46A0_41_end:
            ; //_AE3845712_215:;				
            _AE3845712_215:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_54()			
            L7F5A46A0_54:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00379:      	AR	= rm[BP_SAVE]
0037A:      	push	AR
0037B:      	AR	= BP
0037C:      	rm[BP_SAVE]	= AR
0037D:      	AR	 = -1
0037E:      	BP	+= AR
            ; //_AE3845712_216:;				
            _AE3845712_216:
            ; //	
            ; //_AE3845712_217:;				
            _AE3845712_217:
            ; //	asm I1 = inbuf+0;			
0037F:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
00380:      	AX	= rm[I1]
            ; //_AE3845712_218:;				
            _AE3845712_218:
            ; //	asm	AR = AX				
00381:      	AR = AX
            ; //_AE3845712_219:;				
            _AE3845712_219:
            ; //	asm	I0 = AR				
00382:      	I0 = AR
            ; //	
            ; //	
            ; //_AE3845712_220:;				
            _AE3845712_220:
            ; //	sAX	= io[0x33];			
00383:      	AR	= io[0x33]
00384:      	AX	= AR
            ; //_AE3845712_221:;				
            _AE3845712_221:
            ; //	_i_1_2+0	= 0x20;			
00385:      	I1	= rm[BP_SAVE]
00386:      	AX	= 0x20
00387:      	rm[I1]	= AX
            ; //L7F5A46A0_58:;					
            L7F5A46A0_58:
            ; //_AE3845712_222:;				
            _AE3845712_222:
            ; //	sSI	= (int)&_i_1_2;			
00388:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00389:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0038A:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0038B:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0038C:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0038D:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0038E:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_59;	
0038F:      	if NZ	jmp L7F5A46A0_59
            ; //	goto	L7F5A46A0_57;			
00390:      	jmp	L7F5A46A0_57
            ; //L7F5A46A0_59:;					
            L7F5A46A0_59:
            ; //	
            ; //_AE3845712_223:;				
            _AE3845712_223:
            ; //_AE3845712_224:;				
            _AE3845712_224:
            ; //	read_I0P();				
00391:      	AX	= rm[I0++]
            ; //	io[0x33]	= sAX;			
00392:      	AR	= AX
00393:      	io[0x33]	= AR
            ; //_AE3845712_225:;				
            _AE3845712_225:
            ; //_AE3845712_226:;				
            _AE3845712_226:
            ; //	read_I0M();				
00394:      	AX	= rm[I0--]
            ; //	io[0x33]	= sAX;			
00395:      	AR	= AX
00396:      	io[0x33]	= AR
            ; //	
            ; //_AE3845712_227:;				
            _AE3845712_227:
            ; //	sAX	= io[0x33];			
00397:      	AR	= io[0x33]
00398:      	AX	= AR
            ; //_AE3845712_228:;				
            _AE3845712_228:
            ; //	asm	rm[I0++2] = AX			
00399:      	rm[I0++2] = AX
            ; //_AE3845712_229:;				
            _AE3845712_229:
            ; //	goto L7F5A46A0_58;			
0039A:      	jmp	L7F5A46A0_58
            ; //L7F5A46A0_57:;					
            L7F5A46A0_57:
            ; //_AE3845712_230:;				
            _AE3845712_230:
            ; //	asm I1 = inbuf+0;			
0039B:      	I1 = inbuf+0//
            ; //	asm AR = rm[I1];			
0039C:      	AR = rm[I1]//
            ; //	asm not AR.b6;				
0039D:      	not AR.b6//
            ; //	asm rm[I1] = AR;			
0039E:      	rm[I1] = AR//
            ; //L7F5A46A0_56:;					
            L7F5A46A0_56:
            ; //_AE3845712_231:;				
            _AE3845712_231:
            ; //	return;					
0039F:      	AR	= 1
003A0:      	BP	+= AR
003A1:      	pop	AR
003A2:      	rm[BP_SAVE]	= AR
003A3:      	rets
            ; //L7F5A46A0_54_end:;				
            L7F5A46A0_54_end:
            ; //_AE3845712_232:;				
            _AE3845712_232:
            ; //}
            ; //
            ; //rjmp void _DoADPCM9CD0E20D()			
            _DoADPCM9CD0E20D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //						
003A4:      	AR	= rm[BP_SAVE]
003A5:      	push	AR
003A6:      	AR	= BP
003A7:      	rm[BP_SAVE]	= AR
003A8:      	AR	 = -2
003A9:      	BP	+= AR
            ; //_AE3845712_233:;				
            _AE3845712_233:
            ; //	
            ; //_AE3845712_234:;				
            _AE3845712_234:
            ; //	asm I1 = inbuf+0;			
003AA:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
003AB:      	AX	= rm[I1]
            ; //	asm I1 = outbuf+0;			
003AC:      	I1 = outbuf+0//
            ; //	asm AR = rm[I1];			
003AD:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
003AE:      	AX = AX ^ AR//
            ; //	asm AR = 0x0040;			
003AF:      	AR = 0x0040//
            ; //	asm AX = AX & AR;			
003B0:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003B1:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_62;	
003B2:      	if ZR	jmp L7F5A46A0_62
            ; //	goto	L7F5A46A0_61;			
003B3:      	jmp	L7F5A46A0_61
            ; //L7F5A46A0_62:;					
            L7F5A46A0_62:
            ; //_AE3845712_235:;				
            _AE3845712_235:
            ; //	goto L7F5A46A0_60;			
003B4:      	jmp	L7F5A46A0_60
            ; //L7F5A46A0_61:;					
            L7F5A46A0_61:
            ; //_AE3845712_236:;				
            _AE3845712_236:
            ; //_AE3845712_237:;				
            _AE3845712_237:
            ; //	asm set io[0x09].b0;			
003B5:      	set io[0x09].b0//
            ; //_AE3845712_238:;				
            _AE3845712_238:
            ; //_AE3845712_239:;				
            _AE3845712_239:
            ; //	L7F5A46A0_35();				
003B6:      	pch	= L7F5A46A0_35
003B7:      	lcall	L7F5A46A0_35
            ; //_AE3845712_240:;				
            _AE3845712_240:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
003B8:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	sSI	= (int)&_p_1_4;			
003B9:      	AR	= -1
003BA:      	I1	= rm[BP_SAVE]
003BB:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003BC:      	rm[I1]	= AX
            ; //_AE3845712_241:;				
            _AE3845712_241:
            ; //	asm AX = _adpch30670376+0;		
003BD:      	AX = _adpch30670376+0//
            ; //	asm I1 = ADPCM_Tmpi+0;			
003BE:      	I1 = ADPCM_Tmpi+0//
            ; //	*(__int16*)sSI	= sAX			
003BF:      	rm[I1]	= AX
            ; //_AE3845712_242:;				
            _AE3845712_242:
            ; //	_i_1_2+0	= 0x02;			
003C0:      	I1	= rm[BP_SAVE]
003C1:      	AX	= 0x02
003C2:      	rm[I1]	= AX
            ; //L7F5A46A0_64:;					
            L7F5A46A0_64:
            ; //_AE3845712_243:;				
            _AE3845712_243:
            ; //	sSI	= (int)&_i_1_2;			
003C3:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003C4:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003C5:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003C6:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003C7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003C8:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003C9:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_65;	
003CA:      	if NZ	jmp L7F5A46A0_65
            ; //	goto	L7F5A46A0_63;			
003CB:      	jmp	L7F5A46A0_63
            ; //L7F5A46A0_65:;					
            L7F5A46A0_65:
            ; //	
            ; //_AE3845712_244:;				
            _AE3845712_244:
            ; //_AE3845712_245:;				
            _AE3845712_245:
            ; //	sSI	= (int)&_p_1_4;			
003CC:      	AR	= -1
003CD:      	I1	= rm[BP_SAVE]
003CE:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003CF:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
003D0:      	AR	= -1
003D1:      	I1	= rm[BP_SAVE]
003D2:      	I1	+= AR
            ; //	asm AR = 0x0001;			
003D3:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003D4:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003D5:      	rm[I1] = CX + AR//
            ; //	sSI	= sAX;				
003D6:      	AR	= AX
003D7:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
003D8:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
003D9:      	push	AX
            ; //	L7F5A46A0_41(STACK[sSP + 0]);		
003DA:      	pch	= L7F5A46A0_41
003DB:      	lcall	L7F5A46A0_41
            ; //	RESTORESP(1);				
003DC:      	pop	AR
            ; //_AE3845712_246:;				
            _AE3845712_246:
            ; //	asm I1 = ADPCM_Tmpi+0;			
003DD:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
003DE:      	AX	= rm[I1]
            ; //	sSI	= (int)&ADPCM_Tmpi;		
003DF:      	I1	= ADPCM_Tmpi
            ; //	sCX	= *(__int16*)sSI;		
003E0:      	CX	= rm[I1]
            ; //	asm AR = 0x0012;			
003E1:      	AR = 0x0012//
            ; //	asm rm[I1] = CX + AR;			
003E2:      	rm[I1] = CX + AR//
            ; //_AE3845712_247:;				
            _AE3845712_247:
            ; //	goto L7F5A46A0_64;			
003E3:      	jmp	L7F5A46A0_64
            ; //L7F5A46A0_63:;					
            L7F5A46A0_63:
            ; //_AE3845712_248:;				
            _AE3845712_248:
            ; //_AE3845712_249:;				
            _AE3845712_249:
            ; //	L7F5A46A0_54();				
003E4:      	pch	= L7F5A46A0_54
003E5:      	lcall	L7F5A46A0_54
            ; //_AE3845712_250:;				
            _AE3845712_250:
            ; //	asm clr io[0x09].b0;			
003E6:      	clr io[0x09].b0//
            ; //L7F5A46A0_60:;					
            L7F5A46A0_60:
            ; //_AE3845712_251:;				
            _AE3845712_251:
            ; //	return;					
003E7:      	AR	= 2
003E8:      	BP	+= AR
003E9:      	pop	AR
003EA:      	rm[BP_SAVE]	= AR
003EB:      	rets
            ; //_DoADPCM9CD0E20D_end:;				
            _DoADPCM9CD0E20D_end:
            ; //_AE3845712_252:;				
            _AE3845712_252:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_67,L5589D4CE_68,L5589D4CE_69 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_AE3845712_253:;				
            _AE3845712_253:
            ; //	
            ; //_AE3845712_254:;				
            _AE3845712_254:
            ; //	asm clr io[0x04].b0;			
003EC:      	clr io[0x04].b0//
            ; //_AE3845712_255:;				
            _AE3845712_255:
            ; //	asm clr io[0x04].b1;			
003ED:      	clr io[0x04].b1//
            ; //_AE3845712_256:;				
            _AE3845712_256:
            ; //	asm clr io[0x04].b2;			
003EE:      	clr io[0x04].b2//
            ; //_AE3845712_257:;				
            _AE3845712_257:
            ; //	asm clr io[0x04].b3;			
003EF:      	clr io[0x04].b3//
            ; //_AE3845712_258:;				
            _AE3845712_258:
            ; //	io[0x1E]	= 0x0005;		
003F0:      	AR	= 0x05
003F1:      	io[0x1E]	= AR
            ; //_AE3845712_259:;				
            _AE3845712_259:
            ; //	sAX	= 0x000F;			
003F2:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
003F3:      	AR	= io[0x1F]
003F4:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
003F5:      	AR	= AX
003F6:      	io[0x1F]	= AR
            ; //_AE3845712_260:;				
            _AE3845712_260:
            ; //	sAX	= 0x0000;			
003F7:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_67;		
003F8:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
003F9:      	rm[I1]	= AX
            ; //_AE3845712_261:;				
            _AE3845712_261:
            ; //	sAX	= 0x0000;			
003FA:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_68;		
003FB:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
003FC:      	rm[I1]	= AX
            ; //_AE3845712_262:;				
            _AE3845712_262:
            ; //	sAX	= 0x0200;			
003FD:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
003FF:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00400:      	rm[I1]	= AX
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //_AE3845712_263:;				
            _AE3845712_263:
            ; //	return;					
00401:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_AE3845712_264:;				
            _AE3845712_264:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_71()			
            L5589D4CE_71:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
00402:      	AR	= rm[BP_SAVE]
00403:      	push	AR
00404:      	AR	= BP
00405:      	rm[BP_SAVE]	= AR
00406:      	AR	 = -1
00407:      	BP	+= AR
            ; //_AE3845712_265:;				
            _AE3845712_265:
            ; //	
            ; //_AE3845712_266:;				
            _AE3845712_266:
            ; //	sAX	= 0x000F;			
00408:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
00409:      	AR	= io[0x07]
0040A:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
0040B:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0040C:      	rm[I1]	= AX
            ; //_AE3845712_267:;				
            _AE3845712_267:
            ; //	sSI	= (int)&_btn_1_2;		
0040D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0040E:      	AX	= rm[I1]
            ; //	goto L5589D4CE_73;			
0040F:      	jmp	L5589D4CE_73
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //_AE3845712_268:;				
            _AE3845712_268:
            ; //	return;					
00410:      	AR	= 1
00411:      	BP	+= AR
00412:      	pop	AR
00413:      	rm[BP_SAVE]	= AR
00414:      	rets
            ; //L5589D4CE_71_end:;				
            L5589D4CE_71_end:
            ; //_AE3845712_269:;				
            _AE3845712_269:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
00415:      	AR	= rm[BP_SAVE]
00416:      	push	AR
00417:      	AR	= BP
00418:      	rm[BP_SAVE]	= AR
00419:      	AR	 = -5
0041A:      	BP	+= AR
            ; //_AE3845712_270:;				
            _AE3845712_270:
            ; //	
            ; //_AE3845712_271:;				
            _AE3845712_271:
            ; //_AE3845712_272:;				
            _AE3845712_272:
            ; //	NEARCALL(L5589D4CE_71);			
0041B:      	call	L5589D4CE_71
            ; //	sSI	= (int)&_keynow_1_2;		
0041C:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0041D:      	rm[I1]	= AX
            ; //_AE3845712_273:;				
            _AE3845712_273:
            ; //	asm I1 = L5589D4CE_67+0;		
0041E:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
0041F:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
00420:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00421:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00422:      	pch	= sfx_CMP_AX_CX_JNE
00423:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_76;	
00424:      	if ZR	jmp L5589D4CE_76
            ; //	goto	L5589D4CE_75;			
00425:      	jmp	L5589D4CE_75
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //	
            ; //_AE3845712_274:;				
            _AE3845712_274:
            ; //	sSI	= (int)&_keynow_1_2;		
00426:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00427:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_67;		
00428:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
00429:      	rm[I1]	= AX
            ; //_AE3845712_275:;				
            _AE3845712_275:
            ; //	sAX	= 0x0200;			
0042A:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
0042C:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
0042D:      	rm[I1]	= AX
            ; //_AE3845712_276:;				
            _AE3845712_276:
            ; //	goto L5589D4CE_74;			
0042E:      	jmp	L5589D4CE_74
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //_AE3845712_277:;				
            _AE3845712_277:
            ; //_AE3845712_278:;				
            _AE3845712_278:
            ; //	asm I1 = L5589D4CE_69+0;		
0042F:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
00430:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00431:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_78;	
00432:      	if NZ	jmp L5589D4CE_78
            ; //	goto	L5589D4CE_77;			
00433:      	jmp	L5589D4CE_77
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //	
            ; //_AE3845712_279:;				
            _AE3845712_279:
            ; //	asm I1 = L5589D4CE_69+0;		
00434:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
00435:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00436:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
00437:      	AR	= CX
00438:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_69;		
00439:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
0043A:      	rm[I1]	= AX
            ; //_AE3845712_280:;				
            _AE3845712_280:
            ; //	goto L5589D4CE_74;			
0043B:      	jmp	L5589D4CE_74
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //_AE3845712_281:;				
            _AE3845712_281:
            ; //_AE3845712_282:;				
            _AE3845712_282:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
0043C:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
0043E:      	AR	= -4
0043F:      	I1	= rm[BP_SAVE]
00440:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00441:      	rm[I1]	= AX
            ; //_AE3845712_283:;				
            _AE3845712_283:
            ; //	sAX	= 0x0200;			
00442:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
00444:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00445:      	rm[I1]	= AX
            ; //_AE3845712_284:;				
            _AE3845712_284:
            ; //	asm I1 = L5589D4CE_68+0;		
00446:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
00447:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_67+0;		
00448:      	I1 = L5589D4CE_67+0//
            ; //	asm AR = rm[I1];			
00449:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
0044A:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0044B:      	AR	= -2
0044C:      	I1	= rm[BP_SAVE]
0044D:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0044E:      	rm[I1]	= AX
            ; //_AE3845712_285:;				
            _AE3845712_285:
            ; //	asm I1 = L5589D4CE_68+0;		
0044F:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
00450:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00451:      	AR	= -3
00452:      	I1	= rm[BP_SAVE]
00453:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00454:      	rm[I1]	= AX
            ; //_AE3845712_286:;				
            _AE3845712_286:
            ; //	asm I1 = L5589D4CE_67+0;		
00455:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
00456:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_68;		
00457:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
00458:      	rm[I1]	= AX
            ; //_AE3845712_287:;				
            _AE3845712_287:
            ; //	_i_1_4+0	= 0x05;			
00459:      	AR	= -1
0045A:      	I1	= rm[BP_SAVE]
0045B:      	I1	+= AR
0045C:      	AX	= 0x05
0045D:      	rm[I1]	= AX
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //_AE3845712_288:;				
            _AE3845712_288:
            ; //	sSI	= (int)&_i_1_4;			
0045E:      	AR	= -1
0045F:      	I1	= rm[BP_SAVE]
00460:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00461:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00462:      	AR	= -1
00463:      	I1	= rm[BP_SAVE]
00464:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00465:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00466:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00467:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00468:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_81;	
00469:      	if NZ	jmp L5589D4CE_81
            ; //	goto	L5589D4CE_79;			
0046A:      	jmp	L5589D4CE_79
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	
            ; //_AE3845712_289:;				
            _AE3845712_289:
            ; //	sAX	= 0;				
0046B:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
0046C:      	AR	= -2
0046D:      	I1	= rm[BP_SAVE]
0046E:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0046F:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00470:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_83;		
00471:      	if ZR	jmp L5589D4CE_83
            ; //	sAX	= 1;				
00472:      	AX	= 0x01
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //	sfx_CHECKZERO();			
00473:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_84;	
00474:      	if NZ	jmp L5589D4CE_84
            ; //	goto	L5589D4CE_82;			
00475:      	jmp	L5589D4CE_82
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //	
            ; //_AE3845712_290:;				
            _AE3845712_290:
            ; //	sAX	= 0;				
00476:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
00477:      	AR	= -3
00478:      	I1	= rm[BP_SAVE]
00479:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0047A:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0047B:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_86;		
0047C:      	if ZR	jmp L5589D4CE_86
            ; //	sAX	= 1;				
0047D:      	AX	= 0x01
            ; //L5589D4CE_86:;					
            L5589D4CE_86:
            ; //	sfx_CHECKZERO();			
0047E:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_87;	
0047F:      	if NZ	jmp L5589D4CE_87
            ; //	goto	L5589D4CE_85;			
00480:      	jmp	L5589D4CE_85
            ; //L5589D4CE_87:;					
            L5589D4CE_87:
            ; //	
            ; //_AE3845712_291:;				
            _AE3845712_291:
            ; //	sSI	= (int)&_pkey_1_10;		
00481:      	AR	= -4
00482:      	I1	= rm[BP_SAVE]
00483:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00484:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00485:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00486:      	AR	= CX
00487:      	AX	+= AR
            ; //	sDI	= sAX;				
00488:      	AR	= AX
00489:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0048A:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0048B:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_89;	
0048C:      	if NZ	jmp L5589D4CE_89
            ; //	goto	L5589D4CE_88;			
0048D:      	jmp	L5589D4CE_88
            ; //L5589D4CE_89:;					
            L5589D4CE_89:
            ; //_AE3845712_292:;				
            _AE3845712_292:
            ; //_AE3845712_293:;				
            _AE3845712_293:
            ; //	sSI	= (int)&_pkey_1_10;		
0048E:      	AR	= -4
0048F:      	I1	= rm[BP_SAVE]
00490:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00491:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00492:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00493:      	AR	= CX
00494:      	AX	+= AR
            ; //	sDI	= sAX;				
00495:      	AR	= AX
00496:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00497:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00498:      	AR	= AX
00499:      	P1	= AR
0049A:      	P1.hh	= 0
0049B:      	fcall	pm[P1]
            ; //L5589D4CE_88:;					
            L5589D4CE_88:
            ; //_AE3845712_294:;				
            _AE3845712_294:
            ; //	goto L5589D4CE_90;			
0049C:      	jmp	L5589D4CE_90
            ; //L5589D4CE_85:;					
            L5589D4CE_85:
            ; //	
            ; //_AE3845712_295:;				
            _AE3845712_295:
            ; //	sSI	= (int)&_pkey_1_10;		
0049D:      	AR	= -4
0049E:      	I1	= rm[BP_SAVE]
0049F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004A0:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004A1:      	AR	= AX
004A2:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004A3:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004A4:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_92;	
004A5:      	if NZ	jmp L5589D4CE_92
            ; //	goto	L5589D4CE_91;			
004A6:      	jmp	L5589D4CE_91
            ; //L5589D4CE_92:;					
            L5589D4CE_92:
            ; //_AE3845712_296:;				
            _AE3845712_296:
            ; //_AE3845712_297:;				
            _AE3845712_297:
            ; //	sSI	= (int)&_pkey_1_10;		
004A7:      	AR	= -4
004A8:      	I1	= rm[BP_SAVE]
004A9:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004AA:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004AB:      	AR	= AX
004AC:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004AD:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004AE:      	AR	= AX
004AF:      	P1	= AR
004B0:      	P1.hh	= 0
004B1:      	fcall	pm[P1]
            ; //L5589D4CE_91:;					
            L5589D4CE_91:
            ; //_AE3845712_298:;				
            _AE3845712_298:
            ; //L5589D4CE_90:;					
            L5589D4CE_90:
            ; //_AE3845712_299:;				
            _AE3845712_299:
            ; //	goto L5589D4CE_93;			
004B2:      	jmp	L5589D4CE_93
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //	
            ; //_AE3845712_300:;				
            _AE3845712_300:
            ; //	sAX	= 0;				
004B3:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
004B4:      	AR	= -3
004B5:      	I1	= rm[BP_SAVE]
004B6:      	I1	+= AR
            ; //	asm AR = rm[I1];			
004B7:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
004B8:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_95;		
004B9:      	if ZR	jmp L5589D4CE_95
            ; //	sAX	= 1;				
004BA:      	AX	= 0x01
            ; //L5589D4CE_95:;					
            L5589D4CE_95:
            ; //	sfx_CHECKZERO();			
004BB:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_96;	
004BC:      	if NZ	jmp L5589D4CE_96
            ; //	goto	L5589D4CE_94;			
004BD:      	jmp	L5589D4CE_94
            ; //L5589D4CE_96:;					
            L5589D4CE_96:
            ; //	
            ; //_AE3845712_301:;				
            _AE3845712_301:
            ; //	sSI	= (int)&_pkey_1_10;		
004BE:      	AR	= -4
004BF:      	I1	= rm[BP_SAVE]
004C0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004C1:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004C2:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004C3:      	AR	= CX
004C4:      	AX	+= AR
            ; //	sDI	= sAX;				
004C5:      	AR	= AX
004C6:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004C7:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004C8:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_98;	
004C9:      	if NZ	jmp L5589D4CE_98
            ; //	goto	L5589D4CE_97;			
004CA:      	jmp	L5589D4CE_97
            ; //L5589D4CE_98:;					
            L5589D4CE_98:
            ; //_AE3845712_302:;				
            _AE3845712_302:
            ; //_AE3845712_303:;				
            _AE3845712_303:
            ; //	sSI	= (int)&_pkey_1_10;		
004CB:      	AR	= -4
004CC:      	I1	= rm[BP_SAVE]
004CD:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004CE:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004CF:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004D0:      	AR	= CX
004D1:      	AX	+= AR
            ; //	sDI	= sAX;				
004D2:      	AR	= AX
004D3:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004D4:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004D5:      	AR	= AX
004D6:      	P1	= AR
004D7:      	P1.hh	= 0
004D8:      	fcall	pm[P1]
            ; //L5589D4CE_97:;					
            L5589D4CE_97:
            ; //_AE3845712_304:;				
            _AE3845712_304:
            ; //L5589D4CE_94:;					
            L5589D4CE_94:
            ; //_AE3845712_305:;				
            _AE3845712_305:
            ; //L5589D4CE_93:;					
            L5589D4CE_93:
            ; //_AE3845712_306:;				
            _AE3845712_306:
            ; //_AE3845712_307:;				
            _AE3845712_307:
            ; //	sSI	= (int)&_bits_1_6;		
004D9:      	AR	= -2
004DA:      	I1	= rm[BP_SAVE]
004DB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004DC:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004DD:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
004DE:      	AR	= -2
004DF:      	I1	= rm[BP_SAVE]
004E0:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004E1:      	rm[I1]	= AX
            ; //_AE3845712_308:;				
            _AE3845712_308:
            ; //	sSI	= (int)&_bitp_1_8;		
004E2:      	AR	= -3
004E3:      	I1	= rm[BP_SAVE]
004E4:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004E5:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004E6:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
004E7:      	AR	= -3
004E8:      	I1	= rm[BP_SAVE]
004E9:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004EA:      	rm[I1]	= AX
            ; //_AE3845712_309:;				
            _AE3845712_309:
            ; //	sSI	= (int)&_pkey_1_10;		
004EB:      	AR	= -4
004EC:      	I1	= rm[BP_SAVE]
004ED:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004EE:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
004EF:      	AR	= -4
004F0:      	I1	= rm[BP_SAVE]
004F1:      	I1	+= AR
            ; //	asm AR = 0x0003;			
004F2:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
004F3:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
004F4:      	rm[I1] = CX + AR//
            ; //_AE3845712_310:;				
            _AE3845712_310:
            ; //	goto L5589D4CE_80;			
004F5:      	jmp	L5589D4CE_80
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //_AE3845712_311:;				
            _AE3845712_311:
            ; //	return;					
004F6:      	AR	= 5
004F7:      	BP	+= AR
004F8:      	pop	AR
004F9:      	rm[BP_SAVE]	= AR
004FA:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_AE3845712_312:;				
            _AE3845712_312:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> Start=========================
            ; linkfile.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void ADPCM_CH0_Data();
            ; //naked void ADPCM_CH1_Data();
            ; //naked void ADPCM_CH2_Data();
            ; //naked void ADPCM_CH3_Data();
            ; //naked void ADPCM_CH4_Data();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _adpdata32993E3B[24] = {		
            _adpdata32993E3B:
            ; //	(int)&ADPCM_CH0_Data, (int)&ADPCM_CH0_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH1_Data, (int)&ADPCM_CH1_Data.h|0x0800, 0x3FFF, 0x003F, 
004FB:      DW #ADPCM_CH0_Data,#ADPCM_CH0_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH1_Data,#ADPCM_CH1_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH2_Data, (int)&ADPCM_CH2_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH3_Data, (int)&ADPCM_CH3_Data.h|0x0800, 0x3FFF, 0x003F, 
00503:      DW #ADPCM_CH2_Data,#ADPCM_CH2_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH3_Data,#ADPCM_CH3_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH4_Data, (int)&ADPCM_CH4_Data.h|0x0800, 0x3FFF, 0x003F, 0x0000, 0x0000, 0x0000, 0x0000
0050B:      DW #ADPCM_CH4_Data,#ADPCM_CH4_Data.h|0x0800,0x3FFF,0x003F,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void ADPCM_CH0_Data()			
            ADPCM_CH0_Data:
            ; //{
            ; //	asm	DW "adpcm\Media1_8000_4-12.xam"	
00D3C:      DW "adpcm\Media1_8000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH1_Data()			
            ADPCM_CH1_Data:
            ; //{
            ; //	asm	DW "adpcm\Media1_16000_4-12.xam"
0394C:      DW "adpcm\Media1_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH2_Data()			
            ADPCM_CH2_Data:
            ; //{
            ; //	asm	DW "adpcm\Media2_16000_4-12.xam"
09197:      DW "adpcm\Media2_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH3_Data()			
            ADPCM_CH3_Data:
            ; //{
            ; //	asm	DW "adpcm\Media3_16000_4-12.xam"
13298:      DW "adpcm\Media3_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH4_Data()			
            ADPCM_CH4_Data:
            ; //{
            ; //	asm	DW "adpcm\Media4_16000_4-12.xam"
15530:      DW "adpcm\Media4_16000_4-12.xam"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
00513:      	AR=		BP
00514:      	AR=		AR + 1		; ~~ value
00515:      	I1=		AR
00516:      	AR=		SATV
00517:      	AR=		rm[I1++]
00518:      	SATV=		AR
00519:      	AR=		rm[I1++]
0051A:      	SATV=		AR
0051B:      	AR=		SATV
0051C:      	AX=		AR
0051D:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
0051E:      	AR=		BP
0051F:      	AR=		AR + 1		; ~~ value
00520:      	I1=		AR
00521:      	ADPHD=		rm[I1]
00522:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
00523:      	AR=		ADPHD
00524:      	AX=		AR
00525:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
00526:      	AR=		BP
00527:      	AR=		AR + 1		; ~~ value
00528:      	I1=		AR
00529:      	ADPDAT=		rm[I1]
0052A:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
0052B:      	AR=		ADPDAT
0052C:      	AX=		AR
0052D:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
0052E:      	AR=		ADPPCM
0052F:      	AX=		AR
00530:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
00531:      	AR=		CBL
00532:      	AX=		AR
00533:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
00534:      	AR=		FLTO
00535:      	AX=		AR
00536:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
00537:      	AR=		FLTA
00538:      	AX=		AR
00539:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
0053A:      	AR=		FLTP
0053B:      	AX=		AR
0053C:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
0053D:      	set		io[STATUS].b5
0053E:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
0053F:      	clr		io[STATUS].b5
00540:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
00541:      	set		io[STATUS].b8
00542:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
00543:      	clr		io[STATUS].b8
00544:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
00545:      	set		io[STATUS].b9
00546:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
00547:      	clr		io[STATUS].b9
00548:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
00549:      	set		io[STATUS].b11
0054A:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
0054B:      	clr		io[STATUS].b11
0054C:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
0054D:      	set		io[STATUS].b12
0054E:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
0054F:      	clr		io[STATUS].b12
00550:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
00551:      	set		io[STATUS].b13
00552:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
00553:      	clr		io[STATUS].b13
00554:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
00555:      	AR=		BP
00556:      	AR=		AR + 1		; ~~ value
00557:      	I1=		AR
00558:      	AR=		rm[I1]
00559:      	io[INTENA]=	AR
0055A:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
0055B:      	AR=		io[INTENA]
0055C:      	AX=		AR
0055D:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
0055E:      	AR=		BP
0055F:      	AR=		AR + 1		; ~~ value
00560:      	I1=		AR
00561:      	AR=		rm[I1]
00562:      	io[INTREQ]	=AR
00563:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
00564:      	AR=		io[INTREQ]
00565:      	AX=		AR
00566:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
00567:      	AR=		BP
00568:      	AR=		AR + 1		; ~~ value
00569:      	I1=		AR
0056A:      	AR=		rm[I1]
0056B:      	io[IntVect]	=AR
0056C:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
0056D:      	AR=		io[IntVect]
0056E:      	AX=		AR
0056F:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
00570:      	AR=		io[IOC_PA]
00571:      	AX=		AR
00572:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
00573:      	AR=		io[IOC_PB]
00574:      	AX=		AR
00575:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
00576:      	AR=		io[IOC_PC]
00577:      	AX=		AR
00578:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
00579:      	AR=		io[PortA]
0057A:      	AX=		AR
0057B:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
0057C:      	AR=		io[PortB]
0057D:      	AX=		AR
0057E:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
0057F:      	AR=		io[PortC]
00580:      	AX=		AR
00581:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
00582:      	AR=		BP
00583:      	AR=		AR + 1		; ~~ value
00584:      	I1=		AR
00585:      	AR=		rm[I1]
00586:      	io[SPI_CTL]=	AR
00587:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
00588:      	AR=		io[SPI_CTL]
00589:      	AX=		AR
0058A:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
0058B:      	AR=		BP
0058C:      	AR=		AR + 1		; ~~ value
0058D:      	I1=		AR
0058E:      	AR=		rm[I1]
0058F:      	io[SPI_DAT]=	AR
00590:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
00591:      	AR=		io[SPI_DAT]
00592:      	AX=		AR
00593:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
00594:      	AR=		BP
00595:      	AR=		AR + 1		; ~~ value
00596:      	I1=		AR
00597:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
00598:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
00599:      	AR=		io[MISC]
0059A:      	AX=		AR
0059B:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
0059C:      	AX=		AR
0059D:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
0059E:      	AR=		MACOP
0059F:      	AX=		AR
005A0:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
005A1:      	AR=		BP
005A2:      	AR=		AR + 1
005A3:      	I1=		AR
005A4:      	AR=		rm[I1]
005A5:      	xchg		AR
005A6:      	AX=		AR
005A7:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
005A8:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
005A9:      	AX=		rm[I0]
005AA:      	rets
            
            read_I0P:
005AB:      	AX=		rm[I0++]
005AC:      	rets
            
            read_I0P2:
005AD:      	AX=		rm[I0++2]
005AE:      	rets
            
            read_I0M:
005AF:      	AX=		rm[I0--]
005B0:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
005B1:      	AR=		I0
005B2:      	AX=		AR
005B3:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
005B4:      	AX=		pm[P0]
005B5:      	rets
            
            read_P0P:
005B6:      	AX=		pm[P0++]
005B7:      	rets
            
            read_P0M:
005B8:      	AX=		pm[P0--]
005B9:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
005BA:      	AR=		P0
005BB:      	AX=		AR
005BC:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
005BD:      	AX=		1
005BE:      	if FA jmp	@fa_label_1504
005BF:      	AX=		0
            @fa_label_1504:
005C0:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libc\memset.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_sC3E11DB1:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
005C1:      	AR	= rm[BP_SAVE]
005C2:      	push	AR
005C3:      	AR	= BP
005C4:      	rm[BP_SAVE]	= AR
005C5:      	AR	 = -1
005C6:      	BP	+= AR
            ; //_AE3845712_313:;				
            _AE3845712_313:
            ; //	
            ; //_AE3845712_314:;				
            _AE3845712_314:
            ; //	sSI	= (int)&_s_0_4;			
005C7:      	AR	= 2
005C8:      	I1	= rm[BP_SAVE]
005C9:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
005CA:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
005CB:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
005CC:      	rm[I1]	= AX
            ; //LF2D2B0F3_102:;					
            LF2D2B0F3_102:
            ; //_AE3845712_315:;				
            _AE3845712_315:
            ; //	sSI	= (int)&_n_0_8;			
005CD:      	AR	= 4
005CE:      	I1	= rm[BP_SAVE]
005CF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
005D0:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
005D1:      	AR	= 4
005D2:      	I1	= rm[BP_SAVE]
005D3:      	I1	+= AR
            ; //	asm AR = 0x0001;			
005D4:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
005D5:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
005D6:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
005D7:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_103;	
005D8:      	if NZ	jmp LF2D2B0F3_103
            ; //	goto	LF2D2B0F3_101;			
005D9:      	jmp	LF2D2B0F3_101
            ; //LF2D2B0F3_103:;					
            LF2D2B0F3_103:
            ; //_AE3845712_316:;				
            _AE3845712_316:
            ; //	sSI	= (int)&_ret_1_2;		
005DA:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
005DB:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
005DC:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
005DD:      	AR	= 3
005DE:      	I1	= rm[BP_SAVE]
005DF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
005E0:      	AX	= rm[I1]
            ; //	sSI	= POP();			
005E1:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
005E2:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
005E3:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
005E4:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
005E5:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
005E6:      	rm[I1] = AX + AR//
            ; //_AE3845712_317:;				
            _AE3845712_317:
            ; //	goto LF2D2B0F3_102;			
005E7:      	jmp	LF2D2B0F3_102
            ; //LF2D2B0F3_101:;					
            LF2D2B0F3_101:
            ; //_AE3845712_318:;				
            _AE3845712_318:
            ; //	sSI	= (int)&_s_0_4;			
005E8:      	AR	= 2
005E9:      	I1	= rm[BP_SAVE]
005EA:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
005EB:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_100;			
005EC:      	jmp	LF2D2B0F3_100
            ; //LF2D2B0F3_100:;					
            LF2D2B0F3_100:
            ; //_AE3845712_319:;				
            _AE3845712_319:
            ; //	return;					
005ED:      	AR	= 1
005EE:      	BP	+= AR
005EF:      	pop	AR
005F0:      	rm[BP_SAVE]	= AR
005F1:      	rets
            ; //_memset_sC3E11DB1_end:;				
            _memset_sC3E11DB1_end:
            ; //_AE3845712_320:;				
            _AE3845712_320:
            ; //}
            ; //
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_rC7200006:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
005F2:      	AR	= rm[BP_SAVE]
005F3:      	push	AR
005F4:      	AR	= BP
005F5:      	rm[BP_SAVE]	= AR
005F6:      	AR	 = -1
005F7:      	BP	+= AR
            ; //_AE3845712_321:;				
            _AE3845712_321:
            ; //	
            ; //_AE3845712_322:;				
            _AE3845712_322:
            ; //	sSI	= (int)&_s_0_4;			
005F8:      	AR	= 2
005F9:      	I1	= rm[BP_SAVE]
005FA:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
005FB:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
005FC:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
005FD:      	rm[I1]	= AX
            ; //LF2D2B0F3_106:;					
            LF2D2B0F3_106:
            ; //_AE3845712_323:;				
            _AE3845712_323:
            ; //	sSI	= (int)&_n_0_8;			
005FE:      	AR	= 4
005FF:      	I1	= rm[BP_SAVE]
00600:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00601:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00602:      	AR	= 4
00603:      	I1	= rm[BP_SAVE]
00604:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00605:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00606:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00607:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00608:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_107;	
00609:      	if NZ	jmp LF2D2B0F3_107
            ; //	goto	LF2D2B0F3_105;			
0060A:      	jmp	LF2D2B0F3_105
            ; //LF2D2B0F3_107:;					
            LF2D2B0F3_107:
            ; //_AE3845712_324:;				
            _AE3845712_324:
            ; //	sSI	= (int)&_ret_1_2;		
0060B:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0060C:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0060D:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
0060E:      	AR	= 3
0060F:      	I1	= rm[BP_SAVE]
00610:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00611:      	AX	= rm[I1]
            ; //	sSI	= POP();			
00612:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00613:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00614:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00615:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
00616:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
00617:      	rm[I1] = AX + AR//
            ; //_AE3845712_325:;				
            _AE3845712_325:
            ; //	goto LF2D2B0F3_106;			
00618:      	jmp	LF2D2B0F3_106
            ; //LF2D2B0F3_105:;					
            LF2D2B0F3_105:
            ; //_AE3845712_326:;				
            _AE3845712_326:
            ; //	sSI	= (int)&_s_0_4;			
00619:      	AR	= 2
0061A:      	I1	= rm[BP_SAVE]
0061B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0061C:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_104;			
0061D:      	jmp	LF2D2B0F3_104
            ; //LF2D2B0F3_104:;					
            LF2D2B0F3_104:
            ; //_AE3845712_327:;				
            _AE3845712_327:
            ; //	return;					
0061E:      	AR	= 1
0061F:      	BP	+= AR
00620:      	pop	AR
00621:      	rm[BP_SAVE]	= AR
00622:      	rets
            ; //_memset_rC7200006_end:;				
            _memset_rC7200006_end:
            ; //_AE3845712_328:;				
            _AE3845712_328:
            ; //}
            ; //
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10)
            _memset5A9D755A:
            ; //{						
00623:      	AR	= rm[BP_SAVE]
00624:      	push	AR
00625:      	AR	= BP
00626:      	rm[BP_SAVE]	= AR
            ; //_AE3845712_329:;				
            _AE3845712_329:
            ; //	
            ; //_AE3845712_330:;				
            _AE3845712_330:
            ; //	sAX	= (int)&_s_0_4_0;		
00627:      	AR	= 2
00628:      	AX	= rm[BP_SAVE]
00629:      	AX	+= AR
            ; //	sCX	= 0x0001;			
0062A:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
0062B:      	AR	= CX
0062C:      	AX	+= AR
            ; //	sSI	= sAX;				
0062D:      	AR	= AX
0062E:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0062F:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00630:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_110;	
00631:      	if NZ	jmp LF2D2B0F3_110
            ; //	goto	LF2D2B0F3_109;			
00632:      	jmp	LF2D2B0F3_109
            ; //LF2D2B0F3_110:;					
            LF2D2B0F3_110:
            ; //_AE3845712_331:;				
            _AE3845712_331:
            ; //_AE3845712_332:;				
            _AE3845712_332:
            ; //	sSI	= (int)&_n_0_10;		
00633:      	AR	= 5
00634:      	I1	= rm[BP_SAVE]
00635:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00636:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00637:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
00638:      	AR	= 4
00639:      	I1	= rm[BP_SAVE]
0063A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0063B:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0063C:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
0063D:      	AR	= 2
0063E:      	AX	= rm[BP_SAVE]
0063F:      	AX	+= AR
            ; //	sSI	= sAX;				
00640:      	AR	= AX
00641:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
00642:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00643:      	push	AX
            ; //	_memset_rC7200006(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
00644:      	call	_memset_rC7200006
            ; //	RESTORESP(3);				
00645:      	AR	= 3
00646:      	BP	+= AR
            ; //	sDX	= 0x0800;			
00647:      	DX	= 0x0800
            ; //	goto LF2D2B0F3_108;			
00649:      	jmp	LF2D2B0F3_108
            ; //LF2D2B0F3_109:;					
            LF2D2B0F3_109:
            ; //_AE3845712_333:;				
            _AE3845712_333:
            ; //_AE3845712_334:;				
            _AE3845712_334:
            ; //_AE3845712_335:;				
            _AE3845712_335:
            ; //	sSI	= (int)&_n_0_10;		
0064A:      	AR	= 5
0064B:      	I1	= rm[BP_SAVE]
0064C:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0064D:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0064E:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
0064F:      	AR	= 4
00650:      	I1	= rm[BP_SAVE]
00651:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00652:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00653:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
00654:      	AR	= 2
00655:      	AX	= rm[BP_SAVE]
00656:      	AX	+= AR
            ; //	sSI	= sAX;				
00657:      	AR	= AX
00658:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
00659:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0065A:      	push	AX
            ; //	_memset_sC3E11DB1(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
0065B:      	call	_memset_sC3E11DB1
            ; //	RESTORESP(3);				
0065C:      	AR	= 3
0065D:      	BP	+= AR
            ; //	sDX	= 0;				
0065E:      	DX	= 0x00
            ; //	goto LF2D2B0F3_108;			
0065F:      	jmp	LF2D2B0F3_108
            ; //LF2D2B0F3_108:;					
            LF2D2B0F3_108:
            ; //_AE3845712_336:;				
            _AE3845712_336:
            ; //	return;					
00660:      	pop	AR
00661:      	rm[BP_SAVE]	= AR
00662:      	rets
            ; //_memset5A9D755A_end:;				
            _memset5A9D755A_end:
            ; //_AE3845712_337:;				
            _AE3845712_337:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libadpcm\adp12.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> Start=========================
            
            
            
            
            
            _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E:
            ; {
00663:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
00664:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder	; Z fail
00665:              AX=		1
00666:              if NZ jmp	L9E1082DD_0
00667:              AX=		0
            L9E1082DD_0:
00668:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\XDSP_ADPCM_4BIT_DECV04.OBJ"
            ;
            
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> Start=========================
            ; 3D044B19_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	return;					
0099E:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
0099F:      	P1.hh=		0
009A0:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
009A1:      	AR=		pm[P1++]
009A2:      	rm[I1++]=	AR
            @glinit_label_1409:
009A3:      	loop		@glinit_loop_1409
009A4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
009A5:      	AR=		AX
009A6:      	MX=		AR
009A7:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
009A8:      	MACOP=		3
009A9:      	MR=		MX * AR
            #endif
            
009AA:      	AR=		MR0
009AB:      	AX=		AR
009AC:      	AR=		MR1
009AD:      	DX=		AR
009AE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
009AF:      	AR=		AX
009B0:      	MX=		AR
009B1:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
009B2:      	MACOP=		0
009B3:      	MR=		MX * AR
            #endif
            
009B4:      	AR=		MR0
009B5:      	AX=		AR
009B6:      	AR=		MR1
009B7:      	DX=		AR
009B8:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
009B9:      	AR=		rm[BP_SAVE]
009BA:      	push		AR
009BB:      	AR=		BP
009BC:      	rm[BP_SAVE]=	AR
009BD:      	AR=		AR - 3
009BE:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
009BF:      	AR=		CX
009C0:      	MX=		AR
009C1:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
009C2:      	MACOP=		3		; unsigned
009C3:      	MR=		MX * AR
            #endif
            
009C4:      	I1=		rm[BP_SAVE]
009C5:      	AR=		2
009C6:      	I1=		I1 - AR
009C7:      	rm[I1++]=	MR0
009C8:      	rm[I1++]=	MR1
009C9:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
009CA:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
009CB:      	MACOP=		1		; mx:unsigned / my:signed
009CC:      	MR=		MX * AR
            #endif
            
009CD:      	AR=		rm[I1]
009CE:      	AR=		AR + MR0
009CF:      	rm[I1++]=	AR
009D0:      	AR=		rm[I1]
009D1:      	AR=		AR + MR1 + C
009D2:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
009D3:      	AR=		BX
009D4:      	MX=		AR
009D5:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
009D6:      	MACOP=		2		; mx:signed / my:unsigned
009D7:      	MR=		MX * AR
            #endif
            
009D8:      	AR=		rm[I1]
009D9:      	AR=		AR + MR0
009DA:      	rm[I1++]=	AR
009DB:      	AR=		rm[I1]
009DC:      	AR=		AR + MR1 + C
009DD:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
009DE:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
009DF:      	MACOP=		0		; mx:signed / my:signed
009E0:      	MR=		MX * AR
            #endif
            
009E1:      	AR=		rm[I1]
009E2:      	AR=		AR + MR0
009E3:      	rm[I1]=		AR
            
009E4:      	I1=		rm[BP_SAVE]
009E5:      	CX=		rm[I1--]
009E6:      	DX=		rm[I1--]
009E7:      	AX=		rm[I1]
            
009E8:      	AR=		3
009E9:      	BP=		BP + AR
009EA:      	pop		AR
009EB:      	rm[BP_SAVE]=	AR
            
009EC:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
009ED:      	AR=		rm[BP_SAVE]
009EE:      	push		AR
009EF:      	AR=		BP
009F0:      	rm[BP_SAVE]=	AR
009F1:      	AR=		AR - 3
009F2:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
009F3:      	AR=		CX
009F4:      	MX=		AR
009F5:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
009F6:      	MACOP=		3		; unsigned
009F7:      	MR=		MX * AR
            #endif
            
009F8:      	I1=		rm[BP_SAVE]
009F9:      	AR=		2
009FA:      	I1=		I1 - AR
009FB:      	rm[I1++]=	MR0
009FC:      	rm[I1++]=	MR1
009FD:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
009FE:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
009FF:      	MR=		MX * AR
            #endif
            
00A00:      	AR=		rm[I1]
00A01:      	AR=		AR + MR0
00A02:      	rm[I1++]=	AR
00A03:      	AR=		rm[I1]
00A04:      	AR=		AR + MR1 + C
00A05:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00A06:      	AR=		BX
00A07:      	MX=		AR
00A08:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A09:      	MR=		MX * AR
            #endif
            
00A0A:      	AR=		rm[I1]
00A0B:      	AR=		AR + MR0
00A0C:      	rm[I1++]=	AR
00A0D:      	AR=		rm[I1]
00A0E:      	AR=		AR + MR1 + C
00A0F:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00A10:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A11:      	MR=		MX * AR
            #endif
            
00A12:      	AR=		rm[I1]
00A13:      	AR=		AR + MR0
00A14:      	rm[I1]=		AR
            
00A15:      	I1=		rm[BP_SAVE]
00A16:      	CX=		rm[I1--]
00A17:      	DX=		rm[I1--]
00A18:      	AX=		rm[I1]
            
00A19:      	AR=		3
00A1A:      	BP=		BP + AR
00A1B:      	pop		AR
00A1C:      	rm[BP_SAVE]=	AR
            
00A1D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
00A1E:      		DX=		0
            	; unsigned char count = 16;
00A1F:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00A20:      			slz		AX, 1
            		; reste <<= 1;
00A21:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00A22:      			AR=		DX
00A23:      			AR-=		CX
00A24:      			AR=		0
00A25:      			AR=		AR - 0 + C - 1
00A26:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
00A27:      				AR=		CX
00A28:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00A29:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
00A2A:      		R0--
00A2B:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
00A2C:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
00A2D:      		R1=		0
00A2E:      		AR=		0
00A2F:      		test		AX.b15
00A30:      		if ZR jmp	@divsword_label_1833
00A31:      			AX=		AR - AX
00A32:      			set		R1.b0
            		@divsword_label_1833:
00A33:      		test		CX.b15
00A34:      		if ZR jmp	@divsword_label_1834
00A35:      			CX=		AR - CX
00A36:      			set		R1.b1
            		@divsword_label_1834:
00A37:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
00A38:      		AR=		R1
00A39:      		slz		AR, 1
00A3A:      		AR^=		R1
00A3B:      		test		AR.b1
00A3C:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
00A3D:      			AR=		0
00A3E:      			AX=		AR - AX
00A3F:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
00A40:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
00A41:      		R0=		0	; L
00A42:      		R1=		0	; H
            	; unsigned char count = 32;
00A43:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00A44:      			slz		AX, 1
00A45:      			slc		DX, 1
            		; reste <<= 1;
00A46:      			slc		R0, 1
00A47:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
00A48:      			AR=		R0
00A49:      			AR-=		CX
00A4A:      			AR=		R1
00A4B:      			AR=		AR - BX + C - 1
00A4C:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
00A4D:      				AR=		CX
00A4E:      				R0=		R0 - AR
00A4F:      				AR=		BX
00A50:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
00A51:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
00A52:      		R2--
00A53:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
00A54:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
00A55:      		R3=		0
00A56:      		AR=		0
00A57:      		test		DX.b15
00A58:      		if ZR jmp	@divslong_label_1759
00A59:      			AX=		AR - AX
00A5A:      			DX=		AR - DX + C - 1
00A5B:      			set		R3.b0
            		@divslong_label_1759:
00A5C:      		test		BX.b15
00A5D:      		if ZR jmp	@divslong_label_1800
00A5E:      			CX=		AR - CX
00A5F:      			BX=		AR - BX + C - 1
00A60:      			set		R3.b1
            		@divslong_label_1800:
00A61:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
00A62:      		AR=		R3
00A63:      		slz		AR, 1
00A64:      		AR^=		R3
00A65:      		test		AR.b1
00A66:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
00A67:      			AR=		0
00A68:      			AX=		AR - AX
00A69:      			DX=		AR - DX + C - 1
00A6A:      			R0=		AR - R0
00A6B:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
00A6C:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
00A6D:      	call		sfx_DIV_AX_CX
00A6E:      	AR=		DX
00A6F:      	AX=		AR
00A70:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
00A71:      	call		sfx_IDIV_AX_CX
00A72:      	AR=		DX
00A73:      	AX=		AR
00A74:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
00A75:      	call		sfx_DIVLONG
00A76:      	AR=		R0
00A77:      	AX=		AR
00A78:      	AR=		R1
00A79:      	DX=		AR
00A7A:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
00A7B:      	call		sfx_IDIVLONG
00A7C:      	AR=		R0
00A7D:      	AX=		AR
00A7E:      	AR=		R1
00A7F:      	DX=		AR
00A80:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
00A81:      	AR=		AX
00A82:      	P1=		P1 + AR
00A83:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
00A84:      	AR=		AX
00A85:      	I1=		I1 + AR
00A86:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
00A87:      	AR=		CX
00A88:      	AX=		AX + AR
00A89:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
00A8A:      	AR=		AX
00A8B:      	P1=		P1 - AR
00A8C:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
00A8D:      	AR=		AX
00A8E:      	I1=		I1 - AR
00A8F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
00A90:      	AR=		CX
00A91:      	AX=		AX + AR
00A92:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
00A93:      	pm[P1++]=	AX
00A94:      	pm[P1--]=	DX
00A95:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
00A96:      	pm[P1++]=	CX
00A97:      	pm[P1--]=	BX
00A98:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
00A99:      	BX=		0
00A9A:      	CX.h=		0
00A9B:      	test		CX.b7
00A9C:      	if ZR jmp	@c2lcx_label_1800
00A9D:      	CX.h=		0xFF
00A9E:      	BX=		-1
            @c2lcx_label_1800:
00A9F:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
00AA0:      	DX=		0
00AA1:      	AX.h=		0
00AA2:      	test		AX.b7
00AA3:      	if ZR jmp	@c2lax_label_1800
00AA4:      	AX.h=		0xFF
00AA5:      	DX=		-1
            @c2lax_label_1800:
00AA6:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
00AA7:      	push		AX
00AA8:      	push		CX
00AA9:      	pop		AX
00AAA:      	pop		CX
00AAB:      	push		DX
00AAC:      	push		BX
00AAD:      	pop		DX
00AAE:      	pop		BX
00AAF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
00AB0:      	AR=		DX
00AB1:      	DX=		0
00AB2:      	AR=		AR | AX
00AB3:      	AX=		1
00AB4:      	if ZR jmp	@longnotl_label_1120
00AB5:      	AX=		0
            @longnotl_label_1120:
00AB6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
00AB7:      	DX=		0
00AB8:      	BX=		0
            sfx_CMPLONG_JNE:
00AB9:      	AR=		CX
00ABA:      	AX=		AX - AR
00ABB:      	AR=		BX
00ABC:      	AR=		DX - AR + C - 1
00ABD:      	AR=		AR | AX
00ABE:      	if EQ jmp	@sfx_cl_jne_f
00ABF:      	set		Z		; true
00AC0:      	rets
            @sfx_cl_jne_f:
00AC1:      	clr		Z		; false
00AC2:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
00AC3:      	DX=		0
00AC4:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
00AC5:      	AR=		AX
00AC6:      	CX=		CX - AR
00AC7:      	AR=		DX
00AC8:      	AR=		BX - AR + C - 1
00AC9:      	AR=		AR | CX
00ACA:      	if EQ jmp	@sfx_clbcda_jne_f
00ACB:      	set		Z		; true
00ACC:      	rets
            @sfx_clbcda_jne_f:
00ACD:      	clr		Z		; false
00ACE:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
00ACF:      	AR=		CX
00AD0:      	SF=		AX - AR
00AD1:      	if EQ jmp	@sfx_ac_jne_f
00AD2:      	set		Z
00AD3:      	rets
            @sfx_ac_jne_f:
00AD4:      	clr		Z
00AD5:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
00AD6:      	AR=		AX
00AD7:      	SF=		CX - AR
00AD8:      	if EQ jmp	@sfx_ca_jne_f
00AD9:      	set		Z
00ADA:      	rets
            @sfx_ca_jne_f:
00ADB:      	clr		Z
00ADC:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
00ADD:      	DX=		0
00ADE:      	BX=		0
            sfx_CMPLONG_JE:
00ADF:      	AR=		CX
00AE0:      	AX=		AX - AR
00AE1:      	AR=		BX
00AE2:      	AR=		DX - AR + C - 1
00AE3:      	AR=		AR | AX
00AE4:      	if NE jmp	@sfx_cl_jz_f
00AE5:      	set		Z		; true
00AE6:      	rets
            @sfx_cl_jz_f:
00AE7:      	clr		Z		; false
00AE8:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00AE9:      	DX=		0
00AEA:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
00AEB:      	AR=		AX
00AEC:      	CX=		CX - AR
00AED:      	AR=		DX
00AEE:      	AR=		BX - AR + C - 1
00AEF:      	AR=		AR | CX
00AF0:      	if NE jmp	@sfx_clbcda_jz_f
00AF1:      	set		Z		; true
00AF2:      	rets
            @sfx_clbcda_jz_f:
00AF3:      	clr		Z		; false
00AF4:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
00AF5:      	DX=		0
00AF6:      	BX=		0
            sfx_CMPLONG_JG:
00AF7:      	AR=		CX
00AF8:      	AX=		AX - AR
00AF9:      	AR=		BX
00AFA:      	AR=		DX - AR + C - 1
00AFB:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
00AFC:      	AR=		AR | AX
00AFD:      	if ZR jmp	@sfx_cl_jg_f
            
00AFE:      	set		Z		; true
00AFF:      	rets
            @sfx_cl_jg_f:
00B00:      	clr		Z		; false
00B01:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
00B02:      	AR=		CX
00B03:      	AX=		AX - AR
00B04:      	AR=		BX
00B05:      	DX=		DX - AR + C - 1
00B06:      	AR=		0
00B07:      	AR=		AR - 0 + C - 1
00B08:      	if AN jmp	@sfx_cl_jg_f
            
00B09:      	AR=		AR | DX		; exclude EQU condition
00B0A:      	AR=		AR | AX
00B0B:      	if ZR jmp	@sfx_cl_jg_f
            
00B0C:      	set		Z		; true
00B0D:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
00B0E:      	DX=		0
00B0F:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
00B10:      	AR=		AX
00B11:      	CX=		CX - AR
00B12:      	AR=		DX
00B13:      	AR=		BX - AR + C - 1
00B14:      	if AN jmp	@sfx_clbcda_jg_f
            
00B15:      	AR=		AR | CX		; exclude EQU condition
00B16:      	if ZR jmp	@sfx_clbcda_jg_f
            
00B17:      	set		Z		; true
00B18:      	rets
            @sfx_clbcda_jg_f:
00B19:      	clr		Z		; false
00B1A:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00B1B:      	AR=		AX
00B1C:      	CX=		CX - AR
00B1D:      	AR=		DX
00B1E:      	BX=		BX - AR + C - 1
00B1F:      	AR=		0
00B20:      	AR=		AR - 0 + C - 1
00B21:      	if AN jmp	@sfx_clbcda_jg_f
            
00B22:      	AR=		AR | BX		; exclude EQU condition
00B23:      	AR=		AR | CX
00B24:      	if ZR jmp	@sfx_clbcda_jg_f
            
00B25:      	set		Z		; true
00B26:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
00B27:      	AR=		CX
00B28:      	SF=		AX - AR
00B29:      	if LE jmp	@sfx_cmp_ac_jg_f
00B2A:      	set		Z
00B2B:      	rets
            @sfx_cmp_ac_jg_f:
00B2C:      	clr		Z
00B2D:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
00B2E:      	AR=		AX
00B2F:      	SF=		CX - AR
00B30:      	if LE jmp	@sfx_cmp_ca_jg_f
00B31:      	set		Z
00B32:      	rets
            @sfx_cmp_ca_jg_f:
00B33:      	clr		Z
00B34:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
00B35:      	DX=		0
00B36:      	BX=		0
            sfx_CMPLONG_JGE:
00B37:      	AR=		CX
00B38:      	AX=		AX - AR
00B39:      	AR=		BX
00B3A:      	DX=		DX - AR + C - 1
00B3B:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
00B3C:      	set		Z		; true
00B3D:      	rets
            @sfx_cl_jge_f:
00B3E:      	clr		Z		; false
00B3F:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
00B40:      	AR=		CX
00B41:      	AX=		AX - AR
00B42:      	AR=		BX
00B43:      	DX=		DX - AR + C - 1
00B44:      	AR=		0
00B45:      	AR=		AR - 0 + C - 1
00B46:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
00B47:      	set		Z		; true
00B48:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
00B49:      	DX=		0
00B4A:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
00B4B:      	AR=		AX
00B4C:      	CX=		CX - AR
00B4D:      	AR=		DX
00B4E:      	BX=		BX - AR + C - 1
00B4F:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
00B50:      	set		Z		; true
00B51:      	rets
            @sfx_clbcda_jge_f:
00B52:      	clr		Z		; false
00B53:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
00B54:      	AR=		AX
00B55:      	CX=		CX - AR
00B56:      	AR=		DX
00B57:      	BX=		BX - AR + C - 1
00B58:      	AR=		0
00B59:      	AR=		AR - 0 + C - 1
00B5A:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
00B5B:      	set		Z		; true
00B5C:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
00B5D:      	AR=		CX
00B5E:      	SF=		AX - AR
00B5F:      	if AN jmp	@sfx_cmp_ac_jge_f
00B60:      	set		Z
00B61:      	rets
            @sfx_cmp_ac_jge_f:
00B62:      	clr		Z
00B63:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
00B64:      	AR=		AX
00B65:      	SF=		CX - AR
00B66:      	if AN jmp	@sfx_cmp_ca_jge_f
00B67:      	set		Z
00B68:      	rets
            @sfx_cmp_ca_jge_f:
00B69:      	clr		Z
00B6A:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
00B6B:      	DX=		0
00B6C:      	BX=		0
            sfx_CMPLONG_JL:
00B6D:      	AR=		CX
00B6E:      	AX=		AX - AR
00B6F:      	AR=		BX
00B70:      	AR=		DX - AR + C - 1
00B71:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
00B72:      	clr		Z		; false
00B73:      	rets
            
            @sfx_cl_jl_chk:
00B74:      	AR=		AR | AX		; exclude EQU condition
00B75:      	if ZR jmp	@sfx_cl_jl_f
00B76:      	set		Z
00B77:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
00B78:      	AR=		CX
00B79:      	AX=		AX - AR
00B7A:      	AR=		BX
00B7B:      	DX=		DX - AR + C - 1
00B7C:      	AR=		0
00B7D:      	AR=		AR - 0 + C - 1
00B7E:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
00B7F:      	clr		Z		; false
00B80:      	rets
            
            @sfx_cl_jb_chk:
00B81:      	AR=		AR | DX
00B82:      	AR=		AR | AX		; exclude EQU condition
00B83:      	if ZR jmp	@sfx_cl_jb_f
00B84:      	set		Z
00B85:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
00B86:      	DX=		0
00B87:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
00B88:      	AR=		AX
00B89:      	CX=		CX - AR
00B8A:      	AR=		DX
00B8B:      	AR=		BX - AR + C - 1
00B8C:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
00B8D:      	clr		Z		; false
00B8E:      	rets
            
            @sfx_clbcda_jl_chk:
00B8F:      	AR=		AR | CX		; exclude EQU condition
00B90:      	if ZR jmp	@sfx_clbcda_jl_f
00B91:      	set		Z		; true
00B92:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
00B93:      	AR=		AX
00B94:      	CX=		CX - AR
00B95:      	AR=		DX
00B96:      	BX=		BX - AR + C - 1
00B97:      	AR=		0
00B98:      	AR=		AR - 0 + C - 1
00B99:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
00B9A:      	clr		Z		; false
00B9B:      	rets
            
            @sfx_clbcda_jb_chk:
00B9C:      	AR=		AR | CX
00B9D:      	AR=		AR | BX
00B9E:      	if ZR jmp	@sfx_clbcda_jb_f
00B9F:      	set		Z		; true
00BA0:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
00BA1:      	AR=		CX
00BA2:      	SF=		AX - AR
00BA3:      	if GE jmp	@sfx_cmp_ac_jl_f
00BA4:      	set		Z
00BA5:      	rets
            @sfx_cmp_ac_jl_f:
00BA6:      	clr		Z
00BA7:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
00BA8:      	AR=		AX
00BA9:      	SF=		CX - AR
00BAA:      	if GE jmp	@sfx_cmp_ca_jl_f
00BAB:      	set		Z
00BAC:      	rets
            @sfx_cmp_ca_jl_f:
00BAD:      	clr		Z
00BAE:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
00BAF:      	DX=		0
00BB0:      	BX=		0
            sfx_CMPLONG_JLE:
00BB1:      	AR=		CX
00BB2:      	AX=		AX - AR
00BB3:      	AR=		BX
00BB4:      	AR=		DX - AR + C - 1
00BB5:      	if AN jmp	@sfx_cl_jle_t
            
00BB6:      	AR=		AR | AX		; include EQU condition
00BB7:      	if ZR jmp	@sfx_cl_jle_t
            
00BB8:      	clr		Z		; false
00BB9:      	rets
            @sfx_cl_jle_t:
00BBA:      	set		Z		; true
00BBB:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
00BBC:      	AR=		CX
00BBD:      	AX=		AX - AR
00BBE:      	AR=		BX
00BBF:      	DX=		DX - AR + C - 1
00BC0:      	AR=		0
00BC1:      	AR=		AR - 0 + C - 1
00BC2:      	if AN jmp	@sfx_cl_jle_t
            
00BC3:      	AR=		AR | DX
00BC4:      	AR=		AR | AX
00BC5:      	if ZR jmp	@sfx_cl_jle_t
            
00BC6:      	clr		Z		; false
00BC7:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
00BC8:      	DX=		0
00BC9:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00BCA:      	AR=		AX
00BCB:      	CX=		CX - AR
00BCC:      	AR=		DX
00BCD:      	AR=		BX - AR + C - 1
00BCE:      	if AN jmp	@sfx_clbcda_jle_t
            
00BCF:      	AR=		AR | CX		; include EQU condition
00BD0:      	if ZR jmp	@sfx_clbcda_jle_t
            
00BD1:      	clr		Z		; false
00BD2:      	rets
            @sfx_clbcda_jle_t:
00BD3:      	set		Z		; true
00BD4:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
00BD5:      	AR=		AX
00BD6:      	CX=		CX - AR
00BD7:      	AR=		DX
00BD8:      	BX=		BX - AR + C - 1
00BD9:      	AR=		0
00BDA:      	AR=		AR - 0 + C - 1
00BDB:      	if AN jmp	@sfx_clbcda_jle_t
            
00BDC:      	AR=		AR | BX
00BDD:      	AR=		AR | CX
00BDE:      	if ZR jmp	@sfx_clbcda_jle_t
            
00BDF:      	clr		Z		; false
00BE0:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
00BE1:      	AR=		CX
00BE2:      	SF=		AX - AR
00BE3:      	if LE jmp	@sfx_cmp_ac_jl_t
00BE4:      	clr		Z
00BE5:      	rets
            @sfx_cmp_ac_jl_t:
00BE6:      	set		Z
00BE7:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
00BE8:      	AR=		AX
00BE9:      	SF=		CX - AR
00BEA:      	if LE jmp	@sfx_cmp_ca_jl_t
00BEB:      	clr		Z
00BEC:      	rets
            @sfx_cmp_ca_jl_t:
00BED:      	set		Z
00BEE:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
00BEF:      	DW 0xFFFE
            @sfx_ortable_1:
00BF0:      	DW 0xFFFC
            @sfx_ortable_2:
00BF1:      	DW 0xFFF8
            @sfx_ortable_3:
00BF2:      	DW 0xFFF0
            @sfx_ortable_4:
00BF3:      	DW 0xFFE0
            @sfx_ortable_5:
00BF4:      	DW 0xFFC0
            @sfx_ortable_6:
00BF5:      	DW 0xFF80
            @sfx_ortable_7:
00BF6:      	DW 0xFF00
            @sfx_ortable_8:
00BF7:      	DW 0xFE00
            @sfx_ortable_9:
00BF8:      	DW 0xFC00
            @sfx_ortable_10:
00BF9:      	DW 0xF800
            @sfx_ortable_11:
00BFA:      	DW 0xF000
            @sfx_ortable_12:
00BFB:      	DW 0xE000
            @sfx_ortable_13:
00BFC:      	DW 0xC000
            @sfx_ortable_14:
00BFD:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
00BFE:      	AR=		pm[P1]
00BFF:      	DX=		DX | AR
00C00:      	rets
            
            @sfx_orhigh_dx:
00C01:      	DX=		-1
            @sfx_orlow:
00C02:      	AR=		pm[P1]
00C03:      	AX=		AX | AR
            @sfx_sextw_rets:
00C04:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
00C05:      	P1=		#@sfx_ortable_0
00C08:      	test		AX.b0
00C09:      	if ZR jmp	@sfx_sextw_rets
00C0A:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00C0B:      	P1=		#@sfx_ortable_1
00C0E:      	test		AX.b1
00C0F:      	if ZR jmp	@sfx_sextw_rets
00C10:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
00C11:      	P1=		#@sfx_ortable_2
00C14:      	test		AX.b2
00C15:      	if ZR jmp	@sfx_sextw_rets
00C16:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
00C17:      	P1=		#@sfx_ortable_3
00C1A:      	test		AX.b3
00C1B:      	if ZR jmp	@sfx_sextw_rets
00C1C:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
00C1D:      	P1=		#@sfx_ortable_4
00C20:      	test		AX.b4
00C21:      	if ZR jmp	@sfx_sextw_rets
00C22:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
00C23:      	P1=		#@sfx_ortable_5
00C26:      	test		AX.b5
00C27:      	if ZR jmp	@sfx_sextw_rets
00C28:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00C29:      	P1=		#@sfx_ortable_6
00C2C:      	test		AX.b6
00C2D:      	if ZR jmp	@sfx_sextw_rets
00C2E:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
00C2F:      	P1=		#@sfx_ortable_7
00C32:      	test		AX.b7
00C33:      	if ZR jmp	@sfx_sextw_rets
00C34:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
00C35:      	P1=		#@sfx_ortable_8
00C38:      	test		AX.b8
00C39:      	if ZR jmp	@sfx_sextw_rets
00C3A:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
00C3B:      	P1=		#@sfx_ortable_9
00C3E:      	test		AX.b9
00C3F:      	if ZR jmp	@sfx_sextw_rets
00C40:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
00C41:      	P1=		#@sfx_ortable_10
00C44:      	test		AX.b10
00C45:      	if ZR jmp	@sfx_sextw_rets
00C46:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
00C47:      	P1=		#@sfx_ortable_11
00C4A:      	test		AX.b11
00C4B:      	if ZR jmp	@sfx_sextw_rets
00C4C:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
00C4D:      	P1=		#@sfx_ortable_12
00C50:      	test		AX.b12
00C51:      	if ZR jmp	@sfx_sextw_rets
00C52:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
00C53:      	P1=		#@sfx_ortable_13
00C56:      	test		AX.b13
00C57:      	if ZR jmp	@sfx_sextw_rets
00C58:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
00C59:      	P1=		#@sfx_ortable_14
00C5C:      	test		AX.b14
00C5D:      	if ZR jmp	@sfx_sextw_rets
00C5E:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
00C5F:      	P1=		#@sfx_ortable_0
00C62:      	test		AX.b0
00C63:      	if ZR jmp	@sfx_sextw_rets
00C64:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
00C65:      	P1=		#@sfx_ortable_1
00C68:      	test		AX.b1
00C69:      	if ZR jmp	@sfx_sextw_rets
00C6A:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
00C6B:      	P1=		#@sfx_ortable_2
00C6E:      	test		AX.b2
00C6F:      	if ZR jmp	@sfx_sextw_rets
00C70:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
00C71:      	P1=		#@sfx_ortable_3
00C74:      	test		AX.b3
00C75:      	if ZR jmp	@sfx_sextw_rets
00C76:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
00C77:      	P1=		#@sfx_ortable_4
00C7A:      	test		AX.b4
00C7B:      	if ZR jmp	@sfx_sextw_rets
00C7C:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
00C7D:      	P1=		#@sfx_ortable_5
00C80:      	test		AX.b5
00C81:      	if ZR jmp	@sfx_sextw_rets
00C82:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
00C83:      	P1=		#@sfx_ortable_6
00C86:      	test		AX.b6
00C87:      	if ZR jmp	@sfx_sextw_rets
00C88:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
00C89:      	P1=		#@sfx_ortable_7
00C8C:      	test		AX.b7
00C8D:      	if ZR jmp	@sfx_sextw_rets
00C8E:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
00C8F:      	P1=		#@sfx_ortable_8
00C92:      	test		AX.b8
00C93:      	if ZR jmp	@sfx_sextw_rets
00C94:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
00C95:      	P1=		#@sfx_ortable_9
00C98:      	test		AX.b9
00C99:      	if ZR jmp	@sfx_sextw_rets
00C9A:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
00C9B:      	P1=		#@sfx_ortable_10
00C9E:      	test		AX.b10
00C9F:      	if ZR jmp	@sfx_sextw_rets
00CA0:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
00CA1:      	P1=		#@sfx_ortable_11
00CA4:      	test		AX.b11
00CA5:      	if ZR jmp	@sfx_sextw_rets
00CA6:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
00CA7:      	P1=		#@sfx_ortable_12
00CAA:      	test		AX.b12
00CAB:      	if ZR jmp	@sfx_sextw_rets
00CAC:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
00CAD:      	P1=		#@sfx_ortable_13
00CB0:      	test		AX.b13
00CB1:      	if ZR jmp	@sfx_sextw_rets
00CB2:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
00CB3:      	P1=		#@sfx_ortable_14
00CB6:      	test		AX.b14
00CB7:      	if ZR jmp	@sfx_sextw_rets
00CB8:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
00CB9:      	test		AX.b15
00CBA:      	if ZR jmp	@sfx_sextw_rets
00CBB:      	DX=		-1
00CBC:      	rets
            
            sfx_SignExtL16:
00CBD:      	P1=		#@sfx_ortable_0
00CC0:      	test		DX.b0
00CC1:      	if ZR jmp	@sfx_sextw_rets
00CC2:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
00CC3:      	P1=		#@sfx_ortable_1
00CC6:      	test		DX.b1
00CC7:      	if ZR jmp	@sfx_sextw_rets
00CC8:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00CC9:      	P1=		#@sfx_ortable_2
00CCC:      	test		DX.b2
00CCD:      	if ZR jmp	@sfx_sextw_rets
00CCE:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
00CCF:      	P1=		#@sfx_ortable_3
00CD2:      	test		DX.b3
00CD3:      	if ZR jmp	@sfx_sextw_rets
00CD4:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
00CD5:      	P1=		#@sfx_ortable_4
00CD8:      	test		DX.b4
00CD9:      	if ZR jmp	@sfx_sextw_rets
00CDA:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00CDB:      	P1=		#@sfx_ortable_5
00CDE:      	test		DX.b5
00CDF:      	if ZR jmp	@sfx_sextw_rets
00CE0:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
00CE1:      	P1=		#@sfx_ortable_6
00CE4:      	test		DX.b6
00CE5:      	if ZR jmp	@sfx_sextw_rets
00CE6:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
00CE7:      	P1=		#@sfx_ortable_7
00CEA:      	test		DX.b7
00CEB:      	if ZR jmp	@sfx_sextw_rets
00CEC:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
00CED:      	P1=		#@sfx_ortable_8
00CF0:      	test		DX.b8
00CF1:      	if ZR jmp	@sfx_sextw_rets
00CF2:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
00CF3:      	P1=		#@sfx_ortable_9
00CF6:      	test		DX.b9
00CF7:      	if ZR jmp	@sfx_sextw_rets
00CF8:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00CF9:      	P1=		#@sfx_ortable_10
00CFC:      	test		DX.b10
00CFD:      	if ZR jmp	@sfx_sextw_rets
00CFE:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
00CFF:      	P1=		#@sfx_ortable_11
00D02:      	test		DX.b11
00D03:      	if ZR jmp	@sfx_sextw_rets
00D04:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
00D05:      	P1=		#@sfx_ortable_12
00D08:      	test		DX.b12
00D09:      	if ZR jmp	@sfx_sextw_rets
00D0A:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00D0B:      	P1=		#@sfx_ortable_13
00D0E:      	test		DX.b13
00D0F:      	if ZR jmp	@sfx_sextw_rets
00D10:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
00D11:      	P1=		#@sfx_ortable_14
00D14:      	test		DX.b14
00D15:      	if ZR jmp	@sfx_sextw_rets
00D16:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
00D17:      	push		I1
00D18:      	AR=		AX
00D19:      	I1=		AR
00D1A:      	AR=		rm[I1]
00D1B:      	pop		I1
00D1C:      	rm[I1++]=	AR
00D1D:      	AX++
00D1E:      	loop		@sfx_repmov_ss_loop_1804
00D1F:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
00D20:      	AR=		AX
00D21:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00D22:      	rm[I1++]=	pm[P1++]
00D23:      	loop		@sfx_repmov_sr_loop_1804
00D24:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
00D25:      	AR=		AX
00D26:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
00D27:      	AR=		rm[I1++]
00D28:      	pm[P1++]=	AR
00D29:      	loop		@sfx_repmov_rs_loop_1804
00D2A:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00D2B:      	push		P1
00D2C:      	AR=		AX
00D2D:      	P1=		AR
00D2E:      	AR=		pm[P1]
00D2F:      	pop		P1
00D30:      	pm[P1++]=	AR
00D31:      	AX++
00D32:      	loop		@sfx_repmov_rr_loop_1804
00D33:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00D34:      	PCH=	SYS_PROG_ENTRY
00D35:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
00D36:      	DW #EMPTY_INTENTRY
00D37:      	DW #EMPTY_INTENTRY
00D38:      	DW #EMPTY_INTENTRY
00D39:      	DW #EMPTY_INTENTRY
00D3A:      	DW #EMPTY_INTENTRY
00D3B:      	DW #_PWM_Entry4EB0B003
            
            // .code ends
            ;;FDSP-IDE V2.64
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
