            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.2
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	lcall		_main
0011C:      	jmp		SYS_PROG_ENTRY
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011D:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\1_CC49BD7D.S.CODE.ASM> Start=========================
            ; 1.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //interrupt naked void _PWM99B23D7D();
            ; //void _WakeupProc94A410F9();
            ; //void _main();
            ; //void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //interrupt naked void _PWM99B23D7D()		
            _PWM99B23D7D:
            ; //{
            ; //	
            ; //L376D88D5_2:;					
            L376D88D5_2:
            ; //_A515BFAD5_0:;					
            _A515BFAD5_0:
            ; //	return;					
0011E:      	reti
            ; //_PWM99B23D7D_end:;				
            _PWM99B23D7D_end:
            ; //_A515BFAD5_1:;					
            _A515BFAD5_1:
            ; //}
            ; //
            ; //void _WakeupProc94A410F9()			
            _WakeupProc94A410F9:
            ; //{
            ; //_A515BFAD5_2:;					
            _A515BFAD5_2:
            ; //_A515BFAD5_3:;					
            _A515BFAD5_3:
            ; //	asm	io[ClrWDT] = AR			
0011F:      	io[ClrWDT] = AR
            ; //	
            ; //L376D88D5_3:;					
            L376D88D5_3:
            ; //_A515BFAD5_4:;					
            _A515BFAD5_4:
            ; //	return;					
00120:      	rets
            ; //_WakeupProc94A410F9_end:;			
            _WakeupProc94A410F9_end:
            ; //_A515BFAD5_5:;					
            _A515BFAD5_5:
            ; //}
            ; //
            ; //void _main()					
            _main:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00121:      	AR	= rm[BP_SAVE]
00122:      	push	AR
00123:      	AR	= BP
00124:      	rm[BP_SAVE]	= AR
00125:      	AR	 = -1
00126:      	BP	+= AR
            ; //_A515BFAD5_6:;					
            _A515BFAD5_6:
            ; //_A515BFAD5_7:;					
            _A515BFAD5_7:
            ; //	_i_1_2+0	= 0x00;			
00127:      	I1	= rm[BP_SAVE]
00128:      	AR	= 0x00
00129:      	rm[I1]	= AR
            ; //_A515BFAD5_8:;					
            _A515BFAD5_8:
            ; //_A515BFAD5_9:;					
            _A515BFAD5_9:
            ; //	_InitialDA4A7CC4();			
0012A:      	pch	= _InitialDA4A7CC4
0012B:      	lcall	_InitialDA4A7CC4
            ; //L376D88D5_6:;					
            L376D88D5_6:
            ; //_A515BFAD5_10:;					
            _A515BFAD5_10:
            ; //_A515BFAD5_11:;					
            _A515BFAD5_11:
            ; //	asm	io[ClrWDT] = AR			
0012C:      	io[ClrWDT] = AR
            ; //	
            ; //_A515BFAD5_12:;					
            _A515BFAD5_12:
            ; //_A515BFAD5_13:;					
            _A515BFAD5_13:
            ; //	sAX	= 0x0064;			
0012D:      	AX	= 0x64
            ; //	PUSH(sAX);				
0012E:      	push	AX
            ; //	_delay6F9F34ED(STACK[sSP + 0]);		
0012F:      	pch	= _delay6F9F34ED
00130:      	lcall	_delay6F9F34ED
            ; //	RESTORESP(1);				
00131:      	pop	AR
            ; //_A515BFAD5_14:;					
            _A515BFAD5_14:
            ; //_A515BFAD5_15:;					
            _A515BFAD5_15:
            ; //	sAX	= 0x0002;			
00132:      	AX	= 0x02
            ; //	PUSH(sAX);				
00133:      	push	AX
            ; //	sAX	= 0x0007;			
00134:      	AX	= 0x07
            ; //	PUSH(sAX);				
00135:      	push	AX
            ; //	outp(STACK[sSP + 0], STACK[sSP + 1]);	
00136:      	pch	= outp
00137:      	lcall	outp
            ; //	RESTORESP(2);				
00138:      	pop	AR
00139:      	pop	AR
            ; //	goto L376D88D5_6;			
0013A:      	pch =	L376D88D5_6
0013B:      	ljmp	L376D88D5_6
            ; //L376D88D5_5:;					
            L376D88D5_5:
            ; //L376D88D5_4:;					
            L376D88D5_4:
            ; //_A515BFAD5_16:;					
            _A515BFAD5_16:
            ; //	return;					
0013C:      	AR	= 1
0013D:      	BP	+= AR
0013E:      	pop	AR
0013F:      	rm[BP_SAVE]	= AR
00140:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A515BFAD5_17:;					
            _A515BFAD5_17:
            ; //}
            ; //
            ; //void _InitialDA4A7CC4()				
            _InitialDA4A7CC4:
            ; //{
            ; //_A515BFAD5_18:;					
            _A515BFAD5_18:
            ; //	
            ; //_A515BFAD5_19:;					
            _A515BFAD5_19:
            ; //	sAX	= 0x003F;			
00141:      	AX	= 0x3F
            ; //_A515BFAD5_20:;					
            _A515BFAD5_20:
            ; //	asm	AR = AX				
00142:      	AR = AX
            ; //_A515BFAD5_21:;					
            _A515BFAD5_21:
            ; //	asm	FLTG = AR			
00143:      	FLTG = AR
            ; //	
            ; //_A515BFAD5_22:;					
            _A515BFAD5_22:
            ; //	sAX	= 0x1FFF;			
00144:      	AX	= 0x1FFF
            ; //_A515BFAD5_23:;					
            _A515BFAD5_23:
            ; //	asm	AR = AX				
00146:      	AR = AX
            ; //_A515BFAD5_24:;					
            _A515BFAD5_24:
            ; //	asm	FLTP = AR			
00147:      	FLTP = AR
            ; //	
            ; //_A515BFAD5_25:;					
            _A515BFAD5_25:
            ; //	sAX	= 0x0008;			
00148:      	AX	= 0x08
            ; //_A515BFAD5_26:;					
            _A515BFAD5_26:
            ; //	asm	AR = AX				
00149:      	AR = AX
            ; //_A515BFAD5_27:;					
            _A515BFAD5_27:
            ; //	asm	CBL = AR			
0014A:      	CBL = AR
            ; //_A515BFAD5_28:;					
            _A515BFAD5_28:
            ; //	asm	set io[INTENA].b0		
0014B:      	set io[INTENA].b0
            ; //_A515BFAD5_29:;					
            _A515BFAD5_29:
            ; //	asm	eni				
0014C:      	eni
            ; //	
            ; //_A515BFAD5_30:;					
            _A515BFAD5_30:
            ; //	sAX	= 0x000F;			
0014D:      	AX	= 0x0F
            ; //_A515BFAD5_31:;					
            _A515BFAD5_31:
            ; //	asm	AR = AX				
0014E:      	AR = AX
            ; //_A515BFAD5_32:;					
            _A515BFAD5_32:
            ; //	asm	io[IOC_PA] = AR			
0014F:      	io[IOC_PA] = AR
            ; //_A515BFAD5_33:;					
            _A515BFAD5_33:
            ; //_A515BFAD5_34:;					
            _A515BFAD5_34:
            ; //	_ClearTickCount5DDE4003();		
00150:      	pch	= _ClearTickCount5DDE4003
00151:      	lcall	_ClearTickCount5DDE4003
            ; //L376D88D5_7:;					
            L376D88D5_7:
            ; //_A515BFAD5_35:;					
            _A515BFAD5_35:
            ; //	return;					
00152:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A515BFAD5_36:;					
            _A515BFAD5_36:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_1_CC49BD7D_s(void)	
            ginit_code_1_CC49BD7D_s:
            ; //{
            ; //	return;					
00153:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\1_CC49BD7D.S.CODE.ASM> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\LIB\LIBIO\OUTP.ASM> Start=========================
            
            ; ~~ --------------------------
            ; int outp(unsigned int port, unsigned int value)
            outp:
00154:      	AR=		BP
00155:      	AR=		AR + 1		; ~~ port
00156:      	I1=		AR
00157:      	AR=		rm[I1++]
00158:      	AR=		AR & 0x1F
            
            #ifdef _MSPEECHDSP_	
            	P1=		#outp_00
            #else	
00159:      	P1=		#outp_00
0015C:      	P1.hh=		0
            #endif
            
0015D:      	slz		AR, 1
0015E:      	P1=		P1 + AR
0015F:      	AR=		rm[I1]
00160:      	fjmp		pm[P1]
            outp_00:
00161:      	io[0x00]=	AR
00162:      	rets
            outp_01:
00163:      	io[0x01]=	AR
00164:      	rets
            outp_02:
00165:      	io[0x02]=	AR
00166:      	rets
            outp_03:
00167:      	io[0x03]=	AR
00168:      	rets
            outp_04:
00169:      	io[0x04]=	AR
0016A:      	rets
            outp_05:
0016B:      	io[0x05]=	AR
0016C:      	rets
            outp_06:
0016D:      	io[0x06]=	AR
0016E:      	rets
            outp_07:
0016F:      	io[0x07]=	AR
00170:      	rets
            outp_08:
00171:      	io[0x08]=	AR
00172:      	rets
            outp_09:
00173:      	io[0x09]=	AR
00174:      	rets
            outp_0A:
00175:      	io[0x0A]=	AR
00176:      	rets
            outp_0B:
00177:      	io[0x0B]=	AR
00178:      	rets
            outp_0C:
00179:      	io[0x0C]=	AR
0017A:      	rets
            outp_0D:
0017B:      	io[0x0D]=	AR
0017C:      	rets
            outp_0E:
0017D:      	io[0x0E]=	AR
0017E:      	rets
            outp_0F:
0017F:      	io[0x0F]=	AR
00180:      	rets
            outp_10:
00181:      	io[0x10]=	AR
00182:      	rets
            outp_11:
00183:      	io[0x11]=	AR
00184:      	rets
            outp_12:
00185:      	io[0x12]=	AR
00186:      	rets
            outp_13:
00187:      	io[0x13]=	AR
00188:      	rets
            outp_14:
00189:      	io[0x14]=	AR
0018A:      	rets
            outp_15:
0018B:      	io[0x15]=	AR
0018C:      	rets
            outp_16:
0018D:      	io[0x16]=	AR
0018E:      	rets
            outp_17:
0018F:      	io[0x17]=	AR
00190:      	rets
            outp_18:
00191:      	io[0x18]=	AR
00192:      	rets
            outp_19:
00193:      	io[0x19]=	AR
00194:      	rets
            outp_1A:
00195:      	io[0x1A]=	AR
00196:      	rets
            outp_1B:
            #ifndef _MSPEECHDSP2_
            	io[0x1B]=	AR
            #endif
00197:      	rets
            outp_1C:
            	;~ io[0x1C]=	AR
00198:      	nop
00199:      	rets
            outp_1D:
0019A:      	io[0x1D]=	AR
0019B:      	rets
            outp_1E:
0019C:      	io[0x1E]=	AR
0019D:      	rets
            outp_1F:
0019E:      	io[0x1F]=	AR
0019F:      	rets
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\LIB\LIBIO\OUTP.ASM> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> Start=========================
            
            
            _ClearTickCount5DDE4003:
            #ifdef _MFDSP_
            	set		io[MISC].b8
            #else
001A0:      	set		io[MISC].b7
            #endif
001A1:      	set		io[MISC].b15
            	
001A2:      	io[REAL_T]=	AR
001A3:      	AR=		io[REAL_T]
001A4:      	AR=		io[REAL_T]
001A5:      	io[REAL_T]=	AR
001A6:      	rets
            
            ; -----------------------------------------------
            
            _GetTickCount18DC070C:
001A7:      	AX=		0xFFF0
            @gettickcount_loop_1000:
001A9:      	io[ClrWDT]=	AR
001AA:      	AR=		io[REAL_T]
001AB:      	AR=		AR & AX
001AC:      	SF=		AR - AX
001AD:      	if ZR jmp	@gettickcount_loop_1000
001AE:      	AX=		AR
001AF:      	AR=		io[REAL_T]
001B0:      	DX=		AR
001B1:      	rets
            
            	
            ; -----------------------------------------------
            ; void delay(int ms)
            ;
            ; in:
            ;     BP + 1 - int ms
            ;
            ; -----------------------------------------------
            _delay6F9F34ED:
            ; {
001B2:      	AR=		BP
001B3:      	AR=		AR + 1		; ~~ port
001B4:      	I1=		AR
            
            	; unsigned long tick;
            	; unsigned long msr;
            
            	; ~~ 1ms = 32768 ticks
            
            	; msr = (unsigned long)ms << 15;
001B5:      		R0=		0
001B6:      		R1=		rm[I1]
001B7:      		clr		C
001B8:      		src		R1, 1
001B9:      		src		R0, 1
            	
            	; tick = GetTickCount();
001BA:      		call		_GetTickCount18DC070C
001BB:      		AR=		AX
001BC:      		CX=		AR
001BD:      		AR=		DX
001BE:      		BX=		AR
            	
            	; while((GetTickCount() - tick) < msr);
            	@delay_loop_1024:
001BF:      		call		_GetTickCount18DC070C
001C0:      		AR=		CX
001C1:      		AX=		AX - AR
001C2:      		AR=		BX
001C3:      		DX=		DX - AR + C - 1
001C4:      		AR=		R0
001C5:      		AX=		AX - AR
001C6:      		AR=		R1
001C7:      		DX=		DX - AR + C - 1
001C8:      		AR=		0
001C9:      		AR=		AR - 0 + C - 1
001CA:      		if AN jmp	@delay_loop_1024
            
001CB:      	rets
            ; }
            
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> End=========================
            
            ;=========================Include <DEPS\D0F37027_GINIT.S.CODE.ASM> Start=========================
            ; D0F37027_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_1_CC49BD7D_s();		
001CC:      	pch	= ginit_code_1_CC49BD7D_s
001CD:      	lcall	ginit_code_1_CC49BD7D_s
            ; //	return;					
001CE:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\D0F37027_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
001CF:      	P1.hh=		0
001D0:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
001D1:      	AR=		pm[P1++]
001D2:      	rm[I1++]=	AR
            @glinit_label_1409:
001D3:      	loop		@glinit_loop_1409
001D4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
001D5:      	AR=		AX
001D6:      	MX=		AR
001D7:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
001D8:      	MACOP=		3
001D9:      	MR=		MX * AR
            #endif
            
001DA:      	AR=		MR0
001DB:      	AX=		AR
001DC:      	AR=		MR1
001DD:      	DX=		AR
001DE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
001DF:      	AR=		AX
001E0:      	MX=		AR
001E1:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
001E2:      	MACOP=		0
001E3:      	MR=		MX * AR
            #endif
            
001E4:      	AR=		MR0
001E5:      	AX=		AR
001E6:      	AR=		MR1
001E7:      	DX=		AR
001E8:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
001E9:      	AR=		rm[BP_SAVE]
001EA:      	push		AR
001EB:      	AR=		BP
001EC:      	rm[BP_SAVE]=	AR
001ED:      	AR=		AR - 3
001EE:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
001EF:      	AR=		CX
001F0:      	MX=		AR
001F1:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
001F2:      	MACOP=		3		; unsigned
001F3:      	MR=		MX * AR
            #endif
            
001F4:      	I1=		rm[BP_SAVE]
001F5:      	AR=		2
001F6:      	I1=		I1 - AR
001F7:      	rm[I1++]=	MR0
001F8:      	rm[I1++]=	MR1
001F9:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
001FA:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
001FB:      	MACOP=		1		; mx:unsigned / my:signed
001FC:      	MR=		MX * AR
            #endif
            
001FD:      	AR=		rm[I1]
001FE:      	AR=		AR + MR0
001FF:      	rm[I1++]=	AR
00200:      	AR=		rm[I1]
00201:      	AR=		AR + MR1 + C
00202:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00203:      	AR=		BX
00204:      	MX=		AR
00205:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
00206:      	MACOP=		2		; mx:signed / my:unsigned
00207:      	MR=		MX * AR
            #endif
            
00208:      	AR=		rm[I1]
00209:      	AR=		AR + MR0
0020A:      	rm[I1++]=	AR
0020B:      	AR=		rm[I1]
0020C:      	AR=		AR + MR1 + C
0020D:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
0020E:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
0020F:      	MACOP=		0		; mx:signed / my:signed
00210:      	MR=		MX * AR
            #endif
            
00211:      	AR=		rm[I1]
00212:      	AR=		AR + MR0
00213:      	rm[I1]=		AR
            
00214:      	I1=		rm[BP_SAVE]
00215:      	CX=		rm[I1--]
00216:      	DX=		rm[I1--]
00217:      	AX=		rm[I1]
            
00218:      	AR=		3
00219:      	BP=		BP + AR
0021A:      	pop		AR
0021B:      	rm[BP_SAVE]=	AR
            
0021C:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
0021D:      	AR=		rm[BP_SAVE]
0021E:      	push		AR
0021F:      	AR=		BP
00220:      	rm[BP_SAVE]=	AR
00221:      	AR=		AR - 3
00222:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00223:      	AR=		CX
00224:      	MX=		AR
00225:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00226:      	MACOP=		3		; unsigned
00227:      	MR=		MX * AR
            #endif
            
00228:      	I1=		rm[BP_SAVE]
00229:      	AR=		2
0022A:      	I1=		I1 - AR
0022B:      	rm[I1++]=	MR0
0022C:      	rm[I1++]=	MR1
0022D:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
0022E:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0022F:      	MR=		MX * AR
            #endif
            
00230:      	AR=		rm[I1]
00231:      	AR=		AR + MR0
00232:      	rm[I1++]=	AR
00233:      	AR=		rm[I1]
00234:      	AR=		AR + MR1 + C
00235:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00236:      	AR=		BX
00237:      	MX=		AR
00238:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00239:      	MR=		MX * AR
            #endif
            
0023A:      	AR=		rm[I1]
0023B:      	AR=		AR + MR0
0023C:      	rm[I1++]=	AR
0023D:      	AR=		rm[I1]
0023E:      	AR=		AR + MR1 + C
0023F:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00240:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00241:      	MR=		MX * AR
            #endif
            
00242:      	AR=		rm[I1]
00243:      	AR=		AR + MR0
00244:      	rm[I1]=		AR
            
00245:      	I1=		rm[BP_SAVE]
00246:      	CX=		rm[I1--]
00247:      	DX=		rm[I1--]
00248:      	AX=		rm[I1]
            
00249:      	AR=		3
0024A:      	BP=		BP + AR
0024B:      	pop		AR
0024C:      	rm[BP_SAVE]=	AR
            
0024D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
0024E:      		DX=		0
            	; unsigned char count = 16;
0024F:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00250:      			slz		AX, 1
            		; reste <<= 1;
00251:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00252:      			AR=		DX
00253:      			AR-=		CX
00254:      			AR=		0
00255:      			AR=		AR - 0 + C - 1
00256:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
00257:      				AR=		CX
00258:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00259:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
0025A:      		R0--
0025B:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
0025C:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
0025D:      		R1=		0
0025E:      		AR=		0
0025F:      		test		AX.b15
00260:      		if ZR jmp	@divsword_label_1833
00261:      			AX=		AR - AX
00262:      			set		R1.b0
            		@divsword_label_1833:
00263:      		test		CX.b15
00264:      		if ZR jmp	@divsword_label_1834
00265:      			CX=		AR - CX
00266:      			set		R1.b1
            		@divsword_label_1834:
00267:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
00268:      		AR=		R1
00269:      		slz		AR, 1
0026A:      		AR^=		R1
0026B:      		test		AR.b1
0026C:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
0026D:      			AR=		0
0026E:      			AX=		AR - AX
0026F:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
00270:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
00271:      		R0=		0	; L
00272:      		R1=		0	; H
            	; unsigned char count = 32;
00273:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00274:      			slz		AX, 1
00275:      			slc		DX, 1
            		; reste <<= 1;
00276:      			slc		R0, 1
00277:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
00278:      			AR=		R0
00279:      			AR-=		CX
0027A:      			AR=		R1
0027B:      			AR=		AR - BX + C - 1
0027C:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
0027D:      				AR=		CX
0027E:      				R0=		R0 - AR
0027F:      				AR=		BX
00280:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
00281:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
00282:      		R2--
00283:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
00284:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
00285:      		R3=		0
00286:      		AR=		0
00287:      		test		DX.b15
00288:      		if ZR jmp	@divslong_label_1759
00289:      			AX=		AR - AX
0028A:      			DX=		AR - DX + C - 1
0028B:      			set		R3.b0
            		@divslong_label_1759:
0028C:      		test		BX.b15
0028D:      		if ZR jmp	@divslong_label_1800
0028E:      			CX=		AR - CX
0028F:      			BX=		AR - BX + C - 1
00290:      			set		R3.b1
            		@divslong_label_1800:
00291:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
00292:      		AR=		R3
00293:      		slz		AR, 1
00294:      		AR^=		R3
00295:      		test		AR.b1
00296:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
00297:      			AR=		0
00298:      			AX=		AR - AX
00299:      			DX=		AR - DX + C - 1
0029A:      			R0=		AR - R0
0029B:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
0029C:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
0029D:      	call		sfx_DIV_AX_CX
0029E:      	AR=		DX
0029F:      	AX=		AR
002A0:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
002A1:      	call		sfx_IDIV_AX_CX
002A2:      	AR=		DX
002A3:      	AX=		AR
002A4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
002A5:      	call		sfx_DIVLONG
002A6:      	AR=		R0
002A7:      	AX=		AR
002A8:      	AR=		R1
002A9:      	DX=		AR
002AA:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
002AB:      	call		sfx_IDIVLONG
002AC:      	AR=		R0
002AD:      	AX=		AR
002AE:      	AR=		R1
002AF:      	DX=		AR
002B0:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
002B1:      	AR=		AX
002B2:      	P1=		P1 + AR
002B3:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
002B4:      	AR=		AX
002B5:      	I1=		I1 + AR
002B6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
002B7:      	AR=		CX
002B8:      	AX=		AX + AR
002B9:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
002BA:      	AR=		AX
002BB:      	P1=		P1 - AR
002BC:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
002BD:      	AR=		AX
002BE:      	I1=		I1 - AR
002BF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
002C0:      	AR=		CX
002C1:      	AX=		AX + AR
002C2:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
002C3:      	pm[P1++]=	AX
002C4:      	pm[P1--]=	DX
002C5:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
002C6:      	pm[P1++]=	CX
002C7:      	pm[P1--]=	BX
002C8:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
002C9:      	BX=		0
002CA:      	CX.h=		0
002CB:      	test		CX.b7
002CC:      	if ZR jmp	@c2lcx_label_1800
002CD:      	CX.h=		0xFF
002CE:      	BX=		-1
            @c2lcx_label_1800:
002CF:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
002D0:      	DX=		0
002D1:      	AX.h=		0
002D2:      	test		AX.b7
002D3:      	if ZR jmp	@c2lax_label_1800
002D4:      	AX.h=		0xFF
002D5:      	DX=		-1
            @c2lax_label_1800:
002D6:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
002D7:      	push		AX
002D8:      	push		CX
002D9:      	pop		AX
002DA:      	pop		CX
002DB:      	push		DX
002DC:      	push		BX
002DD:      	pop		DX
002DE:      	pop		BX
002DF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
002E0:      	AR=		DX
002E1:      	DX=		0
002E2:      	AR=		AR | AX
002E3:      	AX=		1
002E4:      	if ZR jmp	@longnotl_label_1120
002E5:      	AX=		0
            @longnotl_label_1120:
002E6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            	
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
002E7:      	DX=		0
002E8:      	BX=		0
            sfx_CMPLONG_JNE:
002E9:      	AR=		CX
002EA:      	AX=		AX - AR
002EB:      	AR=		BX
002EC:      	AR=		DX - AR + C - 1
002ED:      	AR=		AR | AX
002EE:      	if EQ jmp	@sfx_cl_jne_f
002EF:      	set		Z		; true
002F0:      	rets
            @sfx_cl_jne_f:
002F1:      	clr		Z		; false
002F2:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
002F3:      	DX=		0
002F4:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
002F5:      	AR=		AX
002F6:      	CX=		CX - AR
002F7:      	AR=		DX
002F8:      	AR=		BX - AR + C - 1
002F9:      	AR=		AR | CX
002FA:      	if EQ jmp	@sfx_clbcda_jne_f
002FB:      	set		Z		; true
002FC:      	rets
            @sfx_clbcda_jne_f:
002FD:      	clr		Z		; false
002FE:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
002FF:      	AR=		CX
00300:      	SF=		AX - AR
00301:      	if EQ jmp	@sfx_ac_jne_f
00302:      	set		Z
00303:      	rets
            @sfx_ac_jne_f:
00304:      	clr		Z
00305:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
00306:      	AR=		AX
00307:      	SF=		CX - AR
00308:      	if EQ jmp	@sfx_ca_jne_f
00309:      	set		Z
0030A:      	rets
            @sfx_ca_jne_f:
0030B:      	clr		Z
0030C:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
0030D:      	DX=		0
0030E:      	BX=		0
            sfx_CMPLONG_JE:
0030F:      	AR=		CX
00310:      	AX=		AX - AR
00311:      	AR=		BX
00312:      	AR=		DX - AR + C - 1
00313:      	AR=		AR | AX
00314:      	if NE jmp	@sfx_cl_jz_f
00315:      	set		Z		; true
00316:      	rets
            @sfx_cl_jz_f:
00317:      	clr		Z		; false
00318:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00319:      	DX=		0
0031A:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
0031B:      	AR=		AX
0031C:      	CX=		CX - AR
0031D:      	AR=		DX
0031E:      	AR=		BX - AR + C - 1
0031F:      	AR=		AR | CX
00320:      	if NE jmp	@sfx_clbcda_jz_f
00321:      	set		Z		; true
00322:      	rets
            @sfx_clbcda_jz_f:
00323:      	clr		Z		; false
00324:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JE:
00325:      	AR=		CX
00326:      	SF=		AX - AR
00327:      	if NE jmp	@sfx_ac_je_f
00328:      	set		Z
00329:      	rets
            @sfx_ac_je_f:
0032A:      	clr		Z
0032B:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JE:
0032C:      	AR=		AX
0032D:      	SF=		CX - AR
0032E:      	if NE jmp	@sfx_ca_je_f
0032F:      	set		Z
00330:      	rets
            @sfx_ca_je_f:
00331:      	clr		Z
00332:      	rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
00333:      	DX=		0
00334:      	BX=		0
            sfx_CMPLONG_JG:
00335:      	AR=		CX
00336:      	AX=		AX - AR
00337:      	AR=		BX
00338:      	AR=		DX - AR + C - 1
00339:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
0033A:      	AR=		AR | AX
0033B:      	if ZR jmp	@sfx_cl_jg_f
            
0033C:      	set		Z		; true
0033D:      	rets
            @sfx_cl_jg_f:
0033E:      	clr		Z		; false
0033F:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
00340:      	AR=		CX
00341:      	AX=		AX - AR
00342:      	AR=		BX
00343:      	DX=		DX - AR + C - 1
00344:      	AR=		0
00345:      	AR=		AR - 0 + C - 1
00346:      	if AN jmp	@sfx_cl_jg_f
            
00347:      	AR=		AR | DX		; exclude EQU condition
00348:      	AR=		AR | AX
00349:      	if ZR jmp	@sfx_cl_jg_f
            
0034A:      	set		Z		; true
0034B:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
0034C:      	DX=		0
0034D:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
0034E:      	AR=		AX
0034F:      	CX=		CX - AR
00350:      	AR=		DX
00351:      	AR=		BX - AR + C - 1
00352:      	if AN jmp	@sfx_clbcda_jg_f
            
00353:      	AR=		AR | CX		; exclude EQU condition
00354:      	if ZR jmp	@sfx_clbcda_jg_f
            
00355:      	set		Z		; true
00356:      	rets
            @sfx_clbcda_jg_f:
00357:      	clr		Z		; false
00358:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00359:      	AR=		AX
0035A:      	CX=		CX - AR
0035B:      	AR=		DX
0035C:      	BX=		BX - AR + C - 1
0035D:      	AR=		0
0035E:      	AR=		AR - 0 + C - 1
0035F:      	if AN jmp	@sfx_clbcda_jg_f
            
00360:      	AR=		AR | BX		; exclude EQU condition
00361:      	AR=		AR | CX
00362:      	if ZR jmp	@sfx_clbcda_jg_f
            
00363:      	set		Z		; true
00364:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
00365:      	AR=		CX
00366:      	SF=		AX - AR
00367:      	if LE jmp	@sfx_cmp_ac_jg_f
00368:      	set		Z
00369:      	rets
            @sfx_cmp_ac_jg_f:
0036A:      	clr		Z
0036B:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
0036C:      	AR=		AX
0036D:      	SF=		CX - AR
0036E:      	if LE jmp	@sfx_cmp_ca_jg_f
0036F:      	set		Z
00370:      	rets
            @sfx_cmp_ca_jg_f:
00371:      	clr		Z
00372:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
00373:      	DX=		0
00374:      	BX=		0
            sfx_CMPLONG_JGE:
00375:      	AR=		CX
00376:      	AX=		AX - AR
00377:      	AR=		BX
00378:      	DX=		DX - AR + C - 1
00379:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
0037A:      	set		Z		; true
0037B:      	rets
            @sfx_cl_jge_f:
0037C:      	clr		Z		; false
0037D:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
0037E:      	AR=		CX
0037F:      	AX=		AX - AR
00380:      	AR=		BX
00381:      	DX=		DX - AR + C - 1
00382:      	AR=		0
00383:      	AR=		AR - 0 + C - 1
00384:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
00385:      	set		Z		; true
00386:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
00387:      	DX=		0
00388:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
00389:      	AR=		AX
0038A:      	CX=		CX - AR
0038B:      	AR=		DX
0038C:      	BX=		BX - AR + C - 1
0038D:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
0038E:      	set		Z		; true
0038F:      	rets
            @sfx_clbcda_jge_f:
00390:      	clr		Z		; false
00391:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
00392:      	AR=		AX
00393:      	CX=		CX - AR
00394:      	AR=		DX
00395:      	BX=		BX - AR + C - 1
00396:      	AR=		0
00397:      	AR=		AR - 0 + C - 1
00398:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
00399:      	set		Z		; true
0039A:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
0039B:      	AR=		CX
0039C:      	SF=		AX - AR
0039D:      	if AN jmp	@sfx_cmp_ac_jge_f
0039E:      	set		Z
0039F:      	rets
            @sfx_cmp_ac_jge_f:
003A0:      	clr		Z
003A1:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
003A2:      	AR=		AX
003A3:      	SF=		CX - AR
003A4:      	if AN jmp	@sfx_cmp_ca_jge_f
003A5:      	set		Z
003A6:      	rets
            @sfx_cmp_ca_jge_f:
003A7:      	clr		Z
003A8:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
003A9:      	DX=		0
003AA:      	BX=		0
            sfx_CMPLONG_JL:
003AB:      	AR=		CX
003AC:      	AX=		AX - AR
003AD:      	AR=		BX
003AE:      	AR=		DX - AR + C - 1
003AF:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
003B0:      	clr		Z		; false
003B1:      	rets
            
            @sfx_cl_jl_chk:
003B2:      	AR=		AR | AX		; exclude EQU condition
003B3:      	if ZR jmp	@sfx_cl_jl_f
003B4:      	set		Z
003B5:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
003B6:      	AR=		CX
003B7:      	AX=		AX - AR
003B8:      	AR=		BX
003B9:      	DX=		DX - AR + C - 1
003BA:      	AR=		0
003BB:      	AR=		AR - 0 + C - 1
003BC:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
003BD:      	clr		Z		; false
003BE:      	rets
            
            @sfx_cl_jb_chk:
003BF:      	AR=		AR | DX
003C0:      	AR=		AR | AX		; exclude EQU condition
003C1:      	if ZR jmp	@sfx_cl_jb_f
003C2:      	set		Z
003C3:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
003C4:      	DX=		0
003C5:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
003C6:      	AR=		AX
003C7:      	CX=		CX - AR
003C8:      	AR=		DX
003C9:      	AR=		BX - AR + C - 1
003CA:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
003CB:      	clr		Z		; false
003CC:      	rets
            
            @sfx_clbcda_jl_chk:
003CD:      	AR=		AR | CX		; exclude EQU condition
003CE:      	if ZR jmp	@sfx_clbcda_jl_f
003CF:      	set		Z		; true
003D0:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
003D1:      	AR=		AX
003D2:      	CX=		CX - AR
003D3:      	AR=		DX
003D4:      	BX=		BX - AR + C - 1
003D5:      	AR=		0
003D6:      	AR=		AR - 0 + C - 1
003D7:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
003D8:      	clr		Z		; false
003D9:      	rets
            
            @sfx_clbcda_jb_chk:
003DA:      	AR=		AR | CX
003DB:      	AR=		AR | BX
003DC:      	if ZR jmp	@sfx_clbcda_jb_f
003DD:      	set		Z		; true
003DE:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
003DF:      	AR=		CX
003E0:      	SF=		AX - AR
003E1:      	if GE jmp	@sfx_cmp_ac_jl_f
003E2:      	set		Z
003E3:      	rets
            @sfx_cmp_ac_jl_f:
003E4:      	clr		Z
003E5:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
003E6:      	AR=		AX
003E7:      	SF=		CX - AR
003E8:      	if GE jmp	@sfx_cmp_ca_jl_f
003E9:      	set		Z
003EA:      	rets
            @sfx_cmp_ca_jl_f:
003EB:      	clr		Z
003EC:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
003ED:      	DX=		0
003EE:      	BX=		0
            sfx_CMPLONG_JLE:
003EF:      	AR=		CX
003F0:      	AX=		AX - AR
003F1:      	AR=		BX
003F2:      	AR=		DX - AR + C - 1
003F3:      	if AN jmp	@sfx_cl_jle_t
            
003F4:      	AR=		AR | AX		; include EQU condition
003F5:      	if ZR jmp	@sfx_cl_jle_t
            
003F6:      	clr		Z		; false
003F7:      	rets
            @sfx_cl_jle_t:
003F8:      	set		Z		; true
003F9:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
003FA:      	AR=		CX
003FB:      	AX=		AX - AR
003FC:      	AR=		BX
003FD:      	DX=		DX - AR + C - 1
003FE:      	AR=		0
003FF:      	AR=		AR - 0 + C - 1
00400:      	if AN jmp	@sfx_cl_jle_t
            
00401:      	AR=		AR | DX
00402:      	AR=		AR | AX
00403:      	if ZR jmp	@sfx_cl_jle_t
            
00404:      	clr		Z		; false
00405:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
00406:      	DX=		0
00407:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00408:      	AR=		AX
00409:      	CX=		CX - AR
0040A:      	AR=		DX
0040B:      	AR=		BX - AR + C - 1
0040C:      	if AN jmp	@sfx_clbcda_jle_t
            
0040D:      	AR=		AR | CX		; include EQU condition
0040E:      	if ZR jmp	@sfx_clbcda_jle_t
            
0040F:      	clr		Z		; false
00410:      	rets
            @sfx_clbcda_jle_t:
00411:      	set		Z		; true
00412:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
00413:      	AR=		AX
00414:      	CX=		CX - AR
00415:      	AR=		DX
00416:      	BX=		BX - AR + C - 1
00417:      	AR=		0
00418:      	AR=		AR - 0 + C - 1
00419:      	if AN jmp	@sfx_clbcda_jle_t
            
0041A:      	AR=		AR | BX
0041B:      	AR=		AR | CX
0041C:      	if ZR jmp	@sfx_clbcda_jle_t
            
0041D:      	clr		Z		; false
0041E:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
0041F:      	AR=		CX
00420:      	SF=		AX - AR
00421:      	if LE jmp	@sfx_cmp_ac_jl_t
00422:      	clr		Z
00423:      	rets
            @sfx_cmp_ac_jl_t:
00424:      	set		Z
00425:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
00426:      	AR=		AX
00427:      	SF=		CX - AR
00428:      	if LE jmp	@sfx_cmp_ca_jl_t
00429:      	clr		Z
0042A:      	rets
            @sfx_cmp_ca_jl_t:
0042B:      	set		Z
0042C:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
0042D:      	DW 0xFFFE
            @sfx_ortable_1:
0042E:      	DW 0xFFFC
            @sfx_ortable_2:
0042F:      	DW 0xFFF8
            @sfx_ortable_3:
00430:      	DW 0xFFF0
            @sfx_ortable_4:
00431:      	DW 0xFFE0
            @sfx_ortable_5:
00432:      	DW 0xFFC0
            @sfx_ortable_6:
00433:      	DW 0xFF80
            @sfx_ortable_7:
00434:      	DW 0xFF00
            @sfx_ortable_8:
00435:      	DW 0xFE00
            @sfx_ortable_9:
00436:      	DW 0xFC00
            @sfx_ortable_10:
00437:      	DW 0xF800
            @sfx_ortable_11:
00438:      	DW 0xF000
            @sfx_ortable_12:
00439:      	DW 0xE000
            @sfx_ortable_13:
0043A:      	DW 0xC000
            @sfx_ortable_14:
0043B:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
0043C:      	AR=		pm[P1]
0043D:      	DX=		DX | AR
0043E:      	rets
            
            @sfx_orhigh_dx:
0043F:      	DX=		-1
            @sfx_orlow:
00440:      	AR=		pm[P1]
00441:      	AX=		AX | AR
            @sfx_sextw_rets:
00442:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
00443:      	P1=		#@sfx_ortable_0
00446:      	test		AX.b0
00447:      	if ZR jmp	@sfx_sextw_rets
00448:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00449:      	P1=		#@sfx_ortable_1
0044C:      	test		AX.b1
0044D:      	if ZR jmp	@sfx_sextw_rets
0044E:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
0044F:      	P1=		#@sfx_ortable_2
00452:      	test		AX.b2
00453:      	if ZR jmp	@sfx_sextw_rets
00454:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
00455:      	P1=		#@sfx_ortable_3
00458:      	test		AX.b3
00459:      	if ZR jmp	@sfx_sextw_rets
0045A:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
0045B:      	P1=		#@sfx_ortable_4
0045E:      	test		AX.b4
0045F:      	if ZR jmp	@sfx_sextw_rets
00460:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
00461:      	P1=		#@sfx_ortable_5
00464:      	test		AX.b5
00465:      	if ZR jmp	@sfx_sextw_rets
00466:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00467:      	P1=		#@sfx_ortable_6
0046A:      	test		AX.b6
0046B:      	if ZR jmp	@sfx_sextw_rets
0046C:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
0046D:      	P1=		#@sfx_ortable_7
00470:      	test		AX.b7
00471:      	if ZR jmp	@sfx_sextw_rets
00472:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
00473:      	P1=		#@sfx_ortable_8
00476:      	test		AX.b8
00477:      	if ZR jmp	@sfx_sextw_rets
00478:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
00479:      	P1=		#@sfx_ortable_9
0047C:      	test		AX.b9
0047D:      	if ZR jmp	@sfx_sextw_rets
0047E:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
0047F:      	P1=		#@sfx_ortable_10
00482:      	test		AX.b10
00483:      	if ZR jmp	@sfx_sextw_rets
00484:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
00485:      	P1=		#@sfx_ortable_11
00488:      	test		AX.b11
00489:      	if ZR jmp	@sfx_sextw_rets
0048A:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
0048B:      	P1=		#@sfx_ortable_12
0048E:      	test		AX.b12
0048F:      	if ZR jmp	@sfx_sextw_rets
00490:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
00491:      	P1=		#@sfx_ortable_13
00494:      	test		AX.b13
00495:      	if ZR jmp	@sfx_sextw_rets
00496:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
00497:      	P1=		#@sfx_ortable_14
0049A:      	test		AX.b14
0049B:      	if ZR jmp	@sfx_sextw_rets
0049C:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
0049D:      	P1=		#@sfx_ortable_0
004A0:      	test		AX.b0
004A1:      	if ZR jmp	@sfx_sextw_rets
004A2:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
004A3:      	P1=		#@sfx_ortable_1
004A6:      	test		AX.b1
004A7:      	if ZR jmp	@sfx_sextw_rets
004A8:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
004A9:      	P1=		#@sfx_ortable_2
004AC:      	test		AX.b2
004AD:      	if ZR jmp	@sfx_sextw_rets
004AE:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
004AF:      	P1=		#@sfx_ortable_3
004B2:      	test		AX.b3
004B3:      	if ZR jmp	@sfx_sextw_rets
004B4:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
004B5:      	P1=		#@sfx_ortable_4
004B8:      	test		AX.b4
004B9:      	if ZR jmp	@sfx_sextw_rets
004BA:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
004BB:      	P1=		#@sfx_ortable_5
004BE:      	test		AX.b5
004BF:      	if ZR jmp	@sfx_sextw_rets
004C0:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
004C1:      	P1=		#@sfx_ortable_6
004C4:      	test		AX.b6
004C5:      	if ZR jmp	@sfx_sextw_rets
004C6:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
004C7:      	P1=		#@sfx_ortable_7
004CA:      	test		AX.b7
004CB:      	if ZR jmp	@sfx_sextw_rets
004CC:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
004CD:      	P1=		#@sfx_ortable_8
004D0:      	test		AX.b8
004D1:      	if ZR jmp	@sfx_sextw_rets
004D2:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
004D3:      	P1=		#@sfx_ortable_9
004D6:      	test		AX.b9
004D7:      	if ZR jmp	@sfx_sextw_rets
004D8:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
004D9:      	P1=		#@sfx_ortable_10
004DC:      	test		AX.b10
004DD:      	if ZR jmp	@sfx_sextw_rets
004DE:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
004DF:      	P1=		#@sfx_ortable_11
004E2:      	test		AX.b11
004E3:      	if ZR jmp	@sfx_sextw_rets
004E4:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
004E5:      	P1=		#@sfx_ortable_12
004E8:      	test		AX.b12
004E9:      	if ZR jmp	@sfx_sextw_rets
004EA:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
004EB:      	P1=		#@sfx_ortable_13
004EE:      	test		AX.b13
004EF:      	if ZR jmp	@sfx_sextw_rets
004F0:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
004F1:      	P1=		#@sfx_ortable_14
004F4:      	test		AX.b14
004F5:      	if ZR jmp	@sfx_sextw_rets
004F6:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
004F7:      	test		AX.b15
004F8:      	if ZR jmp	@sfx_sextw_rets
004F9:      	DX=		-1
004FA:      	rets
            
            sfx_SignExtL16:
004FB:      	P1=		#@sfx_ortable_0
004FE:      	test		DX.b0
004FF:      	if ZR jmp	@sfx_sextw_rets
00500:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
00501:      	P1=		#@sfx_ortable_1
00504:      	test		DX.b1
00505:      	if ZR jmp	@sfx_sextw_rets
00506:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00507:      	P1=		#@sfx_ortable_2
0050A:      	test		DX.b2
0050B:      	if ZR jmp	@sfx_sextw_rets
0050C:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
0050D:      	P1=		#@sfx_ortable_3
00510:      	test		DX.b3
00511:      	if ZR jmp	@sfx_sextw_rets
00512:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
00513:      	P1=		#@sfx_ortable_4
00516:      	test		DX.b4
00517:      	if ZR jmp	@sfx_sextw_rets
00518:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00519:      	P1=		#@sfx_ortable_5
0051C:      	test		DX.b5
0051D:      	if ZR jmp	@sfx_sextw_rets
0051E:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
0051F:      	P1=		#@sfx_ortable_6
00522:      	test		DX.b6
00523:      	if ZR jmp	@sfx_sextw_rets
00524:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
00525:      	P1=		#@sfx_ortable_7
00528:      	test		DX.b7
00529:      	if ZR jmp	@sfx_sextw_rets
0052A:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
0052B:      	P1=		#@sfx_ortable_8
0052E:      	test		DX.b8
0052F:      	if ZR jmp	@sfx_sextw_rets
00530:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
00531:      	P1=		#@sfx_ortable_9
00534:      	test		DX.b9
00535:      	if ZR jmp	@sfx_sextw_rets
00536:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00537:      	P1=		#@sfx_ortable_10
0053A:      	test		DX.b10
0053B:      	if ZR jmp	@sfx_sextw_rets
0053C:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
0053D:      	P1=		#@sfx_ortable_11
00540:      	test		DX.b11
00541:      	if ZR jmp	@sfx_sextw_rets
00542:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
00543:      	P1=		#@sfx_ortable_12
00546:      	test		DX.b12
00547:      	if ZR jmp	@sfx_sextw_rets
00548:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00549:      	P1=		#@sfx_ortable_13
0054C:      	test		DX.b13
0054D:      	if ZR jmp	@sfx_sextw_rets
0054E:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
0054F:      	P1=		#@sfx_ortable_14
00552:      	test		DX.b14
00553:      	if ZR jmp	@sfx_sextw_rets
00554:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
00555:      	push		I1
00556:      	AR=		AX
00557:      	I1=		AR
00558:      	AR=		rm[I1]
00559:      	pop		I1
0055A:      	rm[I1++]=	AR
0055B:      	AX++
0055C:      	loop		@sfx_repmov_ss_loop_1804
0055D:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
0055E:      	AR=		AX
0055F:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00560:      	rm[I1++]=	pm[P1++]
00561:      	loop		@sfx_repmov_sr_loop_1804
00562:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
00563:      	AR=		AX
00564:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
00565:      	AR=		rm[I1++]
00566:      	pm[P1++]=	AR
00567:      	loop		@sfx_repmov_rs_loop_1804
00568:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00569:      	push		P1
0056A:      	AR=		AX
0056B:      	P1=		AR
0056C:      	AR=		pm[P1]
0056D:      	pop		P1
0056E:      	pm[P1++]=	AR
0056F:      	AX++
00570:      	loop		@sfx_repmov_rr_loop_1804
00571:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            	
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            	
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            	
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            	
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\FP32RT.ASM> Start=========================
            
            ; ~~-----------------------------------------------------
            ; single precision number (32-bit) float point support for DSP
            ; -------------------------------------------------------
            
            ; -------------------------------------------------------
            ; ~~ porting from SDCC
            ; -------------------------------------------------------
            
            ; +-----------------------------------------------------+-------------------------------------------------+
            ; | DX (BX)                                             | AX (CX)                                         |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ; |  0   | 7  6  5  4  3  2  1  0 |22 21 20 19 18 17 16 | 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ; | sign | e  e  e  e  e  e  e  e | m  m  m  m  m  m  m |  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ;    15   14 13 12 11 10  9  8  7   6  5  4  3  2  1  0   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            
            
            ; ~~ float -> sign / exp / mantissa
            
            ; ~~ DX:AX / BX:CX - mantissa [31:8]
            
            ; +-------------------------------------------------+--------------------------------------------------+
            ; | DX (BX)                                         | AX (CX)                                          |
            ; +---+---------------------------------------------+-------------------------+------------------------+
            ; | 1 | m  m  m  m  m  m  m  m  m  m  m  m  m  m  m | m  m  m  m  m  m  m  m  | 0  0  0  0  0  0  0  0 |
            ; +---+---------------------------------------------+-------------------------+------------------------+
            ;   H   22 21 20 19 18 17 16 15 14 13 12 11 10 9  8   7  6  5  4  3  2  1  0    -  -  -  -  -  -  -  -
            ;
            
            ; ~~ R0    / R1    - sign and exp
            ; +------------------------+------------------------+
            ; | S  -  -  -  -  -  -  - | e  e  e  e  e  e  e  e |
            ; +------------------------+------------------------+
            ;  15 14 13 12 11 10  9  8   7  6  5  4  3  2  1  0
            
            
            ; ~~ no shift
            
            sfx_GETARG_DANS_FS:
00572:      	AR=		DX
00573:      	slz		AR, 1		; ~~ C = sign
00574:      	xchg		AR
00575:      	AH=		0
00576:      	R0=		AR
00577:      	if NC jmp	@sfx_getarg_dafs_label_1736
00578:      	set		R0.b15
            @sfx_getarg_dafs_label_1736:
00579:      	AR=		0x7F
0057A:      	DX=		DX & AR
0057B:      	set		DX.b7		; ~~ HIDDEN 1
0057C:      	rets
            
            ; ~~ ----
            
            sfx_GETARG_DA_FS:
0057D:      	call		sfx_GETARG_DANS_FS
0057E:      	slz		AX, 2
0057F:      	slc		DX, 2
00580:      	slz		AX, 2
00581:      	slc		DX, 2
00582:      	slz		AX, 2
00583:      	slc		DX, 2
00584:      	slz		AX, 2
00585:      	slc		DX, 2
00586:      	rets
            
            ; ~~ ----
            
            ; ~~ no shift
            
            sfx_GETARG_BCNS_FS:
00587:      	AR=		BX
00588:      	slz		AR, 1		; ~~ C = sign
00589:      	xchg		AR
0058A:      	AH=		0
0058B:      	R1=		AR
0058C:      	if NC jmp	@sfx_getarg_bcfs_label_1736
0058D:      	set		R1.b15
            @sfx_getarg_bcfs_label_1736:
0058E:      	AR=		0x7F
0058F:      	BX=		BX & AR
00590:      	set		BX.b7		; ~~ HIDDEN 1
00591:      	rets
            
            ; ~~ ----
            
            sfx_GETARG_BC_FS:
00592:      	call		sfx_GETARG_BCNS_FS
00593:      	slz		CX, 2
00594:      	slc		BX, 2
00595:      	slz		CX, 2
00596:      	slc		BX, 2
00597:      	slz		CX, 2
00598:      	slc		BX, 2
00599:      	slz		CX, 2
0059A:      	slc		BX, 2
0059B:      	rets
            
            
            ; ~~ ----
            
            sfx_Normalize_DA_FS:
            ; {
0059C:      	push		CX
0059D:      	CX=		31
            @sfx_normalize_dafs_loop_1609:
0059E:      	test		DX.b15
0059F:      	if NZ jmp	@sfx_normalize_dafs_label_1609
005A0:      	slz		AX, 1
005A1:      	slc		DX, 1
005A2:      	R0--
005A3:      	AR=		R0
005A4:      	clr		AR.b15
005A5:      	if ZR jmp	@sfx_normalize_dafs_label_1609
005A6:      	loop		@sfx_normalize_dafs_loop_1609
            @sfx_normalize_dafs_label_1609:
005A7:      	pop		CX
005A8:      	rets
            ; }
            
            
            
            ; ~~ DX:AX - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_RoundRet_DA_FS:
            ; {
            	; ~~ for register save
            
            	; ~~ round lowest 8-bit to increase accuracy ??
            
            	; AR=		AX
            	; AH=		0
            	; AR=		AR + 0x80		; 0xFF80
            	; if LE jmp	@sfx_roundret_dafs_label_1033
            
            	; test		AX.b8
            	; if ZR jmp	@sfx_roundret_dafs_label_1033
            
            	; ~~ +1
            
005A9:      	AR=		0x0080
005AB:      	AX=		AX + AR
005AC:      	AR=		0
005AD:      	DX=		DX + AR + C
005AE:      	if NC jmp	@sfx_roundret_dafs_label_1033
            	; ~~ overflow
005AF:      	DX.h=		0x80
005B0:      	R0++
            @sfx_roundret_dafs_label_1033:
005B1:      	AR=		AX
005B2:      	AL=		0
005B3:      	AR=		AR | DX
005B4:      	if NZ jmp	sfx_DirectRet_DA_FS
            
            sfx_RetZero_DA_FS:
            	; ~~ float 0.0
005B5:      	AX=		0
005B6:      	DX=		0
005B7:      	rets
            
            
            sfx_DirectRet_DA_FS:
            	; ~~ drop 1-bit  (1.xxx)
005B8:      	slz		AX, 1
005B9:      	slc		DX, 1
            
            	; ~~ 8-bit exp
            
005BA:      	AR=		R0
005BB:      	sra		AR, 2
005BC:      	src		DX, 2
005BD:      	src		AX, 2
005BE:      	sra		AR, 2
005BF:      	src		DX, 2
005C0:      	src		AX, 2
005C1:      	sra		AR, 2
005C2:      	src		DX, 2
005C3:      	src		AX, 2
005C4:      	sra		AR, 2
005C5:      	src		DX, 2
005C6:      	src		AX, 2
            
005C7:      	slz		AR, 1		; ~~ sign bit (sra duplicate)
005C8:      	src		DX, 1
005C9:      	src		AX, 1
005CA:      	rets
            
            sfx_ReturnINF_DA_FS:
005CB:      	AX=		0
005CC:      	DX=		0xFF00
005CE:      	AR=		R0
005CF:      	slz		AR, 1
005D0:      	src		DX, 1
005D1:      	rets
            
            sfx_ReturnNaN_DA_FS:
005D2:      	AX=		0
005D3:      	DX=		0x7FC0
005D5:      	rets
            
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; --------------------------
            ; ~~ int type -> float point
            ; --------------------------
            
            
            ; --------------------------
            ; DX:AX		- in  (long)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_LONGTOFP32:
005D6:      	R0=		0x009E		; ~~ E+31
            
            sfx_LONG2FS_CORE:			; ~~ without exp
005D8:      	test		DX.b15
005D9:      	if ZR jmp	@sfx_long2fs_label_1004
            
            	; ~~ make it positive if value is negative
            
005DA:      	set		R0.b15		; ~~ sign
005DB:      	AR=		0
005DC:      	AX=		AR - AX
005DD:      	DX=		AR - DX + C - 1
            @sfx_long2fs_label_1004:
005DE:      	call		sfx_Normalize_DA_FS
005DF:      	jmp		sfx_RoundRet_DA_FS
            
            
            
            sfx_LONGTOFP32_BXCX:
005E0:      	call		sfx_FP32SWAP
005E1:      	call		sfx_LONGTOFP32
005E2:      	call		sfx_FP32SWAP
005E3:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in  (unsigned long)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_ULONGTOFP32:
            ; {
005E4:      	R0=		0x009E		; ~~ E+31
            sfx_ULONG2FS_CORE:
005E6:      	call		sfx_Normalize_DA_FS
005E7:      	jmp		sfx_RoundRet_DA_FS
            ; }
            
            
            ; --------------------------
            
            
            sfx_ULONGTOFP32_BXCX:
005E8:      	call		sfx_FP32SWAP
005E9:      	call		sfx_ULONGTOFP32
005EA:      	call		sfx_FP32SWAP
005EB:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_INTTOFP32:
005EC:      	AR=		AX
005ED:      	DX=		AR
005EE:      	AX=		0
005EF:      	R0=		0x008E
005F1:      	jmp		sfx_LONG2FS_CORE
            
            
            ; --------------------------
            
            
            sfx_INTTOFP32_BXCX:
005F2:      	call		sfx_FP32SWAP
005F3:      	call		sfx_INTTOFP32
005F4:      	call		sfx_FP32SWAP
005F5:      	rets
            
            
            ; --------------------------
            ; AX		- in  (unsigned int)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_UINTTOFP32:
005F6:      	AR=		AX
005F7:      	DX=		AR
005F8:      	AX=		0
005F9:      	R0=		0x008E
005FB:      	jmp		sfx_ULONG2FS_CORE
            
            ; --------------------------
            
            sfx_UINTTOFP32_BXCX:
005FC:      	call		sfx_FP32SWAP
005FD:      	call		sfx_UINTTOFP32
005FE:      	call		sfx_FP32SWAP
005FF:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            
            ; --------------------------
            ; DX:AX - mantissa
            ; R0    - sign & exp
            ; AR    - shift count
            ; --------------------------
            sfx_RSHIFT_DA:
            	; ~~ check if 0 shift count
            
00600:      	if ZR jmp	@sfx_rshift_label_1132
            
            	; ~~ adjust exp
00601:      	push		CX
00602:      	CX=		AR
00603:      	AR=		AR + R0
00604:      	test		AR.b8
00605:      	if ZR jmp	@sfx_rshift_label_1333
            
00606:      	AR=		R0
00607:      	AL=		0xFF
            
            @sfx_rshift_label_1333:
00608:      	R0=		AR
00609:      	jmp		@sfx_rshift_label_1335
            @sfx_rshift_loop_1335:
0060A:      	clr		C
0060B:      	src		DX, 1
0060C:      	src		AX, 1
            @sfx_rshift_label_1335:
0060D:      	loop		@sfx_rshift_loop_1335
0060E:      	pop		CX
            @sfx_rshift_label_1132:
0060F:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; DX:AX		- out (long)
            ; --------------------------
            sfx_FP32TOLONG:
00610:      	call		sfx_GETARG_DA_FS
00611:      	AR=		0x009E
00613:      	AR=		AR - R0
00614:      	test		AR.b8
00615:      	if NZ jmp	@sfx_fs2long_label_1709		; ~~ |X| >= 2^32
            
            	; ~~ lowest 8-bit already zero
            
00616:      	AH=		0
00617:      	call		sfx_RSHIFT_DA
            
00618:      	test		R0.b15
00619:      	if ZR jmp	@sfx_fs2long_label_1339
            	
            	; ~~ check zero
            
0061A:      	AR=		AX
0061B:      	AR=		AR | DX
0061C:      	if NZ jmp	@sfx_fs2long_label_1116
0061D:      	rets
            @sfx_fs2long_label_1116:
            
            	; ~~ negative
            
0061E:      	AR=		0
0061F:      	AX=		AR - AX
00620:      	DX=		AR - DX + C - 1
00621:      	AR=		AR - 0 + C - 1
            
            	; ~~ x < -0x80000000
00622:      	if AN jmp	@sfx_fs2long_label_1420
00623:      	rets
            
            @sfx_fs2long_label_1339:
            	; ~~ postive
00624:      	test		DX.b15
00625:      	if NZ jmp	@sfx_fs2long_label_1421
00626:      	rets
            
            @sfx_fs2long_label_1709:
            	; ~~ fs2slong_maxval
00627:      	test		R0.b15
00628:      	if ZR jmp	@sfx_fs2long_label_1421
            
            @sfx_fs2long_label_1420:
            	; ~~ check sign bit
00629:      	test		DX.b15
0062A:      	if ZR jmp	@sfx_fs2long_label_1118
0062B:      	rets
            @sfx_fs2long_label_1118:
            	; ~~ fs2slong_maxval_neg
0062C:      	AX=		0
0062D:      	DX=		0x8000
0062F:      	rets
            
            @sfx_fs2long_label_1421:
            	; ~~ fs2long_maxval_pos
00630:      	AX=		0xFFFF
00632:      	DX=		0x7FFF
00634:      	rets
            
            ; --------------------------
            
            sfx_FP32TOLONG_BXCX:
00635:      	call		sfx_FP32SWAP
00636:      	call		sfx_FP32TOLONG
00637:      	call		sfx_FP32SWAP
00638:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP32TOULONG:
00639:      	call		sfx_GETARG_DA_FS
0063A:      	test		R0.b15
0063B:      	if ZR jmp	@sfx_fs2ulong_label_1536
            
            	; ~~ return 0
            
0063C:      	AX=		0
0063D:      	DX=		0
0063E:      	rets
            
            @sfx_fs2ulong_label_1536:
            	; ~~ fs2ulong_int
            
0063F:      	AR=		0x009E
00641:      	AR=		AR - R0
00642:      	test		AR.b8
00643:      	if ZR jmp	@sfx_fs2ulong_label_1541
            
            	; ~~ x >= 2^32
            
00644:      	AX=		0xFF		; ~~ 0xFFFF
00645:      	DX=		0xFF		; ~~ 0xFFFF
00646:      	rets
            
            @sfx_fs2ulong_label_1541:
00647:      	AH=		0
00648:      	call		sfx_RSHIFT_DA
00649:      	rets
            
            	
            ; --------------------------
            
            sfx_FP32TOULONG_BXCX:
0064A:      	call		sfx_FP32SWAP
0064B:      	call		sfx_FP32TOULONG
0064C:      	call		sfx_FP32SWAP
0064D:      	rets
            	
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (short)
            ; --------------------------
            sfx_FP32TOINT:
0064E:      	call		sfx_FP32TOLONG
0064F:      	AR=		AX
00650:      	AR=		AR | DX
00651:      	if NZ jmp	@sfx_fs2int_label_1138
00652:      	rets
            @sfx_fs2int_label_1138:
00653:      	test		R0.b15
00654:      	if ZR jmp	@sfx_fs2int_label_1553
            
            	; ~~ negative
            
00655:      	AR=		-1
00656:      	SF=		AR - DX
00657:      	if NE jmp	@sfx_fs2int_label_1609
00658:      	test		AX.b15
00659:      	if ZR jmp	@sfx_fs2int_label_1609
0065A:      	rets
            @sfx_fs2int_label_1609:
0065B:      	AX=		0x8000
0065D:      	rets
            
            
            @sfx_fs2int_label_1553:
            
            	; ~~ positive check
            
0065E:      	AR=		DX
0065F:      	if NZ jmp	@sfx_fs2int_label_1603_2
00660:      	test		AX.b15
00661:      	if NZ jmp	@sfx_fs2int_label_1603_2
00662:      	rets
            @sfx_fs2int_label_1603_2:
00663:      	AX=		0x7FFF
00665:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOINT_BXCX:
00666:      	call		sfx_FP32SWAP
00667:      	call		sfx_FP32TOINT
00668:      	call		sfx_FP32SWAP
00669:      	rets
            	
            
            	
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (ushort)
            ; --------------------------
            sfx_FP32TOUINT:
0066A:      	call		sfx_FP32TOULONG
0066B:      	AR=		DX
0066C:      	if NZ jmp	@sfx_fs2uint_label_1644
0066D:      	rets
            @sfx_fs2uint_label_1644:
0066E:      	AX=		0xFFFF
00670:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOUINT_BXCX:
00671:      	call		sfx_FP32SWAP
00672:      	call		sfx_FP32TOUINT
00673:      	call		sfx_FP32SWAP
00674:      	rets
            	
            
            ; ~~-------------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (fp16)
            ; ~~-------------------------------
            sfx_FP32TOFP16:
00675:      	call		sfx_GETARG_DA_FS
            
00676:      	AR=		0x70
00677:      	R0=		R0 - AR
00678:      	test		R0.b5
00679:      	if NZ jmp	@sfx_fs2f16_label_1647
0067A:      	AR=		R0
0067B:      	AH=		0
0067C:      	if ZR jmp	@sfx_fs2f16_label_1647
0067D:      	SF=		AR - 0x1F
0067E:      	if GE jmp	@sfx_fs2f16_label_1647
            
            	; ~~ no round
            
            	; ~~ drop hidden 1
0067F:      	slz		AX, 1
00680:      	slc		DX, 1
            
00681:      	AR=		DX
00682:      	AX=		0xE0		; ~~ FFE0
00683:      	AX=		AR & AX
            
00684:      	AR=		R0
00685:      	sra		AR, 2
00686:      	src		AX, 2
00687:      	sra		AR, 2
00688:      	src		AX, 2
00689:      	sra		AR, 1
0068A:      	src		AX, 1
0068B:      	slz		AR, 1
0068C:      	src		AX, 1
0068D:      	rets
            
            @sfx_fs2f16_label_1647:
            	; ~~ FP16 INF
0068E:      	AX=		0xF800
00690:      	AR=		R0
00691:      	slz		AR, 1
00692:      	src		AX, 1
00693:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOFP16_BXCX:
00694:      	call		sfx_FP32SWAP
00695:      	call		sfx_FP32TOFP16
00696:      	call		sfx_FP32SWAP
00697:      	rets
            
            ; -------------------------------------------
            ; ~~ swap two fp32 value
            ; R0:DX:AX  <-> R1:BX:CX
            ; -------------------------------------------
            
            
            sfx_FP32SWAP_AB:
00698:      	push		R0
00699:      	push		R1
0069A:      	pop		R0
0069B:      	pop		R1
0069C:      	push		AX
0069D:      	push		CX
0069E:      	pop		AX
0069F:      	pop		CX
006A0:      	push		DX
006A1:      	push		BX
006A2:      	pop		DX
006A3:      	pop		BX
006A4:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            
            sfx_FP32ADD:
006A5:      	call		sfx_GETARG_DA_FS
006A6:      	call		sfx_GETARG_BC_FS
            
            	; ~~ which exponent is greater ?
            
006A7:      	AR=		R1
006A8:      	push		R0
006A9:      	pop		R2
006AA:      	clr		AR.b15
006AB:      	clr		R2.b15
006AC:      	SF=		AR - R2
006AD:      	if GE jmp	@sfx_fp32add_label_1043
            
006AE:      	call		sfx_FP32SWAP_AB
            
            @sfx_fp32add_label_1043:
006AF:      	AR=		R1
006B0:      	push		R0
006B1:      	pop		R2
006B2:      	clr		AR.b15
006B3:      	clr		R2.b15
006B4:      	AR=		AR - R2
006B5:      	call		sfx_RSHIFT_DA
            
            	; ~~ decide if we need to add or subtract
            
006B6:      	AR=		R0
006B7:      	AR=		AR ^ R1
006B8:      	slz		AR, 1
006B9:      	if AC jmp	@sfx_fp32add_label_1714
            
            	; ~~ add the mantissa (both positive or both negative)
            
006BA:      	AR=		CX
006BB:      	AX=		AX + AR
006BC:      	AR=		BX
006BD:      	DX=		DX + AR + C
006BE:      	if NC jmp	@sfx_fp32add_label_1718
006BF:      	AR=		1
006C0:      	call		sfx_RSHIFT_DA
006C1:      	set		DX.b15			; ~~ hidden 1
            @sfx_fp32add_label_1718:
006C2:      	jmp		@sfx_fp32add_label_1720
            
            @sfx_fp32add_label_1714:
            
            	; ~~ subtract the mantissa (one of them is negative)
            
006C3:      	AR=		CX
006C4:      	AX=		AX - AR
006C5:      	AR=		BX
006C6:      	DX=		DX - AR + C - 1
006C7:      	if AC jmp	@sfx_fp32add_label_1720
            
006C8:      	AR=		0
006C9:      	AX=		AR - AX
006CA:      	DX=		AR - DX + C - 1
006CB:      	not		R0.b15
            @sfx_fp32add_label_1720:
006CC:      	call		sfx_Normalize_DA_FS
006CD:      	jmp		sfx_RoundRet_DA_FS
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32SUB:
006CE:      	not		BX.b15
006CF:      	jmp		sfx_FP32ADD
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32MUL:
            	; ~~ first check if either input is zero
            
006D0:      	AR=		DX
006D1:      	if ZR jmp	sfx_RetZero_DA_FS
006D2:      	AR=		BX
006D3:      	if ZR jmp	sfx_RetZero_DA_FS
            
006D4:      	call		sfx_GETARG_DANS_FS
006D5:      	call		sfx_GETARG_BCNS_FS
            
            	; ~~ compare final sign bit
            
006D6:      	test		R1.b15
006D7:      	if ZR jmp	@sfx_fp32mul_label_1026
            
006D8:      	not		R0.b15
            @sfx_fp32mul_label_1026:
            
            	; ~~ check if either input is infinity
            
006D9:      	AR=		R1
006DA:      	AH=		0xFF
006DB:      	SF=		AR - 0xFF		; ~~ 0xFFFF
006DC:      	if EQ jmp	sfx_ReturnINF_DA_FS
            
006DD:      	AR=		R0
006DE:      	AH=		0xFF
006DF:      	SF=		AR - 0xFF		; ~~ 0xFFFF
006E0:      	if EQ jmp	sfx_ReturnINF_DA_FS
            
            
            	; ~~ add the exponents
            
006E1:      	AR=		R1
006E2:      	clr		AR.b15
006E3:      	AR=		AR + R0
006E4:      	test		AR.b8
006E5:      	if NZ jmp	@sfx_fp32mul_label_1322
            
            	; ~~ minus exponents
            
006E6:      	AR=		AR - 126
006E7:      	test		AR.b8
006E8:      	if ZR jmp	@sfx_fp32mul_label_1103
            
006E9:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32mul_label_1322:
            
006EA:      	AR=		AR - 126
006EB:      	test		AR.b8
006EC:      	if ZR jmp	@sfx_fp32mul_label_1103
            
006ED:      	jmp		sfx_ReturnINF_DA_FS
            
            @sfx_fp32mul_label_1103:
006EE:      	R0=		AR
            
            	; ~~ unsigned multiplay
006EF:      	PCH=		sfx_MULLONG
006F0:      	lcall		sfx_MULLONG
            
            	; ~~ 48-bit result in CX:DX:AX
            
            	; ~~ drop low 16-bit
            
006F1:      	push		DX
006F2:      	pop		AX
006F3:      	push		CX
006F4:      	pop		DX
006F5:      	test		DX.b15
006F6:      	if NZ jmp	@sfx_fs32mul_label_1326
            
006F7:      	call		sfx_Normalize_DA_FS
            @sfx_fs32mul_label_1326:
006F8:      	jmp		sfx_RoundRet_DA_FS
            
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32DIV:
            	; ~~ compute final sign bit
006F9:      	test		BX.b15
006FA:      	if ZR jmp	@sfx_fp32div_label_1629
            
006FB:      	not		DX.b15
            @sfx_fp32div_label_1629:
            
            	; ~~ if divisor is zero, ...
006FC:      	AR=		BX
006FD:      	if NZ jmp	@sfx_fp32div_label_1639
            	; ~~ if dividend is also zero, return NaN
006FE:      	AR=		DX
006FF:      	if NZ jmp	@sfx_fp32div_label_1641
00700:      	jmp		sfx_ReturnNaN_DA_FS
            @sfx_fp32div_label_1641:
            	; ~~ but dividend is non-zero, return infinity
00701:      	jmp		sfx_ReturnINF_DA_FS
            @sfx_fp32div_label_1639:
            	; ~~ if dividend is zero, return zero
00702:      	AR=		DX
00703:      	if NZ jmp	@sfx_fp32div_label_1644
00704:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32div_label_1644:
00705:      	call		sfx_GETARG_DANS_FS
00706:      	call		sfx_GETARG_BCNS_FS
            
            	; ~~ if divisor is infinity, ...
00707:      	AR=		R1
00708:      	AH=		0xFF
00709:      	SF=		AR - 0xFF	; ~~ 0xFFFF
0070A:      	if NE jmp	@sfx_fp32div_label_1646
0070B:      	AR=		R0
0070C:      	AH=		0xFF
0070D:      	SF=		AR - 0xFF	; ~~ 0xFFFF
0070E:      	if NE jmp	@sfx_fp32div_label_1647
0070F:      	jmp		sfx_ReturnNaN_DA_FS
            @sfx_fp32div_label_1647:
00710:      	jmp		sfx_RetZero_DA_FS
            
            @sfx_fp32div_label_1646:
            	; ~~ subtract exponents
            
00711:      	AR=		R1
00712:      	clr		AR.b15
00713:      	AR=		R0 - AR
00714:      	test		AR.b8
00715:      	if ZR jmp	@sfx_fp32div_label_1649
            
00716:      	AR=		AR + 127
00717:      	test		AR.b8
00718:      	if ZR jmp	@sfx_fp32div_label_1753
00719:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32div_label_1649:
            
0071A:      	AR=		AR + 127
0071B:      	test		AR.b8
0071C:      	if ZR jmp	@sfx_fp32div_label_1753
0071D:      	jmp		sfx_ReturnINF_DA_FS
            @sfx_fp32div_label_1753:
0071E:      	R0=		AR
            
0071F:      	AR=		AX
00720:      	AR=		AR - CX
00721:      	AR=		DX
00722:      	AR=		AR - BX + C - 1
00723:      	test		AR.b15
00724:      	if ZR jmp	@sfx_fp32div_label_1638
            
            	; ~~ need extra bits on a's mantissa
            
00725:      	slz		AX, 1
00726:      	slc		DX, 1
00727:      	R0--				; ~~ exponent
            @sfx_fp32div_label_1638:
            
            	; ~~ now we perform repeated substraction of float2 from float1
            
            	; ~~ result - DX:AX
            	; ~~ using 25-bit to make float more accuracy
            
00728:      	push		AX
00729:      	pop		R2
0072A:      	push		DX
0072B:      	pop		R3
0072C:      	DX=		0
0072D:      	AX=		0
0072E:      	P1=		25
0072F:      	push		R0
            @sfx_fp32div_loop_1642:
00730:      	slz		AX, 1
00731:      	slc		DX, 1
            
            	; ~~ mant1 < mant2
00732:      		AR=		R2
00733:      		R0=		AR
00734:      		AR=		R3
00735:      		R1=		AR
00736:      		AR=		CX
00737:      		R0=		R0 - AR
00738:      		AR=		BX
00739:      		R1=		R1 - AR + C - 1
0073A:      		test		R1.b15
0073B:      		if NZ jmp	@sfx_fp32div_label_1651
            
            	; result |= mask
0073C:      		set		AX.b7
            
            	; mant1 -= mant2
0073D:      		AR=		CX
0073E:      		R2=		R2 - AR
0073F:      		AR=		BX
00740:      		R3=		R3 - AR + C - 1
            @sfx_fp32div_label_1651:
            
            	; mantl <<= 1;
00741:      		slz		R2, 1
00742:      		slc		R3, 1
            
00743:      	P1--
00744:      	if NZ jmp	@sfx_fp32div_loop_1642
00745:      	pop		R0
            
            @sfx_fp32div_label_0921:
            
00746:      	call		sfx_Normalize_DA_FS
00747:      	jmp		sfx_RoundRet_DA_FS
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    internal                     ~~ ;
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            
            sfx_FP32CMPU32:
00748:      	clr		DX.b15
00749:      	clr		BX.b15
0074A:      	AR=		AX
0074B:      	SF=		AR - CX
0074C:      	if NE jmp	@sfx_fp32cmpu32_label_1615
0074D:      	AR=		DX
0074E:      	SF=		AR - BX
0074F:      	if NE jmp	@sfx_fp32cmpu32_label_1615
            
00750:      	set		Z
00751:      	rets
            @sfx_fp32cmpu32_label_1615:
00752:      	clr		Z
00753:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            sfx_FP32CHKZERO:
00754:      	AR=		AX
00755:      	AR=		AR | CX
00756:      	if NZ jmp	@sfx_fp32chkzero_label_1620
00757:      	AR=		DX
00758:      	AR=		AR | BX
00759:      	clr		AR.b15
0075A:      	if NZ jmp	@sfx_fp32chkzero_label_1620
0075B:      	set		Z
0075C:      	rets
            @sfx_fp32chkzero_label_1620:
0075D:      	clr		Z
0075E:      	rets
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; DX:AX  <-->   BX:CX
            
            sfx_FP32SWAP:
0075F:      	push		AX
00760:      	push		DX
00761:      	push		CX
00762:      	push		BX
00763:      	pop		DX
00764:      	pop		AX
00765:      	pop		BX
00766:      	pop		CX
00767:      	rets
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    subcc                        ~~ ;
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : EQU
            ;                 0 : not EQU
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JE:
00768:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JE:
00769:      	call		sfx_FP32CHKZERO
0076A:      	if ZR jmp	@sfx_fp32equ_label_1622
0076B:      	call		sfx_FP32CMPU32
0076C:      	if ZR jmp	@sfx_fp32equ_label_1622
0076D:      	clr		Z
0076E:      	rets
            @sfx_fp32equ_label_1622:
0076F:      	set		Z
00770:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : >
            ;                 0 : <=
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JG:
            sfx_CMPFP32_BCDA_JA:
00771:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JG:
            sfx_CMPFP32_JA:
            	; ~~ backup sign bit
00772:      	R0=		0
00773:      	AR=		DX
00774:      	slz		AR, 1
00775:      	slc		R0, 1
00776:      	AR=		BX
00777:      	slz		AR, 1
00778:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
00779:      	call		sfx_FP32CHKZERO
0077A:      	if ZR jmp	@sfx_cmpfp32_jg_label_1641
0077B:      	call		sfx_FP32CMPU32
0077C:      	if ZR jmp	@sfx_cmpfp32_jg_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
0077D:      	AR=		R0
0077E:      	if EQ jmp	@sfx_comfp32_jg_label_1645
0077F:      	SF=		AR - 3
00780:      	if EQ jmp	@sfx_comfp32_jg_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
00781:      	SF=		AR - 1
00782:      	if EQ jmp	@sfx_comfp32_jg_label_1657
            	; ~~ 2  =  -  vs  +   = <
00783:      	jmp		@sfx_cmpfp32_jg_label_1641
            @sfx_comfp32_jg_label_1645:
            	; ~~ sign bit the same
            
00784:      	AR=		CX
00785:      	AX=		AX - AR
00786:      	AR=		BX
00787:      	DX=		DX - AR + C - 1
            
00788:      	AR=		R0
00789:      	SF=		AR - 3
0078A:      	if NE jmp	@sfx_cmpfp32_jg_label_1558
0078B:      	not		DX.b15
            @sfx_cmpfp32_jg_label_1558:
0078C:      	test		DX.b15
0078D:      	if ZR jmp	@sfx_comfp32_jg_label_1657
            
            @sfx_cmpfp32_jg_label_1641:
0078E:      	clr		Z		; ~~ false
0078F:      	rets
            
            @sfx_comfp32_jg_label_1657:
00790:      	set		Z		; ~~ true
00791:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : <
            ;                 0 : >=
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JL:
            sfx_CMPFP32_BCDA_JB:
00792:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JL:
            sfx_CMPFP32_JB:
            	; ~~ backup sign bit
00793:      	R0=		0
00794:      	AR=		DX
00795:      	slz		AR, 1
00796:      	slc		R0, 1
00797:      	AR=		BX
00798:      	slz		AR, 1
00799:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
0079A:      	call		sfx_FP32CHKZERO
0079B:      	if ZR jmp	@sfx_cmpfp32_jl_label_1641
0079C:      	call		sfx_FP32CMPU32
0079D:      	if ZR jmp	@sfx_cmpfp32_jl_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
0079E:      	AR=		R0
0079F:      	if EQ jmp	@sfx_comfp32_jl_label_1645
007A0:      	SF=		AR - 3
007A1:      	if EQ jmp	@sfx_comfp32_jl_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
007A2:      	SF=		AR - 1
007A3:      	if EQ jmp	@sfx_cmpfp32_jl_label_1641
            	; ~~ 2  =  -  vs  +   = <
007A4:      	jmp		@sfx_comfp32_jl_label_1657
            
            @sfx_comfp32_jl_label_1645:
            	; ~~ sign bit the same
            
007A5:      	AR=		CX
007A6:      	AX=		AX - AR
007A7:      	AR=		BX
007A8:      	DX=		DX - AR + C - 1
            
007A9:      	AR=		R0
007AA:      	SF=		AR - 3
007AB:      	if NE jmp	@sfx_cmpfp32_jl_label_1558
007AC:      	not		DX.b15
            @sfx_cmpfp32_jl_label_1558:
007AD:      	test		DX.b15
007AE:      	if NZ jmp	@sfx_comfp32_jl_label_1657
            
            @sfx_cmpfp32_jl_label_1641:
007AF:      	clr		Z		; ~~ false
007B0:      	rets
            
            @sfx_comfp32_jl_label_1657:
007B1:      	set		Z		; ~~ true
007B2:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP32_JNE:
007B3:      	call		sfx_CMPFP32_JE
007B4:      	if ZR jmp	@sfx_cmpfp32_jne_label_false
007B5:      	set		Z
007B6:      	rets
            @sfx_cmpfp32_jne_label_false:
007B7:      	clr		Z
007B8:      	rets
            
            
            ; --------------------------
            ; BX:CX		- in (fp32)
            ; DX:AX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JNE:
007B9:      	call		sfx_CMPFP32_BCDA_JE
007BA:      	if ZR jmp	@sfx_cmpfp32_bcda_jne_label_false
007BB:      	set		Z
007BC:      	rets
            @sfx_cmpfp32_bcda_jne_label_false:
007BD:      	clr		Z
007BE:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : <=
            ;                 0 : >
            ; --------------------------
            
            sfx_CMPFP32_JLE:
            sfx_CMPFP32_JBE:
007BF:      	call		sfx_CMPFP32_JG
007C0:      	if ZR jmp	@sfx_cmpfp32_jle_label_false
007C1:      	set		Z
007C2:      	rets
            @sfx_cmpfp32_jle_label_false:
007C3:      	clr		Z
007C4:      	rets
            
            
            sfx_CMPFP32_BCDA_JLE:
            sfx_CMPFP32_BCDA_JBE:
007C5:      	call		sfx_CMPFP32_BCDA_JG
007C6:      	if ZR jmp	@sfx_cmpfp32_bcda_jle_label_false
007C7:      	set		Z
007C8:      	rets
            @sfx_cmpfp32_bcda_jle_label_false:
007C9:      	clr		Z
007CA:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : >=
            ;                 0 : <
            ; --------------------------
            
            sfx_CMPFP32_JGE:
            sfx_CMPFP32_JAE:
007CB:      	call		sfx_CMPFP32_JL
007CC:      	if ZR jmp	@sfx_cmpfp32_jge_label_false
007CD:      	set		Z
007CE:      	rets
            @sfx_cmpfp32_jge_label_false:
007CF:      	clr		Z
007D0:      	rets
            
            
            sfx_CMPFP32_BCDA_JGE:
            sfx_CMPFP32_BCDA_JAE:
007D1:      	call		sfx_CMPFP32_BCDA_JL
007D2:      	if ZR jmp	@sfx_cmpfp32_bcda_jge_label_false
007D3:      	set		Z
007D4:      	rets
            @sfx_cmpfp32_bcda_jge_label_false:
007D5:      	clr		Z
007D6:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; --------------------------
            sfx_FP32NEG:
007D7:      	not		DX.b15
007D8:      	rets
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\FP32RT.ASM> End=========================
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\FP16RT.ASM> Start=========================
            
            ; ~~-----------------------------------------------------
            ; half precision number (16-bit) float point support for DSP
            ; -------------------------------------------------------
            
            ; -------------------------------------------------------
            ; -------------------------------------------------------
            
            ; +-----------------------------------------------------+
            ; | AX (CX)                                             |
            ; +------+---------------+------------------------------+
            ; |  0   | 4  3  2  1  0 | 9  8  7  6  5  4  3  2  1  0 |
            ; +------+---------------+------------------------------+
            ; | sign | e  e  e  e  e | m  m  m  m  m  m  m  m  m  m |
            ; +------+----------------------------------------------+
            ;    15   14 13 12 11 10   9  8  7  6  5  4  3  2  1  0
            
            
            
            ; ~~ float -> sign / exp / mantissa
            
            ; ~~ AX / CX - mantissa
            
            ; +-------------------------------------------------+
            ; | AX (CX)                                         |
            ; +---+---------------------------------------------+
            ; | 1 | m  m  m  m  m  m  m  m  m  m  0  0  0  0  0 |
            ; +---+---------------------------------------------+
            ;   H   9  8  7  6  5  4  3  2  1  0  -  -  -  -  -
            ;
            
            ; ~~ R0    / R1    - sign and exp
            ; +------------------------+---------+---------------+
            ; | S  -  -  -  -  -  -  - | 0  0  0 | e  e  e  e  e |
            ; +------------------------+---------+---------------+
            ;  15 14 13 12 11 10  9  8   7  6  5   4  3  2  1  0
            
            ; ~~ --
            
            sfx_GETARG_ANS_FP16:
007D9:      	AR=		AX
007DA:      	xchg		AR
007DB:      	sra		AR, 2
007DC:      	AR=		AR & 0x1F
007DD:      	R0=		AR
007DE:      	test		AX.b15
007DF:      	if ZR jmp	@sfx_getarg_aFP16_label_1736
007E0:      	set		R0.b15
            @sfx_getarg_aFP16_label_1736:
007E1:      	AR=		0x03FF
007E3:      	AX=		AX & AR
007E4:      	set		AX.b10		; ~~ HIDDEN 1
007E5:      	rets
            
            
            sfx_GETARG_A_FP16:
007E6:      	call		sfx_GETARG_ANS_FP16
007E7:      	slz		AX, 2
007E8:      	slz		AX, 2
007E9:      	slz		AX, 1
007EA:      	rets
            
            ; ~~ -----------
            
            ; ~~ --
            
            sfx_GETARG_CNS_FP16:
007EB:      	AR=		CX
007EC:      	xchg		AR
007ED:      	sra		AR, 2
007EE:      	AR=		AR & 0x1F
007EF:      	R1=		AR
007F0:      	test		CX.b15
007F1:      	if ZR jmp	@sfx_getarg_cFP16_label_1736
007F2:      	set		R1.b15
            @sfx_getarg_cFP16_label_1736:
007F3:      	AR=		0x03FF
007F5:      	CX=		CX & AR
007F6:      	set		CX.b10		; ~~ HIDDEN 1
007F7:      	rets
            
            
            sfx_GETARG_C_FP16:
007F8:      	call		sfx_GETARG_CNS_FP16
007F9:      	slz		CX, 2
007FA:      	slz		CX, 2
007FB:      	slz		CX, 1
007FC:      	rets
            
            ; ~~ -----------
            ; ~~ AX    - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_Normalize_A_FP16:
            ; {
007FD:      	push		CX
007FE:      	CX=		15
            @sfx_normalize_aFP16_loop_1609:
007FF:      	test		AX.b15
00800:      	if NZ jmp	@sfx_normalize_aFP16_label_1609
00801:      	slz		AX, 1
00802:      	R0--
00803:      	AR=		R0
00804:      	clr		AR.b15
00805:      	if ZR jmp	@sfx_normalize_aFP16_label_1609
00806:      	loop		@sfx_normalize_aFP16_loop_1609
            @sfx_normalize_aFP16_label_1609:
00807:      	pop		CX
00808:      	rets
            ; }
            
            
            ; ~~ AX    - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_RoundRet_A_FP16:
            ; {
            	; ~~ for register save
            
            	; ~~ round lowest 5-bit to increase accuracy ??
            
            	; AR=		AX
            	; AR=		AR & 0x1F
            	; AR=		AR - 0x0F
            	; if LE jmp	@sfx_roundret_aFP16_label_1033
            
            	; test		AX.b5
            	; if ZR jmp	@sfx_roundret_aFP16_label_1033
            
            	; ~~ +1
            
00809:      	AR=		0x10
0080A:      	AX=		AX + AR
0080B:      	if NC jmp	@sfx_roundret_aFP16_label_1033
            	; ~~ overflow
0080C:      	AX.h=		0x80
0080D:      	R0++
            @sfx_roundret_aFP16_label_1033:
0080E:      	AR=		0xFFE0
00810:      	AR=		AR & AX
00811:      	if NZ jmp	sfx_DirectRet_A_FP16
            
            sfx_RetZero_A_FP16:
            	; ~~ float 0.0
00812:      	AX=		0
00813:      	rets
            
            
            sfx_DirectRet_A_FP16:
            	; ~~ drop 1-bit  (1.xxx)
00814:      	slz		AX, 1
            
            	; 5-bit exp
            
00815:      	AR=		R0
00816:      	sra		AR, 2
00817:      	src		AX, 2
00818:      	sra		AR, 2
00819:      	src		AX, 2
0081A:      	sra		AR, 1
0081B:      	src		AX, 1
            
            	; ~~ sign bit (sra duplicate)
            
0081C:      	slz		AR, 1
0081D:      	src		AX, 1
0081E:      	rets
            
            sfx_ReturnINF_A_FP16:
0081F:      	AX=		0xF800
00821:      	AR=		R0
00822:      	slz		AR, 1
00823:      	src		AX, 1
00824:      	rets
            
            sfx_ReturnNaN_A_FP16:
00825:      	AX=		0x7E00
00827:      	rets
            ; }
            
            
            
            ; --------------------------
            ; ~~ int type -> float point
            ; --------------------------
            
            
            ; --------------------------
            ; DX:AX		- in  (long)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_LONGTOFP16:
00828:      	R0=		0x001E		; ~~ E+15
            
            ; sfx_LONG2FP16_CORE:
00829:      	test		DX.b15
0082A:      	if ZR jmp	@sfx_long2FP16_label_1416
            
            	; ~~ make it positive if value is negative
            
0082B:      	set		R0.b15		; ~~ sign
0082C:      	AR=		0
0082D:      	AX=		AR - AX
0082E:      	DX=		AR - DX + C - 1
            
            @sfx_long2FP16_label_1416:
            	; ~~ check INF
0082F:      	AR=		DX
00830:      	if NZ jmp	sfx_ReturnINF_A_FP16
00831:      	call		sfx_Normalize_A_FP16
00832:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_LONGTOFP16_CX:
00833:      	call		sfx_FP16SWAP
00834:      	call		sfx_LONGTOFP16
00835:      	call		sfx_FP16SWAP
00836:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in  (unsigned long)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_ULONGTOFP16:
            ; {
00837:      	R0=		0x001E		; ~~ E+31
            ; sfx_ULONG2FP16_CORE:
00838:      	AR=		DX
00839:      	if NZ jmp	sfx_ReturnINF_A_FP16
0083A:      	call		sfx_Normalize_A_FP16
0083B:      	jmp		sfx_RoundRet_A_FP16
            ; }
            
            ; --------------------------
            
            sfx_ULONGTOFP16_CX:
0083C:      	call		sfx_FP16SWAP
0083D:      	call		sfx_ULONGTOFP16
0083E:      	call		sfx_FP16SWAP
0083F:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_INTTOFP16:
00840:      	R0=		0x001E		; ~~ E+15
            
            ; sfx_INT2FS_CORE:
00841:      	test		AX.b15
00842:      	if ZR jmp	@sfx_int2FP16_label_1004
            
00843:      	set		R0.b15
00844:      	AR=		0
00845:      	AX=		AR - AX
            @sfx_int2FP16_label_1004:
00846:      	call		sfx_Normalize_A_FP16
00847:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_INTTOFP16_CX:
00848:      	call		sfx_FP16SWAP
00849:      	call		sfx_INTTOFP16
0084A:      	call		sfx_FP16SWAP
0084B:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; AX		- out (fp32)
            ; --------------------------
            sfx_UINTTOFP16:
0084C:      	R0=		0x001E		; ~~ E+15
0084D:      	call		sfx_Normalize_A_FP16
0084E:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_UINTTOFP16_CX:
0084F:      	call		sfx_FP16SWAP
00850:      	call		sfx_UINTTOFP16
00851:      	call		sfx_FP16SWAP
00852:      	rets
            
            ; ~~--------------------------------------------------------------------
            
            ; --------------------------
            ; AX    - mantissa
            ; R0    - sign & exp
            ; CX    - shift count
            ; --------------------------
            sfx_RSHIFT_A:
            	; ~~ check if 0 shift count
            
00853:      	if ZR jmp	@sfx_rshifta_label_1132
            
            	; ~~ adjust exp
00854:      	push		CX
00855:      	CX=		AR
00856:      	AR=		AR + R0
00857:      	test		AR.b5
00858:      	if ZR jmp	@sfx_rshifta_label_1333
            
00859:      	AR=		R0
0085A:      	AL=		0x1F
            
            @sfx_rshifta_label_1333:
0085B:      	R0=		AR
0085C:      	jmp		@sfx_rshifta_label_1335
            @sfx_rshifta_loop_1335:
0085D:      	clr		C
0085E:      	src		AX, 1
            @sfx_rshifta_label_1335:
0085F:      	loop		@sfx_rshifta_loop_1335
00860:      	pop		CX
            @sfx_rshifta_label_1132:
00861:      	rets
            
            
            ; ~~--
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (long)
            ; --------------------------
            sfx_FP16TOLONG:
00862:      	call		sfx_GETARG_A_FP16
00863:      	AR=		0x001E
00864:      	AR=		AR - R0
00865:      	test		AR.b5
00866:      	if NZ jmp	@sfx_FP162long_label_1709		; ~~ |X| >= 2^16
            
            	; ~~ lowest 5-bit already zero
            
00867:      	AH=		0
00868:      	CX=		AR
00869:      	call		sfx_RSHIFT_A
            
0086A:      	DX=		0
            
0086B:      	test		R0.b15
0086C:      	if ZR jmp	@sfx_FP162long_label_1339
            
            	; ~~ negative
            
0086D:      	AR=		0
0086E:      	AX=		AR - AX
0086F:      	AR=		AR - 0 + C - 1
            
            	; ~~ x < -0x80000000
00870:      	if AN jmp	@sfx_FP162long_label_1420
00871:      	rets
            
            @sfx_FP162long_label_1339:
            	; ~~ postive
00872:      	test		DX.b15
00873:      	if NZ jmp	@sfx_FP162long_label_1421
00874:      	rets
            
            @sfx_FP162long_label_1709:
            	; ~~ fs2slong_maxval
00875:      	test		R0.b15
00876:      	if ZR jmp	@sfx_FP162long_label_1421
            
            @sfx_FP162long_label_1420:
            	; ~~ check sign bit
00877:      	test		DX.b15
00878:      	if ZR jmp	@sfx_FP162long_label_1118
00879:      	rets
            @sfx_FP162long_label_1118:
            	; ~~ fs2slong_maxval_neg
0087A:      	AX=		0
0087B:      	DX=		0x8000
0087D:      	rets
            
            @sfx_FP162long_label_1421:
            	; ~~ fs2long_maxval_pos
0087E:      	AX=		0xFFFF
00880:      	DX=		0x7FFF
00882:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOLONG_CX:
00883:      	call		sfx_FP16SWAP
00884:      	call		sfx_FP16TOLONG
00885:      	call		sfx_FP16SWAP
00886:      	rets
            
            ; ~~--
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP16TOULONG:
00887:      	call		sfx_GETARG_A_FP16
00888:      	DX=		0
00889:      	test		R0.b15
0088A:      	if ZR jmp	@sfx_FP162ulong_label_1536
            
            	; ~~ return 0
0088B:      	AX=		0
0088C:      	rets
            
            @sfx_FP162ulong_label_1536:
            	; ~~ fs2ulong_int
            
0088D:      	AR=		0x001E
0088E:      	AR=		AR - R0
0088F:      	test		AR.b5
00890:      	if ZR jmp	@sfx_FP162ulong_label_1541
            
            	; ~~ x >= 2^16
            
00891:      	AX=		0xFF		; ~~ 0xFFFF
00892:      	DX=		0xFF		; ~~ 0xFFFF
00893:      	rets
            
            @sfx_FP162ulong_label_1541:
00894:      	AH=		0
00895:      	CX=		AR
00896:      	call		sfx_RSHIFT_A
00897:      	rets
            
            ; --------------------------
            
            sfx_FP16TOULONG_CX:
00898:      	call		sfx_FP16SWAP
00899:      	call		sfx_FP16TOULONG
0089A:      	call		sfx_FP16SWAP
0089B:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (short)
            ; --------------------------
            sfx_FP16TOINT:
0089C:      	call		sfx_GETARG_A_FP16
0089D:      	AR=		0x001E
0089E:      	AR=		AR - R0
0089F:      	test		AR.b5
008A0:      	if NZ jmp	@sfx_FP162int_label_1709		; ~~ |X| >= 2^16
            
            	; ~~ lowest 5-bit already zero
            
008A1:      	AH=		0
008A2:      	CX=		AR
008A3:      	call		sfx_RSHIFT_A
            
008A4:      	test		R0.b15
008A5:      	if ZR jmp	@sfx_FP162int_label_1339
            
            	; ~~ negative
            
008A6:      	AR=		0
008A7:      	AX=		AR - AX
008A8:      	if NZ jmp	@sfx_FP162int_label_1406
008A9:      	rets
            @sfx_FP162int_label_1406:
008AA:      	test		AX.b15
008AB:      	if ZR jmp	@sfx_FP162int_label_1420
008AC:      	rets
            
            @sfx_FP162int_label_1339:
            	; ~~ postive
008AD:      	test		AX.b15
008AE:      	if NZ jmp	@sfx_FP162int_label_1421
008AF:      	rets
            
            
            @sfx_FP162int_label_1709:
            	; ~~ fs2slong_maxval
008B0:      	test		R0.b15
008B1:      	if ZR jmp	@sfx_FP162int_label_1421
            
            @sfx_FP162int_label_1420:
            	; ~~ FP162int_maxval_neg
008B2:      	AX=		0x8000
008B4:      	rets
            
            @sfx_FP162int_label_1421:
            	; ~~ FP162int_maxval_pos
008B5:      	AX=		0x7FFF
008B7:      	rets
            
            ; --------------------------
            
            sfx_FP16TOINT_CX:
008B8:      	call		sfx_FP16SWAP
008B9:      	call		sfx_FP16TOINT
008BA:      	call		sfx_FP16SWAP
008BB:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP16TOUINT:
008BC:      	call		sfx_GETARG_A_FP16
008BD:      	test		R0.b15
008BE:      	if ZR jmp	@sfx_FP162uint_label_1536
            
            	; ~~ return 0
008BF:      	AX=		0
008C0:      	rets
            
            @sfx_FP162uint_label_1536:
            	; ~~ fs2ulong_int
            
008C1:      	AR=		0x001E
008C2:      	AR=		AR - R0
008C3:      	test		AR.b5
008C4:      	if ZR jmp	@sfx_FP162uint_label_1541
            
            	; ~~ x >= 2^16
            
008C5:      	AX=		0xFF		; ~~ 0xFFFF
008C6:      	rets
            
            @sfx_FP162uint_label_1541:
008C7:      	AH=		0
008C8:      	CX=		AR
008C9:      	call		sfx_RSHIFT_A
008CA:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOUINT_CX:
008CB:      	call		sfx_FP16SWAP
008CC:      	call		sfx_FP16TOUINT
008CD:      	call		sfx_FP16SWAP
008CE:      	rets
            
            
            ; ~~-------------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (fp32)
            ; ~~-------------------------------
            sfx_FP16TOFP32:
            	; ~~ wait code .....  NaN / INF check
            
008CF:      	call		sfx_GETARG_A_FP16
008D0:      	AR=		0x70
008D1:      	R0=		R0 + AR
            
            	; ~~ drop hidden 1
008D2:      	slz		AX, 1
            
008D3:      	AR=		AX
008D4:      	DX=		AR
008D5:      	AX=		0
            
            	; ~~ generate fp32 format
            
008D6:      	AR=		R0
008D7:      	sra		AR, 2
008D8:      	src		DX, 2
008D9:      	src		AX, 2
008DA:      	sra		AR, 2
008DB:      	src		DX, 2
008DC:      	src		AX, 2
008DD:      	sra		AR, 2
008DE:      	src		DX, 2
008DF:      	src		AX, 2
008E0:      	sra		AR, 2
008E1:      	src		DX, 2
008E2:      	src		AX, 2
            	; ~~ sign bit (sra duplicate)
008E3:      	slz		AR, 1
008E4:      	src		DX, 1
008E5:      	src		AX, 1
008E6:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOFP32_CX:
008E7:      	call		sfx_FP16SWAP
008E8:      	call		sfx_FP16TOFP32
008E9:      	call		sfx_FP16SWAP
008EA:      	rets
            
            
            ; -------------------------------------------
            ; ~~ swap two fp16 value
            ; R0:AX  <-> R1:CX
            ; -------------------------------------------
            
            sfx_FP16SWAP_AB:
008EB:      	push		R0
008EC:      	push		R1
008ED:      	pop		R0
008EE:      	pop		R1
008EF:      	push		AX
008F0:      	push		CX
008F1:      	pop		AX
008F2:      	pop		CX
008F3:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            
            sfx_FP16ADD:
008F4:      	call		sfx_GETARG_A_FP16
008F5:      	call		sfx_GETARG_C_FP16
            
            	; ~~ which exponent is greater ?
            
008F6:      	AR=		R1
008F7:      	push		R0
008F8:      	pop		R2
008F9:      	clr		AR.b15
008FA:      	clr		R2.b15
008FB:      	SF=		AR - R2
008FC:      	if GE jmp	@sfx_fp16add_label_1043
            
008FD:      	call		sfx_FP16SWAP_AB
            
            @sfx_fp16add_label_1043:
008FE:      	AR=		R1
008FF:      	push		R0
00900:      	pop		R2
00901:      	clr		AR.b15
00902:      	clr		R2.b15
00903:      	AR=		AR - R2
00904:      	call		sfx_RSHIFT_A
            
            	; ~~ decide if we need to add or subtract
            
00905:      	AR=		R0
00906:      	AR=		AR ^ R1
00907:      	slz		AR, 1
00908:      	if AC jmp	@sfx_fp16add_label_1714
            
            	; ~~ add the mantissa (both positive or both negative)
            
00909:      	AR=		CX
0090A:      	AX=		AX + AR
0090B:      	if NC jmp	@sfx_fp16add_label_1718
0090C:      	AR=		1
0090D:      	call		sfx_RSHIFT_A
0090E:      	set		AX.b15			; ~~ hidden 1
            @sfx_fp16add_label_1718:
0090F:      	jmp		@sfx_fp16add_label_1720
            
            @sfx_fp16add_label_1714:
            
            	; ~~ subtract the mantissa (one of them is negative)
            
00910:      	AR=		CX
00911:      	AX=		AX - AR
00912:      	AR=		0
00913:      	AR=		AR - 0 + C - 1
00914:      	if AC jmp	@sfx_fp16add_label_1720
            
00915:      	AR=		0
00916:      	AX=		AR - AX
00917:      	not		R0.b15
            @sfx_fp16add_label_1720:
00918:      	call		sfx_Normalize_A_FP16
00919:      	jmp		sfx_RoundRet_A_FP16
            
            ; ~~ --
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            
            sfx_FP16SUB:
0091A:      	not		CX.b15
0091B:      	jmp		sfx_FP16ADD
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_FP16MUL:
            	; ~~ first check if either input is zero
            
0091C:      	AR=		AX
0091D:      	if ZR jmp	sfx_RetZero_A_FP16
0091E:      	AR=		CX
0091F:      	if ZR jmp	sfx_RetZero_A_FP16
            
00920:      	call		sfx_GETARG_A_FP16
00921:      	call		sfx_GETARG_C_FP16
            
            	; ~~ compare final sign bit
            
00922:      	test		R1.b15
00923:      	if ZR jmp	@sfx_fp16mul_label_1410
            
00924:      	not		R0.b15
            @sfx_fp16mul_label_1410:
            
            	; ~~ check if either input is infinity
            
00925:      	AR=		R1
00926:      	clr		AR.b15
00927:      	SF=		AR - 0x1F
00928:      	if EQ jmp	sfx_ReturnINF_A_FP16
            
00929:      	AR=		R0
0092A:      	clr		AR.b15
0092B:      	SF=		AR - 0x1F
0092C:      	if EQ jmp	sfx_ReturnINF_A_FP16
            
            	; ~~ add the exponent
            
0092D:      	AR=		R1
0092E:      	clr		AR.b15
0092F:      	AR=		AR + R0
00930:      	test		AR.b5
00931:      	if NZ jmp	@sfx_fp16mul_label_1413
            
            	; ~~ + 17 ??
            
00932:      	AR=		AR - 14
00933:      	test		AR.b5
00934:      	if ZR jmp	@sfx_fp16mul_label_1501
            
00935:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16mul_label_1413:
            
00936:      	AR=		AR - 14
00937:      	test		AR.b5
00938:      	if ZR jmp	@sfx_fp16mul_label_1501
            
00939:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16mul_label_1501:
0093A:      	R0=		AR
            
            	; ~~ unsigned multiplay (32-bit)
0093B:      	PCH=		sfx_MUL_AX_CX
0093C:      	lcall		sfx_MUL_AX_CX
            
            	; ~~ drop 16-bit
0093D:      	AR=		DX
0093E:      	AX=		AR
            
0093F:      	test		AX.b15
00940:      	if NZ jmp	@sfx_fs16mul_label_1531
            
00941:      	call		sfx_Normalize_A_FP16
            @sfx_fs16mul_label_1531:
00942:      	jmp		sfx_RoundRet_A_FP16
            
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_FP16DIV:
            	; ~~ compare final sign bit
            
00943:      	test		CX.b15
00944:      	if ZR jmp	@sfx_fp16div_label_1629
            
00945:      	not		AX.b15
            @sfx_fp16div_label_1629:
            
            	; ~~ if divisor is zero, ...
00946:      	AR=		CX
00947:      	if NZ jmp	@sfx_fp16div_label_1639
            	; ~~ if dividend is also zero, return NaN
00948:      	AR=		AX
00949:      	if NZ jmp	@sfx_fp16div_label_1641
0094A:      	jmp		sfx_ReturnNaN_A_FP16
            @sfx_fp16div_label_1641:
            	; ~~ but dividend is non-zero, return infinity
0094B:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16div_label_1639:
            	; ~~ if dividend is zero, return zero
0094C:      	AR=		AX
0094D:      	if NZ jmp	@sfx_fp16div_label_1644
0094E:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16div_label_1644:
0094F:      	call		sfx_GETARG_ANS_FP16
00950:      	call		sfx_GETARG_CNS_FP16
            
            	; ~~ if divisor is infinity, ...
00951:      	AR=		R1
00952:      	AH=		0
00953:      	SF=		AR - 0x1F
00954:      	if NE jmp	@sfx_fp16div_label_1646
00955:      	AR=		R0
00956:      	AH=		0
00957:      	SF=		AR - 0x1F
00958:      	if NE jmp	@sfx_fp16div_label_1647
00959:      	jmp		sfx_ReturnNaN_A_FP16
            @sfx_fp16div_label_1647:
0095A:      	jmp		sfx_RetZero_A_FP16
            
            @sfx_fp16div_label_1646:
            	; ~~ subtract exponents
            
0095B:      	AR=		R1
0095C:      	clr		AR.b15
0095D:      	AR=		R0 - AR
0095E:      	test		AR.b5
0095F:      	if ZR jmp	@sfx_fp16div_label_1649
            
00960:      	AR=		AR + 15
00961:      	test		AR.b5
00962:      	if ZR jmp	@sfx_fp16div_label_1753
00963:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16div_label_1649:
            
00964:      	AR=		AR + 15
00965:      	test		AR.b5
00966:      	if ZR jmp	@sfx_fp16div_label_1753
00967:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16div_label_1753:
00968:      	R0=		AR
            
            	; ~~ unsigned check !!
            
00969:      	AR=		AX
0096A:      	AR=		AR - CX
0096B:      	test		AR.b15
0096C:      	if ZR jmp	@sfx_fp16div_label_1638
            
0096D:      	slz		AX, 1
0096E:      	R0--				; ~~ exponent
            
            @sfx_fp16div_label_1638:
            
            	; ~~ now we perform repeated substraction of float2 from float1
            
            	; ~~ result - AX
            	; ~~ using 12-bit to make float more accuracy
            
0096F:      	push		AX
00970:      	pop		DX
00971:      	AX=		0
00972:      	P1=		12
            @sfx_fp16div_loop_1642:
00973:      	slz		AX, 1
            
            	; ~~ mant1 < mant2
00974:      		AR=		DX
00975:      		R2=		AR
00976:      		AR=		CX
00977:      		R2=		R2 - AR
00978:      		test		R2.b15
00979:      		if NZ jmp	@sfx_fp16div_label_1651
            
            	; result |= mask;
0097A:      		set		AX.b4
            
            	; mant1 -= mant2
0097B:      		AR=		CX
0097C:      		DX=		DX - AR
            @sfx_fp16div_label_1651:
            
            	; mant1 <<= 1;
0097D:      		slz		DX, 1
            
0097E:      	P1--
0097F:      	if NZ jmp	@sfx_fp16div_loop_1642
            
00980:      	call		sfx_Normalize_A_FP16
00981:      	jmp		sfx_RoundRet_A_FP16
            
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    internal                     ~~ ;
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            
            sfx_FP16CMPU16:
00982:      	clr		AX.b15
00983:      	clr		CX.b15
00984:      	AR=		AX
00985:      	SF=		AR - CX
00986:      	if NE jmp	@sfx_fp16cmpu16_label_1615
            
00987:      	set		Z
00988:      	rets
            @sfx_fp16cmpu16_label_1615:
00989:      	clr		Z
0098A:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            sfx_FP16CHKZERO:
0098B:      	AR=		AX
0098C:      	AR=		AR | CX
0098D:      	clr		AR.b15
0098E:      	AR=		AR + 0
0098F:      	if NZ jmp	@sfx_fp16chkzero_label_1620
00990:      	set		Z
00991:      	rets
            @sfx_fp16chkzero_label_1620:
00992:      	clr		Z
00993:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX  <-->   CX
            
            sfx_FP16SWAP:
00994:      	push		AX
00995:      	push		CX
00996:      	pop		AX
00997:      	pop		CX
00998:      	rets
            
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    subcc                        ~~ ;
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : EQU
            ;                 0 : not EQU
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JE:
00999:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JE:
0099A:      	call		sfx_FP16CHKZERO
0099B:      	if ZR jmp	@sfx_fp16equ_label_1622
0099C:      	call		sfx_FP16CMPU16
0099D:      	if ZR jmp	@sfx_fp16equ_label_1622
0099E:      	clr		Z
0099F:      	rets
            @sfx_fp16equ_label_1622:
009A0:      	set		Z
009A1:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : >
            ;                 0 : <=
            ; --------------------------
            sfx_CMPFP16_CX_AX_JG:
            sfx_CMPFP16_CX_AX_JA:
009A2:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JG:
            sfx_CMPFP16_JA:
            	; ~~ backup sign bit
009A3:      	R0=		0
009A4:      	AR=		AX
009A5:      	slz		AR, 1
009A6:      	slc		R0, 1
009A7:      	AR=		CX
009A8:      	slz		AR, 1
009A9:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
009AA:      	call		sfx_FP16CHKZERO
009AB:      	if ZR jmp	@sfx_cmpfp16_jg_label_1641
009AC:      	call		sfx_FP16CMPU16
009AD:      	if ZR jmp	@sfx_cmpfp16_jg_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
009AE:      	AR=		R0
009AF:      	if EQ jmp	@sfx_comfp16_jg_label_1645
009B0:      	SF=		AR - 3
009B1:      	if EQ jmp	@sfx_comfp16_jg_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
009B2:      	SF=		AR - 1
009B3:      	if EQ jmp	@sfx_comfp16_jg_label_1657
            	; ~~ 2  =  -  vs  +   = <
009B4:      	jmp		@sfx_cmpfp16_jg_label_1641
            @sfx_comfp16_jg_label_1645:
            	; ~~ sign bit the same
            
009B5:      	AR=		CX
009B6:      	AX=		AX - AR
            
009B7:      	AR=		R0
009B8:      	SF=		AR - 3
009B9:      	if NE jmp	@sfx_cmpfp16_jg_label_1558
009BA:      	not		AX.b15
            @sfx_cmpfp16_jg_label_1558:
009BB:      	test		AX.b15
009BC:      	if ZR jmp	@sfx_comfp16_jg_label_1657
            
            @sfx_cmpfp16_jg_label_1641:
009BD:      	clr		Z		; ~~ false
009BE:      	rets
            
            @sfx_comfp16_jg_label_1657:
009BF:      	set		Z		; ~~ true
009C0:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : <
            ;                 0 : >=
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JL:
            sfx_CMPFP16_CX_AX_JB:
009C1:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JL:
            sfx_CMPFP16_JB:
            	; ~~ backup sign bit
009C2:      	R0=		0
009C3:      	AR=		AX
009C4:      	slz		AR, 1
009C5:      	slc		R0, 1
009C6:      	AR=		CX
009C7:      	slz		AR, 1
009C8:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
009C9:      	call		sfx_FP16CHKZERO
009CA:      	if ZR jmp	@sfx_cmpfp16_jl_label_1641
009CB:      	call		sfx_FP16CMPU16
009CC:      	if ZR jmp	@sfx_cmpfp16_jl_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
009CD:      	AR=		R0
009CE:      	if EQ jmp	@sfx_comfp16_jl_label_1645
009CF:      	SF=		AR - 3
009D0:      	if EQ jmp	@sfx_comfp16_jl_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
009D1:      	SF=		AR - 1
009D2:      	if EQ jmp	@sfx_cmpfp16_jl_label_1641
            	; ~~ 2  =  -  vs  +   = <
009D3:      	jmp		@sfx_comfp16_jl_label_1657
            
            @sfx_comfp16_jl_label_1645:
            	; ~~ sign bit the same
            
009D4:      	AR=		CX
009D5:      	AX=		AX - AR
            
009D6:      	AR=		R0
009D7:      	SF=		AR - 3
009D8:      	if NE jmp	@sfx_cmpfp16_jl_label_1558
009D9:      	not		AX.b15
            @sfx_cmpfp16_jl_label_1558:
009DA:      	test		AX.b15
009DB:      	if NZ jmp	@sfx_comfp16_jl_label_1657
            
            @sfx_cmpfp16_jl_label_1641:
009DC:      	clr		Z		; ~~ false
009DD:      	rets
            
            @sfx_comfp16_jl_label_1657:
009DE:      	set		Z		; ~~ true
009DF:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP16_JNE:
009E0:      	call		sfx_CMPFP16_JE
009E1:      	if ZR jmp	@sfx_cmpfp16_jne_label_false
009E2:      	set		Z
009E3:      	rets
            @sfx_cmpfp16_jne_label_false:
009E4:      	clr		Z
009E5:      	rets
            
            ; --------------------------
            ; CX		- in (fp16)
            ; AX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JNE:
009E6:      	call		sfx_CMPFP16_CX_AX_JE
009E7:      	if ZR jmp	@sfx_cmpfp16_ca_jne_label_false
009E8:      	set		Z
009E9:      	rets
            @sfx_cmpfp16_ca_jne_label_false:
009EA:      	clr		Z
009EB:      	rets
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : <=
            ;                 0 : >
            ; --------------------------
            
            sfx_CMPFP16_JLE:
            sfx_CMPFP16_JBE:
009EC:      	call		sfx_CMPFP16_JG
009ED:      	if ZR jmp	@sfx_cmpfp16_jle_label_false
009EE:      	set		Z
009EF:      	rets
            @sfx_cmpfp16_jle_label_false:
009F0:      	clr		Z
009F1:      	rets
            
            
            sfx_CMPFP16_CX_AX_JLE:
            sfx_CMPFP16_CX_AX_JBE:
009F2:      	call		sfx_CMPFP16_CX_AX_JG
009F3:      	if ZR jmp	@sfx_cmpfp16_ca_jle_label_false
009F4:      	set		Z
009F5:      	rets
            @sfx_cmpfp16_ca_jle_label_false:
009F6:      	clr		Z
009F7:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : >=
            ;                 0 : <
            ; --------------------------
            
            sfx_CMPFP16_JGE:
            sfx_CMPFP16_JAE:
009F8:      	call		sfx_CMPFP16_JL
009F9:      	if ZR jmp	@sfx_cmpfp16_jge_label_false
009FA:      	set		Z
009FB:      	rets
            @sfx_cmpfp16_jge_label_false:
009FC:      	clr		Z
009FD:      	rets
            
            
            sfx_CMPFP16_CX_AX_JGE:
            sfx_CMPFP16_CX_AX_JAE:
009FE:      	call		sfx_CMPFP16_CX_AX_JL
009FF:      	if ZR jmp	@sfx_cmpfp16_ca_jge_label_false
00A00:      	set		Z
00A01:      	rets
            @sfx_cmpfp16_ca_jge_label_false:
00A02:      	clr		Z
00A03:      	rets
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; --------------------------
            sfx_FP16NEG:
00A04:      	not		AX.b15
00A05:      	rets
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <K:\TRITAN IDE\FDSP-IDE\TOOLS\CC\CRT0\FP16RT.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00A06:      	PCH=	_WakeupProc94A410F9
00A07:      	ljmp	_WakeupProc94A410F9
            
            IntVectTable:
00A08:      	DW #EMPTY_INTENTRY
00A09:      	DW #EMPTY_INTENTRY
00A0A:      	DW #EMPTY_INTENTRY
00A0B:      	DW #EMPTY_INTENTRY
00A0C:      	DW #EMPTY_INTENTRY
00A0D:      	DW #_PWM99B23D7D
            
            // .code ends
            ;;FDSP-IDE V2.53
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
