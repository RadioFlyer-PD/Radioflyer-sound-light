            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            #define DTX_WORD_ADR		
            #define MIDIPCMDEC		
            #define _PWM_32K_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\E_CF87A0F9.S.CODE.ASM> Start=========================
            ; E.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlaySongC44FFB6D();
            ; //rjmp void _KeyPlayStop0C3B8DB1();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //rjmp void _KeyModEEAB4D5A();
            ; //rjmp void _KeySubb3A3BA54B6D();
            ; //rjmp void _KeySubb3B3F6456DA();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_A2C562ABC_0:;					
            _A2C562ABC_0:
            ; //	
            ; //_A2C562ABC_1:;					
            _A2C562ABC_1:
            ; //_A2C562ABC_2:;					
            _A2C562ABC_2:
            ; //	_InitialDA4A7CC4();			
0011D:      	pch	= _InitialDA4A7CC4
0011E:      	lcall	_InitialDA4A7CC4
            ; //_A2C562ABC_3:;					
            _A2C562ABC_3:
            ; //_A2C562ABC_4:;					
            _A2C562ABC_4:
            ; //	_InitKey3C587B6D();			
0011F:      	pch	= _InitKey3C587B6D
00120:      	lcall	_InitKey3C587B6D
            ; //_A2C562ABC_5:;					
            _A2C562ABC_5:
            ; //	asm set io[0x06].b0;			
00121:      	set io[0x06].b0//
            ; //_A2C562ABC_6:;					
            _A2C562ABC_6:
            ; //	asm set io[0x06].b1;			
00122:      	set io[0x06].b1//
            ; //_A2C562ABC_7:;					
            _A2C562ABC_7:
            ; //	asm clr io[0x09].b0;			
00123:      	clr io[0x09].b0//
            ; //_A2C562ABC_8:;					
            _A2C562ABC_8:
            ; //	asm clr io[0x09].b1;			
00124:      	clr io[0x09].b1//
            ; //_A2C562ABC_9:;					
            _A2C562ABC_9:
            ; //_A2C562ABC_10:;					
            _A2C562ABC_10:
            ; //	ChangePWMIntToDynCache();		
00125:      	pch	= ChangePWMIntToDynCache
00126:      	lcall	ChangePWMIntToDynCache
            ; //_A2C562ABC_11:;					
            _A2C562ABC_11:
            ; //_A2C562ABC_12:;					
            _A2C562ABC_12:
            ; //	dtxInitialize();			
00127:      	pch	= dtxInitialize
00128:      	lcall	dtxInitialize
            ; //LF66E16C1_5:;					
            LF66E16C1_5:
            ; //_A2C562ABC_13:;					
            _A2C562ABC_13:
            ; //_A2C562ABC_14:;					
            _A2C562ABC_14:
            ; //	asm AX = #melody+0;			
00129:      	AX = #melody+0//
            ; //	asm DX = #melody.n2			
0012B:      	DX = #melody.n2
            ; //	asm set DX.b11				
0012C:      	set DX.b11
            ; //	PUSH(sDX);				
0012D:      	push	DX
            ; //	PUSH(sAX);				
0012E:      	push	AX
            ; //	_dtxFindToneEntry12F3B4ED(STACK[sSP + 0], STACK[sSP + 1]);
0012F:      	pch	= _dtxFindToneEntry12F3B4ED
00130:      	lcall	_dtxFindToneEntry12F3B4ED
            ; //	RESTORESP(2);				
00131:      	pop	AR
00132:      	pop	AR
            ; //	sfx_CHECKZERO();			
00133:      	AR	= AX
            ; //	if(__jz__)	goto LF66E16C1_6;	
00134:      	if ZR	jmp LF66E16C1_6
            ; //	goto	LF66E16C1_4;			
00135:      	jmp	LF66E16C1_4
            ; //LF66E16C1_6:;					
            LF66E16C1_6:
            ; //	
            ; //LF66E16C1_8:;					
            LF66E16C1_8:
            ; //_A2C562ABC_15:;					
            _A2C562ABC_15:
            ; //_A2C562ABC_16:;					
            _A2C562ABC_16:
            ; //	goto LF66E16C1_8;			
00136:      	jmp	LF66E16C1_8
            ; //LF66E16C1_7:;					
            LF66E16C1_7:
            ; //_A2C562ABC_17:;					
            _A2C562ABC_17:
            ; //	goto LF66E16C1_5;			
00137:      	jmp	LF66E16C1_5
            ; //LF66E16C1_4:;					
            LF66E16C1_4:
            ; //_A2C562ABC_18:;					
            _A2C562ABC_18:
            ; //_A2C562ABC_19:;					
            _A2C562ABC_19:
            ; //	dtxInitParameters();			
00138:      	pch	= dtxInitParameters
00139:      	lcall	dtxInitParameters
            ; //_A2C562ABC_20:;					
            _A2C562ABC_20:
            ; //_A2C562ABC_21:;					
            _A2C562ABC_21:
            ; //	dtxReadTune();				
0013A:      	pch	= dtxReadTune
0013B:      	lcall	dtxReadTune
            ; //_A2C562ABC_22:;					
            _A2C562ABC_22:
            ; //	sAX	= 0x0000;			
0013C:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
0013D:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0013E:      	rm[I1]	= AX
            ; //_A2C562ABC_23:;					
            _A2C562ABC_23:
            ; //	sAX	= 0x7FFF;			
0013F:      	AX	= 0x7FFF
            ; //	asm I1 = dtxfltg+0;			
00141:      	I1 = dtxfltg+0//
            ; //	*(__int16*)sSI	= sAX			
00142:      	rm[I1]	= AX
            ; //LF66E16C1_10:;					
            LF66E16C1_10:
            ; //_A2C562ABC_24:;					
            _A2C562ABC_24:
            ; //_A2C562ABC_25:;					
            _A2C562ABC_25:
            ; //	asm	io[ClrWDT] = AR			
00143:      	io[ClrWDT] = AR
            ; //	
            ; //_A2C562ABC_26:;					
            _A2C562ABC_26:
            ; //_A2C562ABC_27:;					
            _A2C562ABC_27:
            ; //	_PollingKey3B90E3B1();			
00144:      	pch	= _PollingKey3B90E3B1
00145:      	lcall	_PollingKey3B90E3B1
            ; //_A2C562ABC_28:;					
            _A2C562ABC_28:
            ; //_A2C562ABC_29:;					
            _A2C562ABC_29:
            ; //	_KeyShowLEDA84888EC();			
00146:      	pch	= _KeyShowLEDA84888EC
00147:      	lcall	_KeyShowLEDA84888EC
            ; //_A2C562ABC_30:;					
            _A2C562ABC_30:
            ; //_A2C562ABC_31:;					
            _A2C562ABC_31:
            ; //	_ToneVolCtrl03CF265A();			
00148:      	pch	= _ToneVolCtrl03CF265A
00149:      	lcall	_ToneVolCtrl03CF265A
            ; //_A2C562ABC_32:;					
            _A2C562ABC_32:
            ; //	sAX	= 0;				
0014A:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
0014B:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
0014C:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0014D:      	test AR.b0//
            ; //	if(__jz__) goto LF66E16C1_12;		
0014E:      	if ZR	jmp LF66E16C1_12
            ; //	sAX	= 1;				
0014F:      	AX	= 0x01
            ; //LF66E16C1_12:;					
            LF66E16C1_12:
            ; //	sfx_CHECKZERO();			
00150:      	AR	= AX
            ; //	if(__jnz__)	goto LF66E16C1_13;	
00151:      	if NZ	jmp LF66E16C1_13
            ; //	goto	LF66E16C1_11;			
00152:      	jmp	LF66E16C1_11
            ; //LF66E16C1_13:;					
            LF66E16C1_13:
            ; //	
            ; //_A2C562ABC_33:;					
            _A2C562ABC_33:
            ; //_A2C562ABC_34:;					
            _A2C562ABC_34:
            ; //	Subb3_Dec();				
00153:      	pch	= Subb3_Dec
00154:      	lcall	Subb3_Dec
            ; //	sfx_CHECKZERO();			
00155:      	AR	= AX
            ; //	if(__jnz__)	goto LF66E16C1_15;	
00156:      	if NZ	jmp LF66E16C1_15
            ; //	goto	LF66E16C1_14;			
00157:      	jmp	LF66E16C1_14
            ; //LF66E16C1_15:;					
            LF66E16C1_15:
            ; //	
            ; //_A2C562ABC_35:;					
            _A2C562ABC_35:
            ; //	asm set io[0x09].b0;			
00158:      	set io[0x09].b0//
            ; //_A2C562ABC_36:;					
            _A2C562ABC_36:
            ; //	asm I1 = _flags026116D5+0;		
00159:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
0015A:      	AR = rm[I1]//
            ; //	asm clr AR.b0;				
0015B:      	clr AR.b0//
            ; //	asm rm[I1] = AR;			
0015C:      	rm[I1] = AR//
            ; //_A2C562ABC_37:;					
            _A2C562ABC_37:
            ; //_A2C562ABC_38:;					
            _A2C562ABC_38:
            ; //	_Sub3ZeroFillABFF23AA();		
0015D:      	pch	= _Sub3ZeroFillABFF23AA
0015E:      	lcall	_Sub3ZeroFillABFF23AA
            ; //LF66E16C1_14:;					
            LF66E16C1_14:
            ; //_A2C562ABC_39:;					
            _A2C562ABC_39:
            ; //	goto LF66E16C1_16;			
0015F:      	jmp	LF66E16C1_16
            ; //LF66E16C1_11:;					
            LF66E16C1_11:
            ; //	
            ; //_A2C562ABC_40:;					
            _A2C562ABC_40:
            ; //_A2C562ABC_41:;					
            _A2C562ABC_41:
            ; //	_Sub3ZeroFillABFF23AA();		
00160:      	pch	= _Sub3ZeroFillABFF23AA
00161:      	lcall	_Sub3ZeroFillABFF23AA
            ; //LF66E16C1_16:;					
            LF66E16C1_16:
            ; //_A2C562ABC_42:;					
            _A2C562ABC_42:
            ; //_A2C562ABC_43:;					
            _A2C562ABC_43:
            ; //	asm clr io[0x09].b0;			
00162:      	clr io[0x09].b0//
            ; //_A2C562ABC_44:;					
            _A2C562ABC_44:
            ; //	goto LF66E16C1_10;			
00163:      	jmp	LF66E16C1_10
            ; //LF66E16C1_9:;					
            LF66E16C1_9:
            ; //LF66E16C1_3:;					
            LF66E16C1_3:
            ; //_A2C562ABC_45:;					
            _A2C562ABC_45:
            ; //	return;					
00164:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A2C562ABC_46:;					
            _A2C562ABC_46:
            ; //}
            ; //
            ; //rjmp void _KeyPlaySongC44FFB6D()		
            _KeyPlaySongC44FFB6D:
            ; //{
            ; //_A2C562ABC_47:;					
            _A2C562ABC_47:
            ; //	
            ; //_A2C562ABC_48:;					
            _A2C562ABC_48:
            ; //	asm I1 = _flags026116D5+0;		
00165:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
00166:      	AR = rm[I1]//
            ; //	asm clr AR.b0;				
00167:      	clr AR.b0//
            ; //	asm rm[I1] = AR;			
00168:      	rm[I1] = AR//
            ; //_A2C562ABC_49:;					
            _A2C562ABC_49:
            ; //_A2C562ABC_50:;					
            _A2C562ABC_50:
            ; //	_dtxCheckSongEnd870A9712();		
00169:      	pch	= _dtxCheckSongEnd870A9712
0016A:      	lcall	_dtxCheckSongEnd870A9712
            ; //	sfx_CHECKZERO();			
0016B:      	AR	= AX
            ; //	if(__jnz__)	goto LF66E16C1_19;	
0016C:      	if NZ	jmp LF66E16C1_19
            ; //	goto	LF66E16C1_18;			
0016D:      	jmp	LF66E16C1_18
            ; //LF66E16C1_19:;					
            LF66E16C1_19:
            ; //	
            ; //_A2C562ABC_51:;					
            _A2C562ABC_51:
            ; //_A2C562ABC_52:;					
            _A2C562ABC_52:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0016E:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0016F:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00170:      	push	AX
            ; //	_dtxPlaySong5B7DBDA5(STACK[sSP + 0]);	
00171:      	pch	= _dtxPlaySong5B7DBDA5
00172:      	lcall	_dtxPlaySong5B7DBDA5
            ; //	RESTORESP(1);				
00173:      	pop	AR
            ; //	goto LF66E16C1_20;			
00174:      	jmp	LF66E16C1_20
            ; //LF66E16C1_18:;					
            LF66E16C1_18:
            ; //	
            ; //_A2C562ABC_53:;					
            _A2C562ABC_53:
            ; //_A2C562ABC_54:;					
            _A2C562ABC_54:
            ; //	dtxStopSong();				
00175:      	pch	= dtxStopSong
00176:      	lcall	dtxStopSong
            ; //LF66E16C1_20:;					
            LF66E16C1_20:
            ; //_A2C562ABC_55:;					
            _A2C562ABC_55:
            ; //LF66E16C1_17:;					
            LF66E16C1_17:
            ; //_A2C562ABC_56:;					
            _A2C562ABC_56:
            ; //	return;					
00177:      	rets
            ; //_KeyPlaySongC44FFB6D_end:;			
            _KeyPlaySongC44FFB6D_end:
            ; //_A2C562ABC_57:;					
            _A2C562ABC_57:
            ; //}
            ; //
            ; //rjmp void _KeyPlayStop0C3B8DB1()		
            _KeyPlayStop0C3B8DB1:
            ; //{
            ; //_A2C562ABC_58:;					
            _A2C562ABC_58:
            ; //	
            ; //_A2C562ABC_59:;					
            _A2C562ABC_59:
            ; //_A2C562ABC_60:;					
            _A2C562ABC_60:
            ; //	dtxStopSong();				
00178:      	pch	= dtxStopSong
00179:      	lcall	dtxStopSong
            ; //LF66E16C1_21:;					
            LF66E16C1_21:
            ; //_A2C562ABC_61:;					
            _A2C562ABC_61:
            ; //	return;					
0017A:      	rets
            ; //_KeyPlayStop0C3B8DB1_end:;			
            _KeyPlayStop0C3B8DB1_end:
            ; //_A2C562ABC_62:;					
            _A2C562ABC_62:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_A2C562ABC_63:;					
            _A2C562ABC_63:
            ; //	
            ; //_A2C562ABC_64:;					
            _A2C562ABC_64:
            ; //_A2C562ABC_65:;					
            _A2C562ABC_65:
            ; //	dtxStopSong();				
0017B:      	pch	= dtxStopSong
0017C:      	lcall	dtxStopSong
            ; //_A2C562ABC_66:;					
            _A2C562ABC_66:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0017D:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0017E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
0017F:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
00180:      	CX	= rm[I1]
            ; //	sCX++;					
00181:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
00182:      	rm[I1]	= CX
            ; //_A2C562ABC_67:;					
            _A2C562ABC_67:
            ; //_A2C562ABC_68:;					
            _A2C562ABC_68:
            ; //	_CheckSongLimit402181B4();		
00183:      	pch	= _CheckSongLimit402181B4
00184:      	lcall	_CheckSongLimit402181B4
            ; //_A2C562ABC_69:;					
            _A2C562ABC_69:
            ; //_A2C562ABC_70:;					
            _A2C562ABC_70:
            ; //	_KeyPlaySongC44FFB6D();			
00185:      	pch	= _KeyPlaySongC44FFB6D
00186:      	lcall	_KeyPlaySongC44FFB6D
            ; //LF66E16C1_22:;					
            LF66E16C1_22:
            ; //_A2C562ABC_71:;					
            _A2C562ABC_71:
            ; //	return;					
00187:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_A2C562ABC_72:;					
            _A2C562ABC_72:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_A2C562ABC_73:;					
            _A2C562ABC_73:
            ; //	
            ; //_A2C562ABC_74:;					
            _A2C562ABC_74:
            ; //_A2C562ABC_75:;					
            _A2C562ABC_75:
            ; //	dtxStopSong();				
00188:      	pch	= dtxStopSong
00189:      	lcall	dtxStopSong
            ; //_A2C562ABC_76:;					
            _A2C562ABC_76:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0018A:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0018B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
0018C:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
0018D:      	CX	= rm[I1]
            ; //	sCX--;					
0018E:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
0018F:      	rm[I1]	= CX
            ; //_A2C562ABC_77:;					
            _A2C562ABC_77:
            ; //_A2C562ABC_78:;					
            _A2C562ABC_78:
            ; //	_CheckSongLimit402181B4();		
00190:      	pch	= _CheckSongLimit402181B4
00191:      	lcall	_CheckSongLimit402181B4
            ; //_A2C562ABC_79:;					
            _A2C562ABC_79:
            ; //_A2C562ABC_80:;					
            _A2C562ABC_80:
            ; //	_KeyPlaySongC44FFB6D();			
00192:      	pch	= _KeyPlaySongC44FFB6D
00193:      	lcall	_KeyPlaySongC44FFB6D
            ; //LF66E16C1_23:;					
            LF66E16C1_23:
            ; //_A2C562ABC_81:;					
            _A2C562ABC_81:
            ; //	return;					
00194:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_A2C562ABC_82:;					
            _A2C562ABC_82:
            ; //}
            ; //
            ; //rjmp void _KeyModEEAB4D5A()			
            _KeyModEEAB4D5A:
            ; //{
            ; //_A2C562ABC_83:;					
            _A2C562ABC_83:
            ; //	
            ; //_A2C562ABC_84:;					
            _A2C562ABC_84:
            ; //	asm AX = dtxtonech+7;			
00195:      	AX = dtxtonech+7//
            ; //	PUSH(sAX);				
00197:      	push	AX
            ; //	sAX	= 0x0001;			
00198:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
00199:      	I1 = dtxtonech+7//
            ; //	sCX	= *(__int16*)sSI;		
0019B:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
0019C:      	AR	= CX
0019D:      	AX	+= AR
            ; //	asm AR = 0x0003;			
0019E:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
0019F:      	AX = AX & AR//
            ; //	sSI	= POP();			
001A0:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
001A1:      	rm[I1]	= AX
            ; //_A2C562ABC_85:;					
            _A2C562ABC_85:
            ; //	asm AX = dtxtonech+15;			
001A2:      	AX = dtxtonech+15//
            ; //	PUSH(sAX);				
001A4:      	push	AX
            ; //	sAX	= 0x0001;			
001A5:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+15;			
001A6:      	I1 = dtxtonech+15//
            ; //	sCX	= *(__int16*)sSI;		
001A8:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
001A9:      	AR	= CX
001AA:      	AX	+= AR
            ; //	asm AR = 0x0003;			
001AB:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
001AC:      	AX = AX & AR//
            ; //	sSI	= POP();			
001AD:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
001AE:      	rm[I1]	= AX
            ; //LF66E16C1_24:;					
            LF66E16C1_24:
            ; //_A2C562ABC_86:;					
            _A2C562ABC_86:
            ; //	return;					
001AF:      	rets
            ; //_KeyModEEAB4D5A_end:;				
            _KeyModEEAB4D5A_end:
            ; //_A2C562ABC_87:;					
            _A2C562ABC_87:
            ; //}
            ; //
            ; //rjmp void _KeySubb3A3BA54B6D()			
            _KeySubb3A3BA54B6D:
            ; //{
            ; //_A2C562ABC_88:;					
            _A2C562ABC_88:
            ; //	
            ; //_A2C562ABC_89:;					
            _A2C562ABC_89:
            ; //_A2C562ABC_90:;					
            _A2C562ABC_90:
            ; //	dtxStopSong();				
001B0:      	pch	= dtxStopSong
001B1:      	lcall	dtxStopSong
            ; //_A2C562ABC_91:;					
            _A2C562ABC_91:
            ; //_A2C562ABC_92:;					
            _A2C562ABC_92:
            ; //	asm AX = #subdat0+0;			
001B2:      	AX = #subdat0+0//
            ; //	asm DX = #subdat0.n2			
001B4:      	DX = #subdat0.n2
            ; //	asm set DX.b11				
001B5:      	set DX.b11
            ; //	PUSH(sDX);				
001B6:      	push	DX
            ; //	PUSH(sAX);				
001B7:      	push	AX
            ; //	_Sub3Play422CAD6D(STACK[sSP + 0], STACK[sSP + 1]);
001B8:      	pch	= _Sub3Play422CAD6D
001B9:      	lcall	_Sub3Play422CAD6D
            ; //	RESTORESP(2);				
001BA:      	pop	AR
001BB:      	pop	AR
            ; //_A2C562ABC_93:;					
            _A2C562ABC_93:
            ; //	asm I1 = _flags026116D5+0;		
001BC:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
001BD:      	AR = rm[I1]//
            ; //	asm set AR.b0;				
001BE:      	set AR.b0//
            ; //	asm rm[I1] = AR;			
001BF:      	rm[I1] = AR//
            ; //LF66E16C1_25:;					
            LF66E16C1_25:
            ; //_A2C562ABC_94:;					
            _A2C562ABC_94:
            ; //	return;					
001C0:      	rets
            ; //_KeySubb3A3BA54B6D_end:;			
            _KeySubb3A3BA54B6D_end:
            ; //_A2C562ABC_95:;					
            _A2C562ABC_95:
            ; //}
            ; //
            ; //rjmp void _KeySubb3B3F6456DA()			
            _KeySubb3B3F6456DA:
            ; //{
            ; //_A2C562ABC_96:;					
            _A2C562ABC_96:
            ; //	
            ; //_A2C562ABC_97:;					
            _A2C562ABC_97:
            ; //_A2C562ABC_98:;					
            _A2C562ABC_98:
            ; //	dtxStopSong();				
001C1:      	pch	= dtxStopSong
001C2:      	lcall	dtxStopSong
            ; //_A2C562ABC_99:;					
            _A2C562ABC_99:
            ; //_A2C562ABC_100:;				
            _A2C562ABC_100:
            ; //	asm AX = #subdat1+0;			
001C3:      	AX = #subdat1+0//
            ; //	asm DX = #subdat1.n2			
001C5:      	DX = #subdat1.n2
            ; //	asm set DX.b11				
001C6:      	set DX.b11
            ; //	PUSH(sDX);				
001C7:      	push	DX
            ; //	PUSH(sAX);				
001C8:      	push	AX
            ; //	_Sub3Play422CAD6D(STACK[sSP + 0], STACK[sSP + 1]);
001C9:      	pch	= _Sub3Play422CAD6D
001CA:      	lcall	_Sub3Play422CAD6D
            ; //	RESTORESP(2);				
001CB:      	pop	AR
001CC:      	pop	AR
            ; //_A2C562ABC_101:;				
            _A2C562ABC_101:
            ; //	asm I1 = _flags026116D5+0;		
001CD:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
001CE:      	AR = rm[I1]//
            ; //	asm set AR.b0;				
001CF:      	set AR.b0//
            ; //	asm rm[I1] = AR;			
001D0:      	rm[I1] = AR//
            ; //LF66E16C1_26:;					
            LF66E16C1_26:
            ; //_A2C562ABC_102:;				
            _A2C562ABC_102:
            ; //	return;					
001D1:      	rets
            ; //_KeySubb3B3F6456DA_end:;			
            _KeySubb3B3F6456DA_end:
            ; //_A2C562ABC_103:;				
            _A2C562ABC_103:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayNextAFBA8CED[0], 0x0000, 0x0000, (int)&_KeyPlayPrev8E98A35A[0], 0x0000, 0x0000, (int)&_KeyModEEAB4D5A[0], 0x0000, 
001D2:      DW #_KeyPlayNextAFBA8CED,0x0000,0x0000,#_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyModEEAB4D5A,0x0000,
            ; //	0x0000, (int)&_KeySubb3A3BA54B6D[0], 0x0000, 0x0000, (int)&_KeySubb3B3F6456DA[0], 0x0000, 0x0000
001DA:      DW 0x0000,#_KeySubb3A3BA54B6D,0x0000,0x0000,#_KeySubb3B3F6456DA,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\E_CF87A0F9.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:4095]={
             _flags026116D5,_songidx8C42F7DA,_sub_vol980B1B83,_ticksA7263C09[2] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitialDA4A7CC4();
            ; //rjmp void _CheckSongLimit402181B4();
            ; //rjmp void _RampUpFF7996DA();
            ; //rjmp void _RampDown1D382EDA();
            ; //rjmp void _ToneVolCtrl03CF265A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void L0E8FA404_28()			
            L0E8FA404_28:
            ; //{
            ; //_A2C562ABC_104:;				
            _A2C562ABC_104:
            ; //	
            ; //_A2C562ABC_105:;				
            _A2C562ABC_105:
            ; //	io[0x16]	= 0x0000;		
001E1:      	AR	= 0x00
001E2:      	io[0x16]	= AR
            ; //_A2C562ABC_106:;				
            _A2C562ABC_106:
            ; //	io[0x16]	= 0x0000;		
001E3:      	AR	= 0x00
001E4:      	io[0x16]	= AR
            ; //_A2C562ABC_107:;				
            _A2C562ABC_107:
            ; //	io[0x16]	= 0x0000;		
001E5:      	AR	= 0x00
001E6:      	io[0x16]	= AR
            ; //_A2C562ABC_108:;				
            _A2C562ABC_108:
            ; //	io[0x16]	= 0x0000;		
001E7:      	AR	= 0x00
001E8:      	io[0x16]	= AR
            ; //_A2C562ABC_109:;				
            _A2C562ABC_109:
            ; //	io[0x36]	= 0x0000;		
001E9:      	AR	= 0x00
001EA:      	io[0x36]	= AR
            ; //_A2C562ABC_110:;				
            _A2C562ABC_110:
            ; //	io[0x36]	= 0x0000;		
001EB:      	AR	= 0x00
001EC:      	io[0x36]	= AR
            ; //_A2C562ABC_111:;				
            _A2C562ABC_111:
            ; //	io[0x36]	= 0x0000;		
001ED:      	AR	= 0x00
001EE:      	io[0x36]	= AR
            ; //_A2C562ABC_112:;				
            _A2C562ABC_112:
            ; //	io[0x36]	= 0x0000;		
001EF:      	AR	= 0x00
001F0:      	io[0x36]	= AR
            ; //_A2C562ABC_113:;				
            _A2C562ABC_113:
            ; //	io[0x36]	= 0x0000;		
001F1:      	AR	= 0x00
001F2:      	io[0x36]	= AR
            ; //_A2C562ABC_114:;				
            _A2C562ABC_114:
            ; //	io[0x36]	= 0x0000;		
001F3:      	AR	= 0x00
001F4:      	io[0x36]	= AR
            ; //_A2C562ABC_115:;				
            _A2C562ABC_115:
            ; //	io[0x36]	= 0x0000;		
001F5:      	AR	= 0x00
001F6:      	io[0x36]	= AR
            ; //_A2C562ABC_116:;				
            _A2C562ABC_116:
            ; //	io[0x36]	= 0x0000;		
001F7:      	AR	= 0x00
001F8:      	io[0x36]	= AR
            ; //_A2C562ABC_117:;				
            _A2C562ABC_117:
            ; //	io[0x3C]	= 0x003F;		
001F9:      	AR	= 0x3F
001FA:      	io[0x3C]	= AR
            ; //_A2C562ABC_118:;				
            _A2C562ABC_118:
            ; //	sAX	= io[0x3C];			
001FB:      	AR	= io[0x3C]
001FC:      	AX	= AR
            ; //_A2C562ABC_119:;				
            _A2C562ABC_119:
            ; //	asm	set io[MISC].b9			
001FD:      	set io[MISC].b9
            ; //_A2C562ABC_120:;				
            _A2C562ABC_120:
            ; //	asm	set io[MISC].b8			
001FE:      	set io[MISC].b8
            ; //_A2C562ABC_121:;				
            _A2C562ABC_121:
            ; //	asm	set io[MISC].b4			
001FF:      	set io[MISC].b4
            ; //L0E8FA404_30:;					
            L0E8FA404_30:
            ; //_A2C562ABC_122:;				
            _A2C562ABC_122:
            ; //	return;					
00200:      	rets
            ; //L0E8FA404_28_end:;				
            L0E8FA404_28_end:
            ; //_A2C562ABC_123:;				
            _A2C562ABC_123:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_31()			
            L0E8FA404_31:
            ; //{
            ; //_A2C562ABC_124:;				
            _A2C562ABC_124:
            ; //	
            ; //_A2C562ABC_125:;				
            _A2C562ABC_125:
            ; //	io[0x04]	= 0x000F;		
00201:      	AR	= 0x0F
00202:      	io[0x04]	= AR
            ; //_A2C562ABC_126:;				
            _A2C562ABC_126:
            ; //	io[0x05]	= 0xFFFF;		
00203:      	AR	= 0xFFFF
00205:      	io[0x05]	= AR
            ; //_A2C562ABC_127:;				
            _A2C562ABC_127:
            ; //	io[0x07]	= 0x0000;		
00206:      	AR	= 0x00
00207:      	io[0x07]	= AR
            ; //_A2C562ABC_128:;				
            _A2C562ABC_128:
            ; //	io[0x08]	= 0xFFFF;		
00208:      	AR	= 0xFFFF
0020A:      	io[0x08]	= AR
            ; //L0E8FA404_33:;					
            L0E8FA404_33:
            ; //_A2C562ABC_129:;				
            _A2C562ABC_129:
            ; //	return;					
0020B:      	rets
            ; //L0E8FA404_31_end:;				
            L0E8FA404_31_end:
            ; //_A2C562ABC_130:;				
            _A2C562ABC_130:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_A2C562ABC_131:;				
            _A2C562ABC_131:
            ; //	
            ; //_A2C562ABC_132:;				
            _A2C562ABC_132:
            ; //	sAX	= 0x0000;			
0020C:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
0020D:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0020E:      	rm[I1]	= AX
            ; //_A2C562ABC_133:;				
            _A2C562ABC_133:
            ; //_A2C562ABC_134:;				
            _A2C562ABC_134:
            ; //	NEARCALL(L0E8FA404_28);			
0020F:      	call	L0E8FA404_28
            ; //_A2C562ABC_135:;				
            _A2C562ABC_135:
            ; //_A2C562ABC_136:;				
            _A2C562ABC_136:
            ; //	NEARCALL(L0E8FA404_31);			
00210:      	call	L0E8FA404_31
            ; //_A2C562ABC_137:;				
            _A2C562ABC_137:
            ; //	sAX	= 0x0000;			
00211:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
00212:      	I1 = _flags026116D5+0//
            ; //	*(__int16*)sSI	= sAX			
00213:      	rm[I1]	= AX
            ; //_A2C562ABC_138:;				
            _A2C562ABC_138:
            ; //	asm AX = PCMY+0;			
00214:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
00216:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00217:      	rm[I1]	= AX
            ; //_A2C562ABC_139:;				
            _A2C562ABC_139:
            ; //	asm AX = PCMY+0;			
00218:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
0021A:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
0021B:      	rm[I1]	= AX
            ; //L0E8FA404_34:;					
            L0E8FA404_34:
            ; //_A2C562ABC_140:;				
            _A2C562ABC_140:
            ; //	return;					
0021C:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A2C562ABC_141:;				
            _A2C562ABC_141:
            ; //}
            ; //
            ; //rjmp void _CheckSongLimit402181B4()		
            _CheckSongLimit402181B4:
            ; //{
            ; //_A2C562ABC_142:;				
            _A2C562ABC_142:
            ; //	
            ; //_A2C562ABC_143:;				
            _A2C562ABC_143:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0021D:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0021E:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
0021F:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00220:      	pch	= sfx_CMP_AX_CX_JL
00221:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L0E8FA404_37;	
00222:      	if ZR	jmp L0E8FA404_37
            ; //	goto	L0E8FA404_36;			
00223:      	jmp	L0E8FA404_36
            ; //L0E8FA404_37:;					
            L0E8FA404_37:
            ; //	
            ; //_A2C562ABC_144:;				
            _A2C562ABC_144:
            ; //	asm I1 = dtxsongcnt+0;			
00224:      	I1 = dtxsongcnt+0//
            ; //	sAX	= *(__int16*)sSI;		
00226:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00227:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
00228:      	AR	= CX
00229:      	AX	-= AR
            ; //	asm I1 = _songidx8C42F7DA+0;		
0022A:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0022B:      	rm[I1]	= AX
            ; //	goto L0E8FA404_38;			
0022C:      	jmp	L0E8FA404_38
            ; //L0E8FA404_36:;					
            L0E8FA404_36:
            ; //	
            ; //_A2C562ABC_145:;				
            _A2C562ABC_145:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0022D:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0022E:      	AX	= rm[I1]
            ; //	asm I1 = dtxsongcnt+0;			
0022F:      	I1 = dtxsongcnt+0//
            ; //	asm CX = rm[I1];			
00231:      	CX = rm[I1]//
            ; //	sfx_CMP_AX_CX_JGE();			
00232:      	pch	= sfx_CMP_AX_CX_JGE
00233:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto L0E8FA404_40;	
00234:      	if ZR	jmp L0E8FA404_40
            ; //	goto	L0E8FA404_39;			
00235:      	jmp	L0E8FA404_39
            ; //L0E8FA404_40:;					
            L0E8FA404_40:
            ; //	
            ; //_A2C562ABC_146:;				
            _A2C562ABC_146:
            ; //	sAX	= 0x0000;			
00236:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
00237:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
00238:      	rm[I1]	= AX
            ; //L0E8FA404_39:;					
            L0E8FA404_39:
            ; //_A2C562ABC_147:;				
            _A2C562ABC_147:
            ; //L0E8FA404_38:;					
            L0E8FA404_38:
            ; //_A2C562ABC_148:;				
            _A2C562ABC_148:
            ; //L0E8FA404_35:;					
            L0E8FA404_35:
            ; //_A2C562ABC_149:;				
            _A2C562ABC_149:
            ; //	return;					
00239:      	rets
            ; //_CheckSongLimit402181B4_end:;			
            _CheckSongLimit402181B4_end:
            ; //_A2C562ABC_150:;				
            _A2C562ABC_150:
            ; //}
            ; //
            ; //rjmp void _RampUpFF7996DA()			
            _RampUpFF7996DA:
            ; //{
            ; //_A2C562ABC_151:;				
            _A2C562ABC_151:
            ; //	
            ; //_A2C562ABC_152:;				
            _A2C562ABC_152:
            ; //	asm I1 = _sub_vol980B1B83+0;		
0023A:      	I1 = _sub_vol980B1B83+0//
            ; //	sAX	= *(__int16*)sSI;		
0023B:      	AX	= rm[I1]
            ; //	asm AR = 0x003F;			
0023C:      	AR = 0x003F//
            ; //	asm AX = AX & AR;			
0023D:      	AX = AX & AR//
            ; //	sCX	= 0x003F;			
0023E:      	CX	= 0x3F
            ; //	sfx_CMP_AX_CX_JE();			
0023F:      	AR	= AX
00240:      	SF = AR - CX
            ; //	if(__je__)	goto L0E8FA404_43;	
00241:      	if ZR	jmp L0E8FA404_43
            ; //	goto	L0E8FA404_42;			
00242:      	jmp	L0E8FA404_42
            ; //L0E8FA404_43:;					
            L0E8FA404_43:
            ; //_A2C562ABC_153:;				
            _A2C562ABC_153:
            ; //	sAX	= 0x0000;			
00243:      	AX	= 0x00
            ; //	goto L0E8FA404_41;			
00244:      	jmp	L0E8FA404_41
            ; //L0E8FA404_42:;					
            L0E8FA404_42:
            ; //_A2C562ABC_154:;				
            _A2C562ABC_154:
            ; //_A2C562ABC_155:;				
            _A2C562ABC_155:
            ; //_A2C562ABC_156:;				
            _A2C562ABC_156:
            ; //	_GetTickCount18DC070C();		
00245:      	pch	= _GetTickCount18DC070C
00246:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00247:      	I1 = _ticksA7263C09+0//
            ; //	sCX	= *(__int16*)sSI++;		
00248:      	CX	= rm[I1++]
            ; //	sBX	= *(__int16*)sSI--;		
00249:      	BX	= rm[I1--]
            ; //	sfx_SUBLONG();				
0024A:      	AR	= CX
0024B:      	AX	= AX - AR
0024C:      	AR	= BX
0024D:      	DX	= DX - AR + C - 1
            ; //	sCX	= 0x0000;			
0024E:      	CX	= 0x00
            ; //	sBX	= 0x0005;			
0024F:      	BX	= 0x05
            ; //	sfx_CMPLONG_JA();			
00250:      	pch	= sfx_CMPLONG_JA
00251:      	lcall	sfx_CMPLONG_JA
            ; //	if(__je__)	goto L0E8FA404_45;	
00252:      	if ZR	jmp L0E8FA404_45
            ; //	goto	L0E8FA404_44;			
00253:      	jmp	L0E8FA404_44
            ; //L0E8FA404_45:;					
            L0E8FA404_45:
            ; //	
            ; //_A2C562ABC_157:;				
            _A2C562ABC_157:
            ; //_A2C562ABC_158:;				
            _A2C562ABC_158:
            ; //	_GetTickCount18DC070C();		
00254:      	pch	= _GetTickCount18DC070C
00255:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00256:      	I1 = _ticksA7263C09+0//
            ; //	sfx_STORSILONG();			
00257:      	rm[I1++]	= AX
00258:      	rm[I1--]	= DX
            ; //	
            ; //_A2C562ABC_159:;				
            _A2C562ABC_159:
            ; //	sSI	= (int)&_sub_vol980B1B83;	
00259:      	I1	= _sub_vol980B1B83
            ; //	sAX	= *(__int16*)sSI;		
0025A:      	AX	= rm[I1]
            ; //	sAX++;					
0025B:      	AX++
            ; //	*(__int16*)sSI	= sAX;			
0025C:      	rm[I1]	= AX
            ; //	io[0x3C]	= sAX;			
0025D:      	AR	= AX
0025E:      	io[0x3C]	= AR
            ; //L0E8FA404_44:;					
            L0E8FA404_44:
            ; //_A2C562ABC_160:;				
            _A2C562ABC_160:
            ; //_A2C562ABC_161:;				
            _A2C562ABC_161:
            ; //	sAX	= 0x0001;			
0025F:      	AX	= 0x01
            ; //	goto L0E8FA404_41;			
00260:      	jmp	L0E8FA404_41
            ; //L0E8FA404_41:;					
            L0E8FA404_41:
            ; //_A2C562ABC_162:;				
            _A2C562ABC_162:
            ; //	return;					
00261:      	rets
            ; //_RampUpFF7996DA_end:;				
            _RampUpFF7996DA_end:
            ; //_A2C562ABC_163:;				
            _A2C562ABC_163:
            ; //}
            ; //
            ; //rjmp void _RampDown1D382EDA()			
            _RampDown1D382EDA:
            ; //{
            ; //_A2C562ABC_164:;				
            _A2C562ABC_164:
            ; //	
            ; //_A2C562ABC_165:;				
            _A2C562ABC_165:
            ; //	asm I1 = _sub_vol980B1B83+0;		
00262:      	I1 = _sub_vol980B1B83+0//
            ; //	sAX	= *(__int16*)sSI;		
00263:      	AX	= rm[I1]
            ; //	asm AR = 0x003F;			
00264:      	AR = 0x003F//
            ; //	asm AX = AX & AR;			
00265:      	AX = AX & AR//
            ; //	sCX	= 0x0000;			
00266:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JE();			
00267:      	AR	= AX
00268:      	SF = AR - CX
            ; //	if(__je__)	goto L0E8FA404_48;	
00269:      	if ZR	jmp L0E8FA404_48
            ; //	goto	L0E8FA404_47;			
0026A:      	jmp	L0E8FA404_47
            ; //L0E8FA404_48:;					
            L0E8FA404_48:
            ; //_A2C562ABC_166:;				
            _A2C562ABC_166:
            ; //	sAX	= 0x0000;			
0026B:      	AX	= 0x00
            ; //	goto L0E8FA404_46;			
0026C:      	jmp	L0E8FA404_46
            ; //L0E8FA404_47:;					
            L0E8FA404_47:
            ; //_A2C562ABC_167:;				
            _A2C562ABC_167:
            ; //_A2C562ABC_168:;				
            _A2C562ABC_168:
            ; //_A2C562ABC_169:;				
            _A2C562ABC_169:
            ; //	_GetTickCount18DC070C();		
0026D:      	pch	= _GetTickCount18DC070C
0026E:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
0026F:      	I1 = _ticksA7263C09+0//
            ; //	sCX	= *(__int16*)sSI++;		
00270:      	CX	= rm[I1++]
            ; //	sBX	= *(__int16*)sSI--;		
00271:      	BX	= rm[I1--]
            ; //	sfx_SUBLONG();				
00272:      	AR	= CX
00273:      	AX	= AX - AR
00274:      	AR	= BX
00275:      	DX	= DX - AR + C - 1
            ; //	sCX	= 0x0000;			
00276:      	CX	= 0x00
            ; //	sBX	= 0x0005;			
00277:      	BX	= 0x05
            ; //	sfx_CMPLONG_JA();			
00278:      	pch	= sfx_CMPLONG_JA
00279:      	lcall	sfx_CMPLONG_JA
            ; //	if(__je__)	goto L0E8FA404_50;	
0027A:      	if ZR	jmp L0E8FA404_50
            ; //	goto	L0E8FA404_49;			
0027B:      	jmp	L0E8FA404_49
            ; //L0E8FA404_50:;					
            L0E8FA404_50:
            ; //	
            ; //_A2C562ABC_170:;				
            _A2C562ABC_170:
            ; //_A2C562ABC_171:;				
            _A2C562ABC_171:
            ; //	_GetTickCount18DC070C();		
0027C:      	pch	= _GetTickCount18DC070C
0027D:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
0027E:      	I1 = _ticksA7263C09+0//
            ; //	sfx_STORSILONG();			
0027F:      	rm[I1++]	= AX
00280:      	rm[I1--]	= DX
            ; //	
            ; //_A2C562ABC_172:;				
            _A2C562ABC_172:
            ; //	sSI	= (int)&_sub_vol980B1B83;	
00281:      	I1	= _sub_vol980B1B83
            ; //	sAX	= *(__int16*)sSI;		
00282:      	AX	= rm[I1]
            ; //	sAX--;					
00283:      	AX--
            ; //	*(__int16*)sSI	= sAX;			
00284:      	rm[I1]	= AX
            ; //	io[0x3C]	= sAX;			
00285:      	AR	= AX
00286:      	io[0x3C]	= AR
            ; //L0E8FA404_49:;					
            L0E8FA404_49:
            ; //_A2C562ABC_173:;				
            _A2C562ABC_173:
            ; //_A2C562ABC_174:;				
            _A2C562ABC_174:
            ; //	sAX	= 0x0001;			
00287:      	AX	= 0x01
            ; //	goto L0E8FA404_46;			
00288:      	jmp	L0E8FA404_46
            ; //L0E8FA404_46:;					
            L0E8FA404_46:
            ; //_A2C562ABC_175:;				
            _A2C562ABC_175:
            ; //	return;					
00289:      	rets
            ; //_RampDown1D382EDA_end:;				
            _RampDown1D382EDA_end:
            ; //_A2C562ABC_176:;				
            _A2C562ABC_176:
            ; //}
            ; //
            ; //rjmp void _ToneVolCtrl03CF265A()		
            _ToneVolCtrl03CF265A:
            ; //{
            ; //_A2C562ABC_177:;				
            _A2C562ABC_177:
            ; //	
            ; //_A2C562ABC_178:;				
            _A2C562ABC_178:
            ; //	sAX	= 0;				
0028A:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
0028B:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
0028C:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0028D:      	test AR.b0//
            ; //	if(__jz__) goto L0E8FA404_53;		
0028E:      	if ZR	jmp L0E8FA404_53
            ; //	sAX	= 1;				
0028F:      	AX	= 0x01
            ; //L0E8FA404_53:;					
            L0E8FA404_53:
            ; //	sfx_CHECKZERO();			
00290:      	AR	= AX
            ; //	if(__jnz__)	goto L0E8FA404_54;	
00291:      	if NZ	jmp L0E8FA404_54
            ; //	goto	L0E8FA404_52;			
00292:      	jmp	L0E8FA404_52
            ; //L0E8FA404_54:;					
            L0E8FA404_54:
            ; //	
            ; //_A2C562ABC_179:;				
            _A2C562ABC_179:
            ; //	asm I1 = dtxfltg+0;			
00293:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
00294:      	AX	= rm[I1]
            ; //	sCX	= 0x100F;			
00295:      	CX	= 0x100F
            ; //	sfx_CMP_AX_CX_JG();			
00297:      	pch	= sfx_CMP_AX_CX_JG
00298:      	lcall	sfx_CMP_AX_CX_JG
            ; //	if(__je__)	goto L0E8FA404_56;	
00299:      	if ZR	jmp L0E8FA404_56
            ; //	goto	L0E8FA404_55;			
0029A:      	jmp	L0E8FA404_55
            ; //L0E8FA404_56:;					
            L0E8FA404_56:
            ; //_A2C562ABC_180:;				
            _A2C562ABC_180:
            ; //	asm I1 = dtxfltg+0;			
0029B:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
0029C:      	AX	= rm[I1]
            ; //	sCX	= 0x0010;			
0029D:      	CX	= 0x10
            ; //	sAX	= sAX - sCX;			
0029E:      	AR	= CX
0029F:      	AX	-= AR
            ; //	asm I1 = dtxfltg+0;			
002A0:      	I1 = dtxfltg+0//
            ; //	*(__int16*)sSI	= sAX			
002A1:      	rm[I1]	= AX
            ; //L0E8FA404_55:;					
            L0E8FA404_55:
            ; //_A2C562ABC_181:;				
            _A2C562ABC_181:
            ; //	goto L0E8FA404_57;			
002A2:      	jmp	L0E8FA404_57
            ; //L0E8FA404_52:;					
            L0E8FA404_52:
            ; //	
            ; //_A2C562ABC_182:;				
            _A2C562ABC_182:
            ; //	asm I1 = dtxfltg+0;			
002A3:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
002A4:      	AX	= rm[I1]
            ; //	sCX	= 0x7FFF;			
002A5:      	CX	= 0x7FFF
            ; //	sfx_CMP_AX_CX_JNE();			
002A7:      	pch	= sfx_CMP_AX_CX_JNE
002A8:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L0E8FA404_59;	
002A9:      	if ZR	jmp L0E8FA404_59
            ; //	goto	L0E8FA404_58;			
002AA:      	jmp	L0E8FA404_58
            ; //L0E8FA404_59:;					
            L0E8FA404_59:
            ; //_A2C562ABC_183:;				
            _A2C562ABC_183:
            ; //	sSI	= (int)&dtxfltg;		
002AB:      	I1	= dtxfltg
            ; //	sAX	= *(__int16*)sSI;		
002AC:      	AX	= rm[I1]
            ; //	sAX++;					
002AD:      	AX++
            ; //	*(__int16*)sSI	= sAX;			
002AE:      	rm[I1]	= AX
            ; //L0E8FA404_58:;					
            L0E8FA404_58:
            ; //_A2C562ABC_184:;				
            _A2C562ABC_184:
            ; //L0E8FA404_57:;					
            L0E8FA404_57:
            ; //_A2C562ABC_185:;				
            _A2C562ABC_185:
            ; //L0E8FA404_51:;					
            L0E8FA404_51:
            ; //_A2C562ABC_186:;				
            _A2C562ABC_186:
            ; //	return;					
002AF:      	rets
            ; //_ToneVolCtrl03CF265A_end:;			
            _ToneVolCtrl03CF265A_end:
            ; //_A2C562ABC_187:;				
            _A2C562ABC_187:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_61,L5589D4CE_62,L5589D4CE_63 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_A2C562ABC_188:;				
            _A2C562ABC_188:
            ; //	
            ; //_A2C562ABC_189:;				
            _A2C562ABC_189:
            ; //	asm clr io[0x04].b0;			
002B0:      	clr io[0x04].b0//
            ; //_A2C562ABC_190:;				
            _A2C562ABC_190:
            ; //	asm clr io[0x04].b1;			
002B1:      	clr io[0x04].b1//
            ; //_A2C562ABC_191:;				
            _A2C562ABC_191:
            ; //	asm clr io[0x04].b2;			
002B2:      	clr io[0x04].b2//
            ; //_A2C562ABC_192:;				
            _A2C562ABC_192:
            ; //	asm clr io[0x04].b3;			
002B3:      	clr io[0x04].b3//
            ; //_A2C562ABC_193:;				
            _A2C562ABC_193:
            ; //	io[0x1E]	= 0x0005;		
002B4:      	AR	= 0x05
002B5:      	io[0x1E]	= AR
            ; //_A2C562ABC_194:;				
            _A2C562ABC_194:
            ; //	sAX	= 0x000F;			
002B6:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
002B7:      	AR	= io[0x1F]
002B8:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
002B9:      	AR	= AX
002BA:      	io[0x1F]	= AR
            ; //_A2C562ABC_195:;				
            _A2C562ABC_195:
            ; //	sAX	= 0x0000;			
002BB:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_61;		
002BC:      	I1	= L5589D4CE_61
            ; //	*(__int16*)sSI	= sAX			
002BD:      	rm[I1]	= AX
            ; //_A2C562ABC_196:;				
            _A2C562ABC_196:
            ; //	sAX	= 0x0000;			
002BE:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_62;		
002BF:      	I1	= L5589D4CE_62
            ; //	*(__int16*)sSI	= sAX			
002C0:      	rm[I1]	= AX
            ; //_A2C562ABC_197:;				
            _A2C562ABC_197:
            ; //	sAX	= 0x0200;			
002C1:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_63;		
002C3:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
002C4:      	rm[I1]	= AX
            ; //L5589D4CE_64:;					
            L5589D4CE_64:
            ; //_A2C562ABC_198:;				
            _A2C562ABC_198:
            ; //	return;					
002C5:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_A2C562ABC_199:;				
            _A2C562ABC_199:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_65()			
            L5589D4CE_65:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
002C6:      	AR	= rm[BP_SAVE]
002C7:      	push	AR
002C8:      	AR	= BP
002C9:      	rm[BP_SAVE]	= AR
002CA:      	AR	 = -1
002CB:      	BP	+= AR
            ; //_A2C562ABC_200:;				
            _A2C562ABC_200:
            ; //	
            ; //_A2C562ABC_201:;				
            _A2C562ABC_201:
            ; //	sAX	= 0x000F;			
002CC:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
002CD:      	AR	= io[0x07]
002CE:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
002CF:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
002D0:      	rm[I1]	= AX
            ; //_A2C562ABC_202:;				
            _A2C562ABC_202:
            ; //	sSI	= (int)&_btn_1_2;		
002D1:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002D2:      	AX	= rm[I1]
            ; //	goto L5589D4CE_67;			
002D3:      	jmp	L5589D4CE_67
            ; //L5589D4CE_67:;					
            L5589D4CE_67:
            ; //_A2C562ABC_203:;				
            _A2C562ABC_203:
            ; //	return;					
002D4:      	AR	= 1
002D5:      	BP	+= AR
002D6:      	pop	AR
002D7:      	rm[BP_SAVE]	= AR
002D8:      	rets
            ; //L5589D4CE_65_end:;				
            L5589D4CE_65_end:
            ; //_A2C562ABC_204:;				
            _A2C562ABC_204:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
002D9:      	AR	= rm[BP_SAVE]
002DA:      	push	AR
002DB:      	AR	= BP
002DC:      	rm[BP_SAVE]	= AR
002DD:      	AR	 = -5
002DE:      	BP	+= AR
            ; //_A2C562ABC_205:;				
            _A2C562ABC_205:
            ; //	
            ; //_A2C562ABC_206:;				
            _A2C562ABC_206:
            ; //_A2C562ABC_207:;				
            _A2C562ABC_207:
            ; //	NEARCALL(L5589D4CE_65);			
002DF:      	call	L5589D4CE_65
            ; //	sSI	= (int)&_keynow_1_2;		
002E0:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
002E1:      	rm[I1]	= AX
            ; //_A2C562ABC_208:;				
            _A2C562ABC_208:
            ; //	asm I1 = L5589D4CE_61+0;		
002E2:      	I1 = L5589D4CE_61+0//
            ; //	sAX	= *(__int16*)sSI;		
002E3:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
002E4:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
002E5:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
002E6:      	pch	= sfx_CMP_AX_CX_JNE
002E7:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_70;	
002E8:      	if ZR	jmp L5589D4CE_70
            ; //	goto	L5589D4CE_69;			
002E9:      	jmp	L5589D4CE_69
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //	
            ; //_A2C562ABC_209:;				
            _A2C562ABC_209:
            ; //	sSI	= (int)&_keynow_1_2;		
002EA:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002EB:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_61;		
002EC:      	I1	= L5589D4CE_61
            ; //	*(__int16*)sSI	= sAX			
002ED:      	rm[I1]	= AX
            ; //_A2C562ABC_210:;				
            _A2C562ABC_210:
            ; //	sAX	= 0x0200;			
002EE:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_63;		
002F0:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
002F1:      	rm[I1]	= AX
            ; //_A2C562ABC_211:;				
            _A2C562ABC_211:
            ; //	goto L5589D4CE_68;			
002F2:      	jmp	L5589D4CE_68
            ; //L5589D4CE_69:;					
            L5589D4CE_69:
            ; //_A2C562ABC_212:;				
            _A2C562ABC_212:
            ; //_A2C562ABC_213:;				
            _A2C562ABC_213:
            ; //	asm I1 = L5589D4CE_63+0;		
002F3:      	I1 = L5589D4CE_63+0//
            ; //	sAX	= *(__int16*)sSI;		
002F4:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
002F5:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_72;	
002F6:      	if NZ	jmp L5589D4CE_72
            ; //	goto	L5589D4CE_71;			
002F7:      	jmp	L5589D4CE_71
            ; //L5589D4CE_72:;					
            L5589D4CE_72:
            ; //	
            ; //_A2C562ABC_214:;				
            _A2C562ABC_214:
            ; //	asm I1 = L5589D4CE_63+0;		
002F8:      	I1 = L5589D4CE_63+0//
            ; //	sAX	= *(__int16*)sSI;		
002F9:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002FA:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
002FB:      	AR	= CX
002FC:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_63;		
002FD:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
002FE:      	rm[I1]	= AX
            ; //_A2C562ABC_215:;				
            _A2C562ABC_215:
            ; //	goto L5589D4CE_68;			
002FF:      	jmp	L5589D4CE_68
            ; //L5589D4CE_71:;					
            L5589D4CE_71:
            ; //_A2C562ABC_216:;				
            _A2C562ABC_216:
            ; //_A2C562ABC_217:;				
            _A2C562ABC_217:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
00300:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
00302:      	AR	= -4
00303:      	I1	= rm[BP_SAVE]
00304:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00305:      	rm[I1]	= AX
            ; //_A2C562ABC_218:;				
            _A2C562ABC_218:
            ; //	sAX	= 0x0200;			
00306:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_63;		
00308:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
00309:      	rm[I1]	= AX
            ; //_A2C562ABC_219:;				
            _A2C562ABC_219:
            ; //	asm I1 = L5589D4CE_62+0;		
0030A:      	I1 = L5589D4CE_62+0//
            ; //	sAX	= *(__int16*)sSI;		
0030B:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_61+0;		
0030C:      	I1 = L5589D4CE_61+0//
            ; //	asm AR = rm[I1];			
0030D:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
0030E:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0030F:      	AR	= -2
00310:      	I1	= rm[BP_SAVE]
00311:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00312:      	rm[I1]	= AX
            ; //_A2C562ABC_220:;				
            _A2C562ABC_220:
            ; //	asm I1 = L5589D4CE_62+0;		
00313:      	I1 = L5589D4CE_62+0//
            ; //	sAX	= *(__int16*)sSI;		
00314:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00315:      	AR	= -3
00316:      	I1	= rm[BP_SAVE]
00317:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00318:      	rm[I1]	= AX
            ; //_A2C562ABC_221:;				
            _A2C562ABC_221:
            ; //	asm I1 = L5589D4CE_61+0;		
00319:      	I1 = L5589D4CE_61+0//
            ; //	sAX	= *(__int16*)sSI;		
0031A:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_62;		
0031B:      	I1	= L5589D4CE_62
            ; //	*(__int16*)sSI	= sAX			
0031C:      	rm[I1]	= AX
            ; //_A2C562ABC_222:;				
            _A2C562ABC_222:
            ; //	_i_1_4+0	= 0x05;			
0031D:      	AR	= -1
0031E:      	I1	= rm[BP_SAVE]
0031F:      	I1	+= AR
00320:      	AX	= 0x05
00321:      	rm[I1]	= AX
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //_A2C562ABC_223:;				
            _A2C562ABC_223:
            ; //	sSI	= (int)&_i_1_4;			
00322:      	AR	= -1
00323:      	I1	= rm[BP_SAVE]
00324:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00325:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00326:      	AR	= -1
00327:      	I1	= rm[BP_SAVE]
00328:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00329:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0032A:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0032B:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0032C:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_75;	
0032D:      	if NZ	jmp L5589D4CE_75
            ; //	goto	L5589D4CE_73;			
0032E:      	jmp	L5589D4CE_73
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //	
            ; //_A2C562ABC_224:;				
            _A2C562ABC_224:
            ; //	sAX	= 0;				
0032F:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
00330:      	AR	= -2
00331:      	I1	= rm[BP_SAVE]
00332:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00333:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00334:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_77;		
00335:      	if ZR	jmp L5589D4CE_77
            ; //	sAX	= 1;				
00336:      	AX	= 0x01
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //	sfx_CHECKZERO();			
00337:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_78;	
00338:      	if NZ	jmp L5589D4CE_78
            ; //	goto	L5589D4CE_76;			
00339:      	jmp	L5589D4CE_76
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //	
            ; //_A2C562ABC_225:;				
            _A2C562ABC_225:
            ; //	sAX	= 0;				
0033A:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0033B:      	AR	= -3
0033C:      	I1	= rm[BP_SAVE]
0033D:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0033E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0033F:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_80;		
00340:      	if ZR	jmp L5589D4CE_80
            ; //	sAX	= 1;				
00341:      	AX	= 0x01
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //	sfx_CHECKZERO();			
00342:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_81;	
00343:      	if NZ	jmp L5589D4CE_81
            ; //	goto	L5589D4CE_79;			
00344:      	jmp	L5589D4CE_79
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	
            ; //_A2C562ABC_226:;				
            _A2C562ABC_226:
            ; //	sSI	= (int)&_pkey_1_10;		
00345:      	AR	= -4
00346:      	I1	= rm[BP_SAVE]
00347:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00348:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00349:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0034A:      	AR	= CX
0034B:      	AX	+= AR
            ; //	sDI	= sAX;				
0034C:      	AR	= AX
0034D:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0034E:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0034F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_83;	
00350:      	if NZ	jmp L5589D4CE_83
            ; //	goto	L5589D4CE_82;			
00351:      	jmp	L5589D4CE_82
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //_A2C562ABC_227:;				
            _A2C562ABC_227:
            ; //_A2C562ABC_228:;				
            _A2C562ABC_228:
            ; //	sSI	= (int)&_pkey_1_10;		
00352:      	AR	= -4
00353:      	I1	= rm[BP_SAVE]
00354:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00355:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00356:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00357:      	AR	= CX
00358:      	AX	+= AR
            ; //	sDI	= sAX;				
00359:      	AR	= AX
0035A:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0035B:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0035C:      	AR	= AX
0035D:      	P1	= AR
0035E:      	P1.hh	= 0
0035F:      	fcall	pm[P1]
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //_A2C562ABC_229:;				
            _A2C562ABC_229:
            ; //	goto L5589D4CE_84;			
00360:      	jmp	L5589D4CE_84
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //	
            ; //_A2C562ABC_230:;				
            _A2C562ABC_230:
            ; //	sSI	= (int)&_pkey_1_10;		
00361:      	AR	= -4
00362:      	I1	= rm[BP_SAVE]
00363:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00364:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00365:      	AR	= AX
00366:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00367:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
00368:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_86;	
00369:      	if NZ	jmp L5589D4CE_86
            ; //	goto	L5589D4CE_85;			
0036A:      	jmp	L5589D4CE_85
            ; //L5589D4CE_86:;					
            L5589D4CE_86:
            ; //_A2C562ABC_231:;				
            _A2C562ABC_231:
            ; //_A2C562ABC_232:;				
            _A2C562ABC_232:
            ; //	sSI	= (int)&_pkey_1_10;		
0036B:      	AR	= -4
0036C:      	I1	= rm[BP_SAVE]
0036D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0036E:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
0036F:      	AR	= AX
00370:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00371:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00372:      	AR	= AX
00373:      	P1	= AR
00374:      	P1.hh	= 0
00375:      	fcall	pm[P1]
            ; //L5589D4CE_85:;					
            L5589D4CE_85:
            ; //_A2C562ABC_233:;				
            _A2C562ABC_233:
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //_A2C562ABC_234:;				
            _A2C562ABC_234:
            ; //	goto L5589D4CE_87;			
00376:      	jmp	L5589D4CE_87
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //	
            ; //_A2C562ABC_235:;				
            _A2C562ABC_235:
            ; //	sAX	= 0;				
00377:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
00378:      	AR	= -3
00379:      	I1	= rm[BP_SAVE]
0037A:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0037B:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0037C:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_89;		
0037D:      	if ZR	jmp L5589D4CE_89
            ; //	sAX	= 1;				
0037E:      	AX	= 0x01
            ; //L5589D4CE_89:;					
            L5589D4CE_89:
            ; //	sfx_CHECKZERO();			
0037F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_90;	
00380:      	if NZ	jmp L5589D4CE_90
            ; //	goto	L5589D4CE_88;			
00381:      	jmp	L5589D4CE_88
            ; //L5589D4CE_90:;					
            L5589D4CE_90:
            ; //	
            ; //_A2C562ABC_236:;				
            _A2C562ABC_236:
            ; //	sSI	= (int)&_pkey_1_10;		
00382:      	AR	= -4
00383:      	I1	= rm[BP_SAVE]
00384:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00385:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00386:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
00387:      	AR	= CX
00388:      	AX	+= AR
            ; //	sDI	= sAX;				
00389:      	AR	= AX
0038A:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0038B:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0038C:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_92;	
0038D:      	if NZ	jmp L5589D4CE_92
            ; //	goto	L5589D4CE_91;			
0038E:      	jmp	L5589D4CE_91
            ; //L5589D4CE_92:;					
            L5589D4CE_92:
            ; //_A2C562ABC_237:;				
            _A2C562ABC_237:
            ; //_A2C562ABC_238:;				
            _A2C562ABC_238:
            ; //	sSI	= (int)&_pkey_1_10;		
0038F:      	AR	= -4
00390:      	I1	= rm[BP_SAVE]
00391:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00392:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00393:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
00394:      	AR	= CX
00395:      	AX	+= AR
            ; //	sDI	= sAX;				
00396:      	AR	= AX
00397:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00398:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00399:      	AR	= AX
0039A:      	P1	= AR
0039B:      	P1.hh	= 0
0039C:      	fcall	pm[P1]
            ; //L5589D4CE_91:;					
            L5589D4CE_91:
            ; //_A2C562ABC_239:;				
            _A2C562ABC_239:
            ; //L5589D4CE_88:;					
            L5589D4CE_88:
            ; //_A2C562ABC_240:;				
            _A2C562ABC_240:
            ; //L5589D4CE_87:;					
            L5589D4CE_87:
            ; //_A2C562ABC_241:;				
            _A2C562ABC_241:
            ; //_A2C562ABC_242:;				
            _A2C562ABC_242:
            ; //	sSI	= (int)&_bits_1_6;		
0039D:      	AR	= -2
0039E:      	I1	= rm[BP_SAVE]
0039F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003A0:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003A1:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
003A2:      	AR	= -2
003A3:      	I1	= rm[BP_SAVE]
003A4:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003A5:      	rm[I1]	= AX
            ; //_A2C562ABC_243:;				
            _A2C562ABC_243:
            ; //	sSI	= (int)&_bitp_1_8;		
003A6:      	AR	= -3
003A7:      	I1	= rm[BP_SAVE]
003A8:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003A9:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003AA:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
003AB:      	AR	= -3
003AC:      	I1	= rm[BP_SAVE]
003AD:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003AE:      	rm[I1]	= AX
            ; //_A2C562ABC_244:;				
            _A2C562ABC_244:
            ; //	sSI	= (int)&_pkey_1_10;		
003AF:      	AR	= -4
003B0:      	I1	= rm[BP_SAVE]
003B1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003B2:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
003B3:      	AR	= -4
003B4:      	I1	= rm[BP_SAVE]
003B5:      	I1	+= AR
            ; //	asm AR = 0x0003;			
003B6:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
003B7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003B8:      	rm[I1] = CX + AR//
            ; //_A2C562ABC_245:;				
            _A2C562ABC_245:
            ; //	goto L5589D4CE_74;			
003B9:      	jmp	L5589D4CE_74
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //L5589D4CE_68:;					
            L5589D4CE_68:
            ; //_A2C562ABC_246:;				
            _A2C562ABC_246:
            ; //	return;					
003BA:      	AR	= 5
003BB:      	BP	+= AR
003BC:      	pop	AR
003BD:      	rm[BP_SAVE]	= AR
003BE:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_A2C562ABC_247:;				
            _A2C562ABC_247:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> Start=========================
            ; led.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //void _KeyShowLEDA84888EC();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //void _KeyShowLEDA84888EC()			
            _KeyShowLEDA84888EC:
            ; //{
            ; //_A2C562ABC_248:;				
            _A2C562ABC_248:
            ; //	
            ; //_A2C562ABC_249:;				
            _A2C562ABC_249:
            ; //	sAX	= 0x0001;			
003BF:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
003C0:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
003C2:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
003C3:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003C4:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_95;		
003C5:      	if ZR	jmp L7573600E_95
            ; //	asm set io[0x09].b0;			
003C6:      	set io[0x09].b0//
            ; //	goto	L7573600E_96;			
003C7:      	pch =	L7573600E_96
003C8:      	ljmp	L7573600E_96
            ; //L7573600E_95:;					
            L7573600E_95:
            ; //	asm clr io[0x09].b0;			
003C9:      	clr io[0x09].b0//
            ; //L7573600E_96:;					
            L7573600E_96:
            ; //_A2C562ABC_250:;				
            _A2C562ABC_250:
            ; //	sAX	= 0x0002;			
003CA:      	AX	= 0x02
            ; //	asm I1 = dtxtonech+7;			
003CB:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
003CD:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
003CE:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003CF:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_97;		
003D0:      	if ZR	jmp L7573600E_97
            ; //	asm set io[0x09].b1;			
003D1:      	set io[0x09].b1//
            ; //	goto	L7573600E_98;			
003D2:      	pch =	L7573600E_98
003D3:      	ljmp	L7573600E_98
            ; //L7573600E_97:;					
            L7573600E_97:
            ; //	asm clr io[0x09].b1;			
003D4:      	clr io[0x09].b1//
            ; //L7573600E_98:;					
            L7573600E_98:
            ; //L7573600E_94:;					
            L7573600E_94:
            ; //_A2C562ABC_251:;				
            _A2C562ABC_251:
            ; //	return;					
003D5:      	rets
            ; //_KeyShowLEDA84888EC_end:;			
            _KeyShowLEDA84888EC_end:
            ; //_A2C562ABC_252:;				
            _A2C562ABC_252:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> Start=========================
            ; sub3play.c Code Start!!;
            VarRM[0:4095]={
             bts_ch0_get_ix[2],PCMYIN_PTR,PCMYOU_PTR,PCMIN,SampleCh0Rate,BaseOn512#PCMY[512],SUBFLTI[4],SUBFLTA
            ,SUBFLTP,SUBFLTG 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _ClearRenderBufB079D01D();
            ; //rjmp void _Sub3Initial96BE24F3();
            ; //rjmp void _Sub3ZeroFillABFF23AA();
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1);
            ; //rjmp void Sbb_Ch0GetBts();
            ; //rjmp void _Sbb_SkipdataE1C72441(__int16 _offset_0_4_0, __int16 _offset_0_4_1);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _ClearRenderBufB079D01D()		
            _ClearRenderBufB079D01D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
003D6:      	AR	= rm[BP_SAVE]
003D7:      	push	AR
003D8:      	AR	= BP
003D9:      	rm[BP_SAVE]	= AR
003DA:      	AR	 = -1
003DB:      	BP	+= AR
            ; //_A2C562ABC_253:;				
            _A2C562ABC_253:
            ; //	
            ; //_A2C562ABC_254:;				
            _A2C562ABC_254:
            ; //	asm AX = PCMY+0;			
003DC:      	AX = PCMY+0//
            ; //_A2C562ABC_255:;				
            _A2C562ABC_255:
            ; //	asm	AR = AX				
003DE:      	AR = AX
            ; //_A2C562ABC_256:;				
            _A2C562ABC_256:
            ; //	asm	I0 = AR				
003DF:      	I0 = AR
            ; //	
            ; //	
            ; //_A2C562ABC_257:;				
            _A2C562ABC_257:
            ; //	_i_1_2+0	= 0x0200;		
003E0:      	I1	= rm[BP_SAVE]
003E1:      	AX	= 0x0200
003E3:      	rm[I1]	= AX
            ; //LFB78B58C_102:;					
            LFB78B58C_102:
            ; //_A2C562ABC_258:;				
            _A2C562ABC_258:
            ; //	sSI	= (int)&_i_1_2;			
003E4:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003E5:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003E6:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003E7:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003E8:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003E9:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003EA:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_103;	
003EB:      	if NZ	jmp LFB78B58C_103
            ; //	goto	LFB78B58C_101;			
003EC:      	jmp	LFB78B58C_101
            ; //LFB78B58C_103:;					
            LFB78B58C_103:
            ; //	
            ; //_A2C562ABC_259:;				
            _A2C562ABC_259:
            ; //	sAX	= 0x0000;			
003ED:      	AX	= 0x00
            ; //_A2C562ABC_260:;				
            _A2C562ABC_260:
            ; //	asm	rm[I0++] = AX			
003EE:      	rm[I0++] = AX
            ; //_A2C562ABC_261:;				
            _A2C562ABC_261:
            ; //	goto LFB78B58C_102;			
003EF:      	jmp	LFB78B58C_102
            ; //LFB78B58C_101:;					
            LFB78B58C_101:
            ; //LFB78B58C_100:;					
            LFB78B58C_100:
            ; //_A2C562ABC_262:;				
            _A2C562ABC_262:
            ; //	return;					
003F0:      	AR	= 1
003F1:      	BP	+= AR
003F2:      	pop	AR
003F3:      	rm[BP_SAVE]	= AR
003F4:      	rets
            ; //_ClearRenderBufB079D01D_end:;			
            _ClearRenderBufB079D01D_end:
            ; //_A2C562ABC_263:;				
            _A2C562ABC_263:
            ; //}
            ; //
            ; //rjmp void _Sub3Initial96BE24F3()		
            _Sub3Initial96BE24F3:
            ; //{
            ; //_A2C562ABC_264:;				
            _A2C562ABC_264:
            ; //_A2C562ABC_265:;				
            _A2C562ABC_265:
            ; //	asm	dsi				
003F5:      	dsi
            ; //_A2C562ABC_266:;				
            _A2C562ABC_266:
            ; //	asm	nop				
003F6:      	nop
            ; //	
            ; //	
            ; //_A2C562ABC_267:;				
            _A2C562ABC_267:
            ; //_A2C562ABC_268:;				
            _A2C562ABC_268:
            ; //	_ClearRenderBufB079D01D();		
003F7:      	pch	= _ClearRenderBufB079D01D
003F8:      	lcall	_ClearRenderBufB079D01D
            ; //_A2C562ABC_269:;				
            _A2C562ABC_269:
            ; //	asm	AR = PASR,0			
003F9:      	AR = PASR,0
            ; //_A2C562ABC_270:;				
            _A2C562ABC_270:
            ; //	asm AX = PCMY+0;			
003FA:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
003FC:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
003FD:      	rm[I1]	= AX
            ; //_A2C562ABC_271:;				
            _A2C562ABC_271:
            ; //	asm AX = PCMY+0;			
003FE:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
00400:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00401:      	rm[I1]	= AX
            ; //_A2C562ABC_272:;				
            _A2C562ABC_272:
            ; //	io[0x3C]	= 0x0000;		
00402:      	AR	= 0x00
00403:      	io[0x3C]	= AR
            ; //_A2C562ABC_273:;				
            _A2C562ABC_273:
            ; //	io[0x3E]	= 0x1FFF;		
00404:      	AR	= 0x1FFF
00406:      	io[0x3E]	= AR
            ; //_A2C562ABC_274:;				
            _A2C562ABC_274:
            ; //	io[0x3B]	= 0x0000;		
00407:      	AR	= 0x00
00408:      	io[0x3B]	= AR
            ; //_A2C562ABC_275:;				
            _A2C562ABC_275:
            ; //_A2C562ABC_276:;				
            _A2C562ABC_276:
            ; //	Subb3_Init();				
00409:      	pch	= Subb3_Init
0040A:      	lcall	Subb3_Init
            ; //LFB78B58C_104:;					
            LFB78B58C_104:
            ; //_A2C562ABC_277:;				
            _A2C562ABC_277:
            ; //	return;					
0040B:      	rets
            ; //_Sub3Initial96BE24F3_end:;			
            _Sub3Initial96BE24F3_end:
            ; //_A2C562ABC_278:;				
            _A2C562ABC_278:
            ; //}
            ; //
            ; //rjmp void _Sub3ZeroFillABFF23AA()		
            _Sub3ZeroFillABFF23AA:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
0040C:      	AR	= rm[BP_SAVE]
0040D:      	push	AR
0040E:      	AR	= BP
0040F:      	rm[BP_SAVE]	= AR
00410:      	AR	 = -1
00411:      	BP	+= AR
            ; //_A2C562ABC_279:;				
            _A2C562ABC_279:
            ; //_A2C562ABC_280:;				
            _A2C562ABC_280:
            ; //	asm	push CBL			
00412:      	push CBL
            ; //	
            ; //_A2C562ABC_281:;				
            _A2C562ABC_281:
            ; //	io[0x3B]	= 0x0009;		
00413:      	AR	= 0x09
00414:      	io[0x3B]	= AR
            ; //	
            ; //_A2C562ABC_282:;				
            _A2C562ABC_282:
            ; //	asm I1 = PCMYIN_PTR+0;			
00415:      	I1 = PCMYIN_PTR+0//
            ; //	sAX	= *(__int16*)sSI;		
00416:      	AX	= rm[I1]
            ; //_A2C562ABC_283:;				
            _A2C562ABC_283:
            ; //	asm	AR = AX				
00417:      	AR = AX
            ; //_A2C562ABC_284:;				
            _A2C562ABC_284:
            ; //	asm	I0 = AR				
00418:      	I0 = AR
            ; //	
            ; //_A2C562ABC_285:;				
            _A2C562ABC_285:
            ; //	_i_1_2+0	= 0x0120;		
00419:      	I1	= rm[BP_SAVE]
0041A:      	AX	= 0x0120
0041C:      	rm[I1]	= AX
            ; //LFB78B58C_107:;					
            LFB78B58C_107:
            ; //_A2C562ABC_286:;				
            _A2C562ABC_286:
            ; //	sSI	= (int)&_i_1_2;			
0041D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0041E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0041F:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00420:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00421:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00422:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00423:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_108;	
00424:      	if NZ	jmp LFB78B58C_108
            ; //	goto	LFB78B58C_106;			
00425:      	jmp	LFB78B58C_106
            ; //LFB78B58C_108:;					
            LFB78B58C_108:
            ; //	
            ; //_A2C562ABC_287:;				
            _A2C562ABC_287:
            ; //	sAX	= 0x0000;			
00426:      	AX	= 0x00
            ; //_A2C562ABC_288:;				
            _A2C562ABC_288:
            ; //	asm	rm[I0++] = AX			
00427:      	rm[I0++] = AX
            ; //_A2C562ABC_289:;				
            _A2C562ABC_289:
            ; //	goto LFB78B58C_107;			
00428:      	jmp	LFB78B58C_107
            ; //LFB78B58C_106:;					
            LFB78B58C_106:
            ; //_A2C562ABC_290:;				
            _A2C562ABC_290:
            ; //_A2C562ABC_291:;				
            _A2C562ABC_291:
            ; //	get_I0();				
00429:      	push	I0
0042A:      	pop	AX
            ; //	asm I1 = PCMYIN_PTR+0;			
0042B:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
0042C:      	rm[I1]	= AX
            ; //_A2C562ABC_292:;				
            _A2C562ABC_292:
            ; //	asm	pop CBL				
0042D:      	pop CBL
            ; //LFB78B58C_105:;					
            LFB78B58C_105:
            ; //_A2C562ABC_293:;				
            _A2C562ABC_293:
            ; //	return;					
0042E:      	AR	= 1
0042F:      	BP	+= AR
00430:      	pop	AR
00431:      	rm[BP_SAVE]	= AR
00432:      	rets
            ; //_Sub3ZeroFillABFF23AA_end:;			
            _Sub3ZeroFillABFF23AA_end:
            ; //_A2C562ABC_294:;				
            _A2C562ABC_294:
            ; //}
            ; //
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1)
            _Sub3Play422CAD6D:
            ; //{						
00433:      	AR	= rm[BP_SAVE]
00434:      	push	AR
00435:      	AR	= BP
00436:      	rm[BP_SAVE]	= AR
            ; //_A2C562ABC_295:;				
            _A2C562ABC_295:
            ; //	
            ; //_A2C562ABC_296:;				
            _A2C562ABC_296:
            ; //_A2C562ABC_297:;				
            _A2C562ABC_297:
            ; //	dtxStopSong();				
00437:      	pch	= dtxStopSong
00438:      	lcall	dtxStopSong
            ; //_A2C562ABC_298:;				
            _A2C562ABC_298:
            ; //	sSI	= (int)&_sdata_0_4_0;		
00439:      	AR	= 2
0043A:      	I1	= rm[BP_SAVE]
0043B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI++;		
0043C:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
0043D:      	DX	= rm[I1--]
            ; //	asm I1 = bts_ch0_get_ix+0;		
0043E:      	I1 = bts_ch0_get_ix+0//
            ; //	sfx_STORSILONG();			
0043F:      	rm[I1++]	= AX
00440:      	rm[I1--]	= DX
            ; //_A2C562ABC_299:;				
            _A2C562ABC_299:
            ; //_A2C562ABC_300:;				
            _A2C562ABC_300:
            ; //	_Sub3Initial96BE24F3();			
00441:      	pch	= _Sub3Initial96BE24F3
00442:      	lcall	_Sub3Initial96BE24F3
            ; //_A2C562ABC_301:;				
            _A2C562ABC_301:
            ; //	asm AX = SUBFLTI+0;			
00443:      	AX = SUBFLTI+0//
            ; //	PUSH(sAX);				
00444:      	push	AX
            ; //	sAX	= 0x0000;			
00445:      	AX	= 0x00
            ; //	sSI	= POP();			
00446:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00447:      	rm[I1]	= AX
            ; //_A2C562ABC_302:;				
            _A2C562ABC_302:
            ; //	asm AX = SUBFLTI+1;			
00448:      	AX = SUBFLTI+1//
            ; //	PUSH(sAX);				
00449:      	push	AX
            ; //	sAX	= 0x0000;			
0044A:      	AX	= 0x00
            ; //	sSI	= POP();			
0044B:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0044C:      	rm[I1]	= AX
            ; //_A2C562ABC_303:;				
            _A2C562ABC_303:
            ; //	asm AX = SUBFLTI+2;			
0044D:      	AX = SUBFLTI+2//
            ; //	PUSH(sAX);				
0044E:      	push	AX
            ; //	sAX	= 0x0000;			
0044F:      	AX	= 0x00
            ; //	sSI	= POP();			
00450:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00451:      	rm[I1]	= AX
            ; //_A2C562ABC_304:;				
            _A2C562ABC_304:
            ; //	asm AX = SUBFLTI+3;			
00452:      	AX = SUBFLTI+3//
            ; //	PUSH(sAX);				
00453:      	push	AX
            ; //	sAX	= 0x0000;			
00454:      	AX	= 0x00
            ; //	sSI	= POP();			
00455:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00456:      	rm[I1]	= AX
            ; //_A2C562ABC_305:;				
            _A2C562ABC_305:
            ; //	sAX	= 0x0000;			
00457:      	AX	= 0x00
            ; //	asm I1 = SUBFLTA+0;			
00458:      	I1 = SUBFLTA+0//
            ; //	*(__int16*)sSI	= sAX			
00459:      	rm[I1]	= AX
            ; //_A2C562ABC_306:;				
            _A2C562ABC_306:
            ; //	asm I1 = SampleCh0Rate+0;		
0045A:      	I1 = SampleCh0Rate+0//
            ; //	sAX	= *(__int16*)sSI;		
0045B:      	AX	= rm[I1]
            ; //	asm I1 = SUBFLTP+0;			
0045C:      	I1 = SUBFLTP+0//
            ; //	*(__int16*)sSI	= sAX			
0045D:      	rm[I1]	= AX
            ; //_A2C562ABC_307:;				
            _A2C562ABC_307:
            ; //	sAX	= 0x003F;			
0045E:      	AX	= 0x3F
            ; //	asm I1 = SUBFLTG+0;			
0045F:      	I1 = SUBFLTG+0//
            ; //	*(__int16*)sSI	= sAX			
00460:      	rm[I1]	= AX
            ; //_A2C562ABC_308:;				
            _A2C562ABC_308:
            ; //	asm	set io[INTENA].b0		
00461:      	set io[INTENA].b0
            ; //_A2C562ABC_309:;				
            _A2C562ABC_309:
            ; //	asm	eni				
00462:      	eni
            ; //LFB78B58C_109:;					
            LFB78B58C_109:
            ; //_A2C562ABC_310:;				
            _A2C562ABC_310:
            ; //	return;					
00463:      	pop	AR
00464:      	rm[BP_SAVE]	= AR
00465:      	rets
            ; //_Sub3Play422CAD6D_end:;				
            _Sub3Play422CAD6D_end:
            ; //_A2C562ABC_311:;				
            _A2C562ABC_311:
            ; //}
            ; //
            ; //rjmp void Sbb_Ch0GetBts()			
            Sbb_Ch0GetBts:
            ; //{
            ; //_A2C562ABC_312:;				
            _A2C562ABC_312:
            ; //_A2C562ABC_313:;				
            _A2C562ABC_313:
            ; //	asm	push I1				
00466:      	push I1
            ; //_A2C562ABC_314:;				
            _A2C562ABC_314:
            ; //	asm	push P1				
00467:      	push P1
            ; //_A2C562ABC_315:;				
            _A2C562ABC_315:
            ; //	asm	push AX				
00468:      	push AX
            ; //_A2C562ABC_316:;				
            _A2C562ABC_316:
            ; //	asm	push BX				
00469:      	push BX
            ; //_A2C562ABC_317:;				
            _A2C562ABC_317:
            ; //	asm	push CX				
0046A:      	push CX
            ; //_A2C562ABC_318:;				
            _A2C562ABC_318:
            ; //	asm	push DX				
0046B:      	push DX
            ; //_A2C562ABC_319:;				
            _A2C562ABC_319:
            ; //	asm	AR = P1.hh			
0046C:      	AR = P1.hh
            ; //_A2C562ABC_320:;				
            _A2C562ABC_320:
            ; //	asm	push AR				
0046D:      	push AR
            ; //	
            ; //_A2C562ABC_321:;				
            _A2C562ABC_321:
            ; //_A2C562ABC_322:;				
            _A2C562ABC_322:
            ; //_A2C562ABC_323:;				
            _A2C562ABC_323:
            ; //	asm I1 = bts_ch0_get_ix+0;		
0046E:      	I1 = bts_ch0_get_ix+0//
            ; //	sAX	= *(__int16*)sSI++;		
0046F:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00470:      	DX	= rm[I1--]
            ; //	sSI	= (int)&bts_ch0_get_ix[0];	
00471:      	I1	= bts_ch0_get_ix
            ; //	PUSH(sAX);				
00472:      	push	AX
            ; //	PUSH(sDX);				
00473:      	push	DX
            ; //	sfx_GETSILONG_BXCX();			
00474:      	CX	= rm[I1++]
00475:      	BX	= rm[I1--]
            ; //	sAX = 0x0001;				
00476:      	AX	= 0x01
            ; //	sDX = 0x0000;				
00477:      	DX	= 0x00
            ; //	sfx_ADDLONG_BXCX_DXAX();		
00478:      	AR	= AX
00479:      	CX	= CX + AR
0047A:      	AR	= DX
0047B:      	BX	= BX + AR + C
            ; //	sfx_STORSILONG_BXCX();			
0047C:      	rm[I1++]	= CX
0047D:      	rm[I1--]	= BX
            ; //	sDX	= POP();			
0047E:      	pop	DX
            ; //	sAX	= POP();			
0047F:      	pop	AX
            ; //	PUSH(sDX);				
00480:      	push	DX
            ; //	PUSH(sAX);				
00481:      	push	AX
            ; //	_lptr_read(STACK[sSP + 0], STACK[sSP + 1]);
00482:      	pch	= _lptr_read
00483:      	lcall	_lptr_read
            ; //	RESTORESP(2);				
00484:      	pop	AR
00485:      	pop	AR
            ; //	PUSH(sAX);				
00486:      	push	AX
            ; //	vXCHG(STACK[sSP + 0]);			
00487:      	AR	= AX
00488:      	AX	= xchg AR
            ; //	RESTORESP(1);				
00489:      	pop	AR
            ; //_A2C562ABC_324:;				
            _A2C562ABC_324:
            ; //	asm	pop AR				
0048A:      	pop AR
            ; //_A2C562ABC_325:;				
            _A2C562ABC_325:
            ; //	asm	P1.hh = AR			
0048B:      	P1.hh = AR
            ; //_A2C562ABC_326:;				
            _A2C562ABC_326:
            ; //	asm	pop DX				
0048C:      	pop DX
            ; //_A2C562ABC_327:;				
            _A2C562ABC_327:
            ; //	asm	pop CX				
0048D:      	pop CX
            ; //_A2C562ABC_328:;				
            _A2C562ABC_328:
            ; //	asm	pop BX				
0048E:      	pop BX
            ; //	
            ; //_A2C562ABC_329:;				
            _A2C562ABC_329:
            ; //_A2C562ABC_330:;				
            _A2C562ABC_330:
            ; //	asintax();				
            ; //_A2C562ABC_331:;				
            _A2C562ABC_331:
            ; //	asm	AR = AX				
0048F:      	AR = AX
            ; //_A2C562ABC_332:;				
            _A2C562ABC_332:
            ; //	asm	pop AX				
00490:      	pop AX
            ; //_A2C562ABC_333:;				
            _A2C562ABC_333:
            ; //	asm	pop P1				
00491:      	pop P1
            ; //_A2C562ABC_334:;				
            _A2C562ABC_334:
            ; //	asm	pop I1				
00492:      	pop I1
            ; //LFB78B58C_110:;					
            LFB78B58C_110:
            ; //_A2C562ABC_335:;				
            _A2C562ABC_335:
            ; //	return;					
00493:      	rets
            ; //Sbb_Ch0GetBts_end:;				
            Sbb_Ch0GetBts_end:
            ; //_A2C562ABC_336:;				
            _A2C562ABC_336:
            ; //}
            ; //
            ; //rjmp void _Sbb_SkipdataE1C72441(__int16 _offset_0_4_0, __int16 _offset_0_4_1)
            _Sbb_SkipdataE1C72441:
            ; //{
            ; //						
00494:      	AR	= rm[BP_SAVE]
00495:      	push	AR
00496:      	AR	= BP
00497:      	rm[BP_SAVE]	= AR
            ; //LFB78B58C_111:;					
            LFB78B58C_111:
            ; //_A2C562ABC_337:;				
            _A2C562ABC_337:
            ; //	return;					
00498:      	pop	AR
00499:      	rm[BP_SAVE]	= AR
0049A:      	rets
            ; //_Sbb_SkipdataE1C72441_end:;			
            _Sbb_SkipdataE1C72441_end:
            ; //_A2C562ABC_338:;				
            _A2C562ABC_338:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> End=========================
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> Start=========================
            
            ; ~.~------------------------------------------
            ; void PWM_ENTRY(void) interrupt 0
            ; ---------------------------------------------
            PWM_ENTRY:
            ; {
0049B:      	clr 		io[INTREQ].b0	; Clear Int0 Request!!
            
0049C:      	push		AX
0049D:      	push		BX
0049E:      	push		CX
0049F:      	push		DX
004A0:      	push		I0
004A1:      	push		I1
004A2:      	push		P1
004A3:      	AR=		P1.hh
004A4:      	push		AR
004A5:      	push		MX
004A6:      	push		MR0
004A7:      	push		MR1
004A8:      	push		MR2
004A9:      	push		CBL
            #ifdef _MSPEECHDSP_
            
            #else
004AA:      	AR=		MACOP
004AB:      	push		AR
004AC:      	MACOP=		0
            #endif
            
004AD:      	CBL=		0
            
004AE:      	I1=		dtxRender
004B0:      	io[DACL]=	rm[I1++2]
004B1:      	io[DACL]=	rm[I1++2]
004B2:      	io[DACL]=	rm[I1++2]
004B3:      	io[DACL]=	rm[I1++2]
            
            	; dtxDoChannel();
004B4:      		PCH=		dtxDoChannel
004B5:      		lcall		dtxDoChannel
            
            	; if(dtxnote)
004B6:      		I1=		dtxnote
004B8:      		AX=		rm[I1++]
004B9:      		AR=		rm[I1]
004BA:      		AR=		AR | AX
004BB:      		if ZR jmp	@pwm_label_1615
            	; {
            
            		; dtxDoEvent();
004BC:      			PCH=		dtxDoEvent
004BD:      			lcall		dtxDoEvent
            	; }
            	@pwm_label_1615:
            
            	
            	; -=-=-=-=-=-=-=-=-=-
            	; dtx + subband3 sound mix
            
004BE:      	I1=		SUBFLTI
004BF:      	FLTI=		rm[I1++]
004C0:      	FLTI=		rm[I1++]
004C1:      	FLTI=		rm[I1++]
004C2:      	FLTI=		rm[I1++]
004C3:      	FLTA=		rm[I1++]
004C4:      	FLTP=		rm[I1++]
004C5:      	FLTG=		rm[I1]
004C6:      	AR=		FLTO
            
004C7:      	MX=		1
004C8:      	CBL=		9
            
004C9:      	I1=		dtxRender
004CB:      	I0=		rm[PCMYOU_PTR]
004CC:      	CX=		3
            @pwm_loop_1340:
004CD:      	if FA jmp	@pwm_label_1340
            
004CE:      	AR=		rm[I0++]
004CF:      	FLTI=		AR
            @pwm_label_1340:
004D0:      	AR=		FLTO
            
            #ifdef _MSPEECHDSP_	
            	MULSS
            #else
004D1:      	MR=		MX * AR
            #endif
            	; ~~ can not use SATV because subband3 use it already
004D2:      	AX=		rm[I1++]
004D3:      	AR=		MR0
004D4:      	AX=		AX + AR
004D5:      	AR=		rm[I1--]
004D6:      	AR=		AR + MR1 + C
004D7:      	if AN jmp	@pwm_label_1021
004D8:      	SF=		AR - 0
004D9:      	if NE jmp	@pwm_label_1149
004DA:      	test		AX.b15
004DB:      	if ZR jmp	@pwm_label_1022
            @pwm_label_1149:
004DC:      	AX=		0x7FFF
004DE:      	jmp		@pwm_label_1022
            @pwm_label_1021:
004DF:      	SF=		AR - 0xFF
004E0:      	if NE jmp	@pwm_label_1149_1
004E1:      	test		AX.b15
004E2:      	if NZ jmp	@pwm_label_1022
            @pwm_label_1149_1:
004E3:      	AX=		0x8001
            @pwm_label_1022:
004E5:      	rm[I1++2]=	AX
004E6:      	loop		@pwm_loop_1340
            
004E7:      	I1=		SUBFLTI
004E8:      	rm[I1++]=	FLTI
004E9:      	rm[I1++]=	FLTI
004EA:      	rm[I1++]=	FLTI
004EB:      	rm[I1++]=	FLTI
004EC:      	rm[I1++]=	FLTA
            
004ED:      	rm[PCMYOU_PTR]=	I0
            
            	; -=-=-=-=-=-=-=-=-=-
            
            
            #ifdef _MSPEECHDSP_
            
            #else
004EE:      	pop		AR
004EF:      	MACOP=		AR
            #endif
004F0:      	pop		CBL
004F1:      	pop		MR2
004F2:      	pop		MR1
004F3:      	pop		MR0
004F4:      	pop		MX
004F5:      	pop		AR
004F6:      	P1.hh=		AR
004F7:      	pop		P1
004F8:      	pop		I1
004F9:      	pop		I0
004FA:      	pop		DX
004FB:      	pop		CX
004FC:      	pop		BX
004FD:      	pop		AX
004FE:      	reti
            
            PWM_ENTRY_END:	
            ; }
            
            
            
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> End=========================
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> Start=========================
            
            
            ; ~~ assembly function in C form...
            
            ; ---------------------------------------------
            
            ; --------------------------------------------------------------
            
            
            ChangePWMIntToDynCache:
            
            
            #ifdef PRAM_BANK
            	P1=		#PWM_ENTRY
            	AX=		#PWM_ENTRY_END
            	PCH=		sfx_DynFindPRG
            	lcall		sfx_DynFindPRG
            	if NZ jmp	@chpwmi_label_1757
            
            	rets
            @chpwmi_label_1757:
            	PCH=		sfx_DynBooking
            	lcall		sfx_DynBooking
            	if ZR jmp	@chpwmi_label_1758
            
            	rets
            @chpwmi_label_1758:
            	PCH=		sfx_DynCache
            	lcall		sfx_DynCache
            
            
            	; P0 is point to entry
            
            	set             io[STATUS].b13
            	I1=		PCMY
            	
            	CX=		DSP_VECT_SUPPORT - 2
            @cpitm_loop_1836:
            	AR=		io[IntVect]                      ;
            	rm[I1++]=	AR                           ;	; Int5~0
            	AR=		PCB
            	rm[I1++]=	AR                           ;	; Int5~0 PCB
            	loop            @cpitm_loop_1836
            
            
            	AR=		P0
            	AR++
            	rm[I1++]=	AR
            	AR=		P0.hh
            	rm[I1++]=	AR
            
            	clr		io[STATUS].b13
            
            	
            	; ~~ write new vector table
            
            	set             io[STATUS].b13
            	I1=		PCMY
            
            	CX=		DSP_VECT_SUPPORT - 1
            @cpitm_loop_1837:
            	AX=		rm[I1++]
            	AR=		rm[I1++]
            	PCB=		AR
            	AR=		AX
            	io[IntVect]=	AR
            	PCB=		0
            	loop		@cpitm_loop_1837
            
            	; Dis-int-vector table access
            	clr		io[STATUS].b13
            	P0.hh=		0
            #endif
            
004FF:      	rets
            
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> End=========================
            
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> Start=========================
            ; data.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void melody();
            ; //naked void subdat0();
            ; //naked void subdat1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void melody()				
            melody:
            ; //{
            ; //	asm	DW "dtx\gamedtx_32K_4CH_mp.dtx"	
033C5:      DW "dtx\gamedtx_32K_4CH_mp.dtx"
            ; //}
            ; //
            ; //naked void subdat0()				
            subdat0:
            ; //{
            ; //	asm	DW "subband3\Airport_16K@39K5bps.t3z"
0BFCA:      DW "subband3\Airport_16K@39K5bps.t3z"
            ; //}
            ; //
            ; //naked void subdat1()				
            subdat1:
            ; //{
            ; //	asm	DW "subband3\06_Story_12K1@27K8bps.t3z"
15894:      DW "subband3\06_Story_12K1@27K8bps.t3z"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
00500:      	AR=		BP
00501:      	AR=		AR + 1		; ~~ value
00502:      	I1=		AR
00503:      	AR=		SATV
00504:      	AR=		rm[I1++]
00505:      	SATV=		AR
00506:      	AR=		rm[I1++]
00507:      	SATV=		AR
00508:      	AR=		SATV
00509:      	AX=		AR
0050A:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
0050B:      	AR=		BP
0050C:      	AR=		AR + 1		; ~~ value
0050D:      	I1=		AR
0050E:      	ADPHD=		rm[I1]
0050F:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
00510:      	AR=		ADPHD
00511:      	AX=		AR
00512:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
00513:      	AR=		BP
00514:      	AR=		AR + 1		; ~~ value
00515:      	I1=		AR
00516:      	ADPDAT=		rm[I1]
00517:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
00518:      	AR=		ADPDAT
00519:      	AX=		AR
0051A:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
0051B:      	AR=		ADPPCM
0051C:      	AX=		AR
0051D:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
0051E:      	AR=		CBL
0051F:      	AX=		AR
00520:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
00521:      	AR=		FLTO
00522:      	AX=		AR
00523:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
00524:      	AR=		FLTA
00525:      	AX=		AR
00526:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
00527:      	AR=		FLTP
00528:      	AX=		AR
00529:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
0052A:      	set		io[STATUS].b5
0052B:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
0052C:      	clr		io[STATUS].b5
0052D:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
0052E:      	set		io[STATUS].b8
0052F:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
00530:      	clr		io[STATUS].b8
00531:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
00532:      	set		io[STATUS].b9
00533:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
00534:      	clr		io[STATUS].b9
00535:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
00536:      	set		io[STATUS].b11
00537:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
00538:      	clr		io[STATUS].b11
00539:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
0053A:      	set		io[STATUS].b12
0053B:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
0053C:      	clr		io[STATUS].b12
0053D:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
0053E:      	set		io[STATUS].b13
0053F:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
00540:      	clr		io[STATUS].b13
00541:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
00542:      	AR=		BP
00543:      	AR=		AR + 1		; ~~ value
00544:      	I1=		AR
00545:      	AR=		rm[I1]
00546:      	io[INTENA]=	AR
00547:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
00548:      	AR=		io[INTENA]
00549:      	AX=		AR
0054A:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
0054B:      	AR=		BP
0054C:      	AR=		AR + 1		; ~~ value
0054D:      	I1=		AR
0054E:      	AR=		rm[I1]
0054F:      	io[INTREQ]	=AR
00550:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
00551:      	AR=		io[INTREQ]
00552:      	AX=		AR
00553:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
00554:      	AR=		BP
00555:      	AR=		AR + 1		; ~~ value
00556:      	I1=		AR
00557:      	AR=		rm[I1]
00558:      	io[IntVect]	=AR
00559:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
0055A:      	AR=		io[IntVect]
0055B:      	AX=		AR
0055C:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
0055D:      	AR=		io[IOC_PA]
0055E:      	AX=		AR
0055F:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
00560:      	AR=		io[IOC_PB]
00561:      	AX=		AR
00562:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
00563:      	AR=		io[IOC_PC]
00564:      	AX=		AR
00565:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
00566:      	AR=		io[PortA]
00567:      	AX=		AR
00568:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
00569:      	AR=		io[PortB]
0056A:      	AX=		AR
0056B:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
0056C:      	AR=		io[PortC]
0056D:      	AX=		AR
0056E:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
0056F:      	AR=		BP
00570:      	AR=		AR + 1		; ~~ value
00571:      	I1=		AR
00572:      	AR=		rm[I1]
00573:      	io[SPI_CTL]=	AR
00574:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
00575:      	AR=		io[SPI_CTL]
00576:      	AX=		AR
00577:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
00578:      	AR=		BP
00579:      	AR=		AR + 1		; ~~ value
0057A:      	I1=		AR
0057B:      	AR=		rm[I1]
0057C:      	io[SPI_DAT]=	AR
0057D:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
0057E:      	AR=		io[SPI_DAT]
0057F:      	AX=		AR
00580:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
00581:      	AR=		BP
00582:      	AR=		AR + 1		; ~~ value
00583:      	I1=		AR
00584:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
00585:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
00586:      	AR=		io[MISC]
00587:      	AX=		AR
00588:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
00589:      	AX=		AR
0058A:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
0058B:      	AR=		MACOP
0058C:      	AX=		AR
0058D:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
0058E:      	AR=		BP
0058F:      	AR=		AR + 1
00590:      	I1=		AR
00591:      	AR=		rm[I1]
00592:      	xchg		AR
00593:      	AX=		AR
00594:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
00595:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
00596:      	AX=		rm[I0]
00597:      	rets
            
            read_I0P:
00598:      	AX=		rm[I0++]
00599:      	rets
            
            read_I0P2:
0059A:      	AX=		rm[I0++2]
0059B:      	rets
            
            read_I0M:
0059C:      	AX=		rm[I0--]
0059D:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
0059E:      	AR=		I0
0059F:      	AX=		AR
005A0:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
005A1:      	AX=		pm[P0]
005A2:      	rets
            
            read_P0P:
005A3:      	AX=		pm[P0++]
005A4:      	rets
            
            read_P0M:
005A5:      	AX=		pm[P0--]
005A6:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
005A7:      	AR=		P0
005A8:      	AX=		AR
005A9:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
005AA:      	AX=		1
005AB:      	if FA jmp	@fa_label_1504
005AC:      	AX=		0
            @fa_label_1504:
005AD:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> Start=========================
            _lptr_read:
005AE:      	AR=		DX
005AF:      	test		AR.b11
005B0:      	if ZR jmp	@_lptr_read_label_1510
            
005B1:      	P1.hh=		AR
005B2:      	AR=		AX
005B3:      	P1=		AR
005B4:      	AX=		pm[P1]
005B5:      	P1.hh=		0
005B6:      	rets
            
            @_lptr_read_label_1510:
            
005B7:      	AR=		AX
005B8:      	I1=		AR
005B9:      	AX=		rm[I1]
005BA:      	rets
            
            
            _lptr_read32:
005BB:      	AR=		DX
005BC:      	test		AR.b11
005BD:      	if ZR jmp	@_lptr_read_label_1510_32
            
005BE:      	P1.hh=		AR
005BF:      	AR=		AX
005C0:      	P1=		AR
005C1:      	AX=		pm[P1++]
005C2:      	DX=		pm[P1]
005C3:      	P1.hh=		0
005C4:      	rets
            
            @_lptr_read_label_1510_32:
            
005C5:      	AR=		AX
005C6:      	I1=		AR
005C7:      	AX=		rm[I1++]
005C8:      	DX=		rm[I1]
005C9:      	rets
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> Start=========================
            
            
            _ClearTickCount5DDE4003:
            #ifdef _MFDSP_
            	set		io[MISC].b8
            #else
005CA:      	set		io[MISC].b7
            #endif
005CB:      	set		io[MISC].b15
            	
005CC:      	io[REAL_T]=	AR
005CD:      	AR=		io[REAL_T]
005CE:      	AR=		io[REAL_T]
005CF:      	io[REAL_T]=	AR
005D0:      	rets
            
            ; -----------------------------------------------
            
            _GetTickCount18DC070C:
005D1:      	AX=		0xFFF0
            @gettickcount_loop_1000:
005D3:      	io[ClrWDT]=	AR
005D4:      	AR=		io[REAL_T]
005D5:      	AR=		AR & AX
005D6:      	SF=		AR - AX
005D7:      	if ZR jmp	@gettickcount_loop_1000
005D8:      	AX=		AR
005D9:      	AR=		io[REAL_T]
005DA:      	DX=		AR
005DB:      	rets
            
            	
            ; -----------------------------------------------
            ; void delay(int ms)
            ;
            ; in:
            ;     BP + 1 - int ms
            ;
            ; -----------------------------------------------
            _delay6F9F34ED:
            ; {
005DC:      	AR=		BP
005DD:      	AR=		AR + 1		; ~~ port
005DE:      	I1=		AR
            
            	; unsigned long tick;
            	; unsigned long msr;
            
            	; ~~ 1ms = 32768 ticks
            
            	; msr = (unsigned long)ms << 15;
005DF:      		R0=		0
005E0:      		R1=		rm[I1]
005E1:      		clr		C
005E2:      		src		R1, 1
005E3:      		src		R0, 1
            	
            	; tick = GetTickCount();
005E4:      		call		_GetTickCount18DC070C
005E5:      		AR=		AX
005E6:      		CX=		AR
005E7:      		AR=		DX
005E8:      		BX=		AR
            	
            	; while((GetTickCount() - tick) < msr);
            	@delay_loop_1024:
005E9:      		call		_GetTickCount18DC070C
005EA:      		AR=		CX
005EB:      		AX=		AX - AR
005EC:      		AR=		BX
005ED:      		DX=		DX - AR + C - 1
005EE:      		AR=		R0
005EF:      		AX=		AX - AR
005F0:      		AR=		R1
005F1:      		DX=		DX - AR + C - 1
005F2:      		AR=		0
005F3:      		AR=		AR - 0 + C - 1
005F4:      		if AN jmp	@delay_loop_1024
            
005F5:      	rets
            ; }
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> End=========================
            
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libdtx\dtx.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> Start=========================
            ; .\lib\libsubb3\sub3_cshell.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXDOCHANNEL.OBJ"
            ;
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> Start=========================
            
            
            
            
            
            
            
            #define MAX_DTX_CHANNEL		4
            
            ; -----------------------------------------------------
            
            
            #define DTX_SET_CH1_INS		0
            #define DTX_SET_CH2_INS		1
            #define DTX_SET_CH4_INS		2
            #define DTX_RESERVE3		3
            #define DTX_CHANGE_CH1_VOL	4
            #define DTX_CHANGE_CH2_VOL	5
            #define DTX_CHANGE_CH3_VOL	6
            #define DTX_CHANGE_CH4_VOL	7
            #define DTX_USER_CMD		8
            #define DTX_REST		9
            #define DTX_SET_NOTEOFF		10
            #define DTX_END_SONG		11
            
            
            ; -----------------------------------------------------
            
            
            #define DTX_TONE_ENVADR		0
            #define DTX_TONE_ENVSTA		2
            #define DTX_TONE_TONE		4
            #define DTX_TONE_TONECNT	5
            #define DTX_TONE_FLTG		6
            #define DTX_TONE_MOD		7
            
            #define DTX_TONE_SIZEOF		8
            
            #define DTX_TONE_CH		(DTX_TONE_SIZEOF*3)
            
            ; -----------------------------------------------------
            
            #define DTX_PERC_INSADR		0
            #define DTX_PERC_INSADR_H	1
            #define DTX_PERC_FLTG		2
            #define DTX_PERC_FLTI		3
            #define DTX_PERC_FLTA		7
            #define DTX_PERC_FLTP		8
            #define DTX_PERC_ADPCM_HD	9
            #define DTX_PERC_ADPCM_S0	10
            #define DTX_PERC_ADPCM_S1	11
            #define DTX_PERC_ADPCM_CNT	12
            #define DTX_PERC_ADPCM_BUF	13
            #define DTX_PERC_MASK		14
            
            #define DTX_PERC_SIZEOF		15
            
            ; -----------------------------------------------------
            
            
            VarRM[0:127] = {
            
            	dtxfltg,
            
            
            }
            
            
            
            VarRM[512:4095] = {
            
            	dtxbaseadr[2]
            	dtxinsbase[2]
            	dtxpercbase[2]
            	dtxsonghdr[2]
            	dtxnote[2]
            	dtxsongcnt
            	dtxtonech[DTX_TONE_CH]			; 3 channel tone
            	dtxperc[DTX_PERC_SIZEOF]
            
            	dtxPlayInfo
            	dtxPlayChannel
            	dtxReleaseCh
            	dtxBaseTimer
            	dtxEventTimer
            
            	dtxRender[8]
            }
            
            
            #define dtxbaseadr_l		dtxbaseadr
            #define dtxbaseadr_h		dtxbaseadr+1
            #define dtxinsbase_l		dtxinsbase
            #define dtxinsbase_h		dtxinsbase+1
            #define dtxpercbase_l		dtxpercbase
            #define dtxpercbase_h		dtxpercbase+1
            #define dtxsonghdr_l		dtxsonghdr
            #define dtxsonghdr_h		dtxsonghdr+1
            #define dtxnote_h		dtxnote+1
            
            
            
            ShareVar = {
            
            
            }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            DTX_TONE_FREQ:
00765:      	DW 0x7A01, 0x7302, 0x6D00, 0x6603, 0x6100, 0x5B02, 0x5602, 0x5102,
0076D:      	DW 0x4D00, 0x4803, 0x4403, 0x4003, 0x3D01, 0x3903, 0x3602, 0x3302,
00775:      	DW 0x3002, 0x2D03, 0x2B01, 0x2803, 0x2602, 0x2401, 0x2201, 0x2002,
0077D:      	DW 0x1E02, 0x1C03, 0x1B01, 0x1903, 0x1801, 0x1700, 0x1502, 0x1402,
00785:      	DW 0x1301, 0x1201, 0x1101, 0x1001, 0x0F01, 0x0E02, 0x0D02, 0x0C03,
0078D:      	DW 0x0C01, 0x0B02, 0x0A03, 0x0A01, 0x0902, 0x0900, 0x0802, 0x0800,
00795:      	DW 0x0702, 0x0701, 0x0603, 0x0602, 0x0600, 0x0503, 0x0502, 0x0500,
0079D:      	DW 0x0403, 0x0402, 0x0401, 0x0400,
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxInitialize:
            ; {
            	; dtxbaseadr = 0;
007A1:      		AR=		0
007A2:      		I1=		dtxbaseadr
007A4:      		rm[I1++]=	AR
007A5:      		rm[I1]=		AR
            
            	; dtxinsbase = 0;
007A6:      		I1=		dtxinsbase
007A8:      		rm[I1++]=	AR
007A9:      		rm[I1]=		AR
            
            	; dtxpercbase = 0;
007AA:      		I1=		dtxpercbase
007AC:      		rm[I1++]=	AR
007AD:      		rm[I1]=		AR
            
            
007AE:      	jmp		dtxInitParameters
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxInitParameters:
            ; {
            	; dtxPlayInfo = 0;
007AF:      		I1=		dtxPlayInfo
007B1:      		rm[I1]=		AR
            
            	; dtxPlayChannel = 0;
007B2:      		I1=		dtxPlayChannel
007B4:      		rm[I1]=		AR
            
            	; dtxReleaseCh = 0;
007B5:      		I1=		dtxReleaseCh
007B7:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
007B8:      		I1=		dtxEventTimer
007BA:      		rm[I1]=		AR
            
            	; memset(dtxtonech, 0, sizeof(dtxtonech));
007BB:      		CX=		DTX_TONE_CH - 1
007BC:      		I1=		dtxtonech
            	@dtxinit_loop_0932:
007BE:      		rm[I1++]=	AR
007BF:      		loop		@dtxinit_loop_0932
            
            	; memset(&dtxperc, 0, sizeof(dtxperc));
007C0:      		CX=		DTX_PERC_SIZEOF - 1
007C1:      		I1=		dtxperc
            	@dtxinit_loop_1804:
007C3:      		rm[I1++]=	AR
007C4:      		loop		@dtxinit_loop_1804
            
            	; dtxBaseTimer = 0x001F;
007C5:      		AR=		0x001F
007C6:      		I1=		dtxBaseTimer
007C8:      		rm[I1]=		AR
            
            	#ifdef DTX_PRAM_START
            		CX=		#DTXPLAYER_PRAM_LARGE_END - 1
            		AR=		#DTXPLAYER_PRAM_LARGE_START
            		CX=		CX - AR
            		P1=		#DTXPLAYER_PRAM_LARGE_START
            		P0=		DTX_PRAM_START
            		P0.hh=		DTX_PRAM_BANK
            	@dtxinit_loop_0913:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		loop		@dtxinit_loop_0913
            		P0.hh=		0
            	#endif
            
007C9:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxReadTune:
            ; {
            	; ~~ read tone modtune
            
            	; spiContReadStart(dtxbaseadr + 12, &dtx);
007CA:      		I1=		dtxbaseadr
007CC:      		AR=		rm[I1++]
007CD:      		AR=		AR + 12
007CE:      		AX=		AR
007CF:      		AR=		rm[I1]
007D0:      		AR=		AR + 0 + C
007D1:      		push		AR
007D2:      		push		AX
007D3:      		AR=		BP
007D4:      		AR=		AR + 2
007D5:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
007D6:      AR= rm[I1 -- ] 
007D7:      P1 = rm[I1] 
007D8:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
007D9:      		pop		AR
007DA:      		pop		AR
            
            	; dtxtonech[0].Mod = spiContReadByte();
007DB:      		I1=		dtxtonech + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
007DD:      PCH = SfContReadByte 
007DE:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
007DF:      		rm[I1]=		AR
            
            	; dtxtonech[1].Mod = spiContReadByte();
007E0:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
007E2:      PCH = SfContReadByte 
007E3:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
007E4:      		rm[I1]=		AR
            
            	; tmp = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
007E5:      PCH = SfContReadWord 
007E6:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
007E7:      		push		AR
            
            	; dtxtonech[2].Mod = spiContReadWord() >> 8;
007E8:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF + DTX_TONE_MOD
007EA:      		AL=		0
007EB:      		xchg		AR
007EC:      		rm[I1]=		AR
            		
            	; dtxperc.Mask = (tmp & 0x00FF) ? 0xFFFF : 0xFFF0;
007ED:      		I1=		dtxperc + DTX_PERC_MASK
007EF:      		pop		AR
007F0:      		AH=		0
007F1:      		SF=		AR - 0
007F2:      		if ZR jmp	@dtxreadtune_label_1349
            
007F3:      		AR=		0xFFFF
007F5:      		jmp		@dtxreadtune_label_1349_1
            	@dtxreadtune_label_1349:
007F6:      		AR=		0xFFF0
            	@dtxreadtune_label_1349_1:
007F8:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
007F9:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
007FA:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; bool dtxDoEvent(void)
            dtxDoEvent:
            ; {
            	; DSP16 AX;
            	; int i, mask, cmd;
            
            	; BaseTimer = (BaseTimer + 1) & 0x003F;
007FB:      		I1=		dtxBaseTimer
007FD:      		AR=		rm[I1]
007FE:      		AR++
007FF:      		AR=		AR & 0x3F
00800:      		rm[I1]=		AR
            
            
            	; switch(BaseTimer)
00801:      		SF=		AR - 0
00802:      		if EQ jmp	@dtxdoe_case0_label_1906
00803:      		SF=		AR - 0x20
00804:      		if EQ jmp	@dtxdoe_case20_label_1906
00805:      		jmp		@dtxdoe_case_default_1909
            	; {
            		; case 0:
            		@dtxdoe_case0_label_1906:
            		; {
            			; mask = 0x01;
00806:      				I1=		dtxPlayChannel
00808:      				AX=		rm[I1]
            
            			; for(i = 0; i < MAX_DTX_CHANNEL; i++)
00809:      				CX=		MAX_DTX_CHANNEL - 1
0080A:      				BX=		dtxtonech
0080C:      				DX=		1
            			@dtxdoe_loop_0911:
            			; {
            				; if(PlayChannel & mask)
0080D:      					sra		AX, 1
0080E:      					if NC jmp	@dtxdoe_label_0913
            				; {
            					; if(i != 2)		// perc
0080F:      						test		DX.b2
00810:      						if NZ jmp	@dtxdoe_label_0916
            					; {
            						; ch[i].tone.envadr++;
00811:      							AR=		BX
00812:      							I1=		AR	; DTX_TONE_ENVADR
00813:      							AR=		rm[I1]
00814:      							AR++
00815:      							rm[I1++]=	AR
00816:      							AR=		rm[I1]
00817:      							AR=		AR + 0 + C
00818:      							rm[I1]=		AR
            					; }
            					@dtxdoe_label_0916:
            				; }
            				@dtxdoe_label_0913:
            
            				; mask <<= 1;
00819:      					test		DX.b2
0081A:      					if NZ jmp	@dtxdoe_label_1614
0081B:      						AR=		DTX_TONE_SIZEOF
0081C:      						BX=		BX + AR
            					@dtxdoe_label_1614:
0081D:      					slz		DX, 1
            
0081E:      				loop		@dtxdoe_loop_0911
            			; }
            		; }
            
            		; case 0x0020:
            		@dtxdoe_case20_label_1906:
            		; {
            			; dtxEventTimer--;
0081F:      				I1=		dtxEventTimer
00821:      				AR=		rm[I1]
00822:      				AR--
00823:      				rm[I1]=		AR
            
            			; if(EventTimer != 0xFFFF)
00824:      				SF=		AR - 0xFF
00825:      				if EQ jmp	@dtxdoe_label_0919
            			; {
            				; return true;
            			; }
            
            			; break;
            		; }
            
            		; default:
            		@dtxdoe_case_default_1909:
            		; {
            			; return true;
00826:      				set		Z
00827:      				rets
            		; }
            	; }
            	@dtxdoe_label_0919:
            
            
            	; spiContReadStart(dtxnote, &dtx);
00828:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
0082A:      AR= rm[I1 -- ] 
0082B:      P1 = rm[I1] 
0082C:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; ~~            byte 0                         byte 1
            	; ~~ +-----------------------------+-----------------------------+
            	; ~~ |      H             L        |      H              L       |
            	; ~~ +--------------+--------------+--------------+--------------+
            	; ~~ | Note Timer H | Note Timer M | Note Timer L |   PlayInfo   |
            	; ~~ +--------------+--------------+--------------+--------------+
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
0082D:      PCH = SfContReadByte 
0082E:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer = (AX.U << 4);
0082F:      		I1=		dtxEventTimer
00831:      		AX=		AR
00832:      		slz		AX, 2
00833:      		slz		AX, 2
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
00834:      PCH = SfContReadByte 
00835:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer |= (AX.U >> 4);
00836:      		push		AR
00837:      		sra		AR, 2
00838:      		sra		AR, 2
00839:      		rm[I1]=		AR | AX
0083A:      		AX=		rm[I1]
            
            	; dtxPlayInfo = (unsigned long)(AX.U & 0x000F);
0083B:      		pop		AR
0083C:      		I1=		dtxPlayInfo
0083E:      		AR=		AR & 0x0F
0083F:      		rm[I1]=		AR
            
            	; dtxnote += 2;
00840:      		I1=		dtxnote
00842:      		AR=		rm[I1]
00843:      		AR=		AR + 2
00844:      		rm[I1++]=	AR
00845:      		AR=		rm[I1]
00846:      		AR=		AR + 0 + C
00847:      		rm[I1]=		AR
            
            	; if(!dtxPlayInfo)
00848:      		I1=		dtxPlayInfo
0084A:      		AR=		rm[I1]
0084B:      		if NZ jmp	@dtxdoe_label_0933
            	; {
            		; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
0084C:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
0084D:      			clr		Z
0084E:      			rets
            	; }
            	@dtxdoe_label_0933:
            
            	; // ---
            
            	; while(PlayInfo)
            	@dtxdoe_loop_1400:
0084F:      		io[ClrWDT]=	AR
00850:      		I1=		dtxPlayInfo
00852:      		AR=		rm[I1]
00853:      		if ZR jmp	@dtxdoe_label_0935
            	; {
            		; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
00854:      PCH = SfContReadByte 
00855:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00856:      			AX=		AR
            
            		; note++;
00857:      			I1=		dtxnote
00859:      			AR=		rm[I1]
0085A:      			AR++
0085B:      			rm[I1++]=	AR
0085C:      			AR=		rm[I1]
0085D:      			AR=		AR + 0 + C
0085E:      			rm[I1]=		AR
            
            		; //          byte 3
            		; // +---------------------+
            		; //      H           L
            		; // +---+-------+---------+
            		; // | 1 | 0 0 0 | x x x x |   command
            		; // +---+-------+---------+
            		; //           or
            		; // +---+-------+---------+
            		; // | y | y y y | x x x x |   data
            		; // +---+-------+---------+
            
            
            		; if(AX.N1 == 0x08)
0085F:      			AR=		0x00F0
00861:      			AR=		AR & AX
00862:      			AH=		0xFF
00863:      			SF=		AR - 0x80
00864:      			if NE jmp	@dtxdoe_label_0939
            		; {
            			; // command prc
            
            			; note++;
00865:      				I1=		dtxnote
00867:      				AR=		rm[I1]
00868:      				AR++
00869:      				rm[I1++]=	AR
0086A:      				AR=		rm[I1]
0086B:      				AR=		AR + 0 + C
0086C:      				rm[I1]=		AR
            
            			; cmd = AX.N0;
0086D:      				AR=		0x0F
0086E:      				AR=		AX & AR
0086F:      				push		AR
            
            			; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
00870:      PCH = SfContReadByte 
00871:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00872:      				AX=		AR
            
            			; switch(cmd)
00873:      				pop		AR
00874:      				SF=		AR - DTX_SET_CH1_INS
00875:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH1_INS_label_0948
00876:      				SF=		AR - DTX_SET_CH2_INS
00877:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH2_INS_label_0948
00878:      				SF=		AR - DTX_SET_CH4_INS
00879:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH4_INS_label_0948
0087A:      				SF=		AR - DTX_CHANGE_CH1_VOL
0087B:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948
0087C:      				SF=		AR - DTX_CHANGE_CH2_VOL
0087D:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948
0087E:      				SF=		AR - DTX_CHANGE_CH3_VOL
0087F:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948
00880:      				SF=		AR - DTX_CHANGE_CH4_VOL
00881:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948
00882:      				SF=		AR - DTX_REST
00883:      				if EQ jmp	@dtxdoe_case_DTX_REST_label_0948
00884:      				SF=		AR - DTX_SET_NOTEOFF
00885:      				if EQ jmp	@dtxdoe_case_DTX_SET_NOTEOFF_label_0948
00886:      				SF=		AR - DTX_END_SONG
00887:      				if GE jmp	@dtxdoe_case_DTX_END_SONG_label_0948
00888:      				jmp		@dtxdoe_label_0955
            			; {
            				; case DTX_SET_CH1_INS:
            				@dtxdoe_case_DTX_SET_CH1_INS_label_0948:
            				; {
            					; SetTone(&ch[0].tone, (int)AX.U);
00889:      						BX=		dtxtonech
0088B:      						call		dtxSetTone
            					; break;
0088C:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH2_INS:
            				@dtxdoe_case_DTX_SET_CH2_INS_label_0948:
            				; {
            					; SetTone(&ch[1].tone, (int)AX.U);
0088D:      						BX=		dtxtonech + DTX_TONE_SIZEOF
0088F:      						call		dtxSetTone
            					; break;
00890:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH4_INS:
            				@dtxdoe_case_DTX_SET_CH4_INS_label_0948:
            				; {
            					; SetTone(&ch[3].tone, (int)AX.U);
00891:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
00893:      						call		dtxSetTone
            					; break;
00894:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_RESERVE3:
            					; break;
            
            				; case DTX_CHANGE_CH1_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[0], (int)AX.U);
00895:      						BX=		dtxtonech
00897:      						call		dtxSetToneFLTG
            					; break;
00898:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH2_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[1], (int)AX.U);
00899:      						BX=		dtxtonech + DTX_TONE_SIZEOF
0089B:      						call		dtxSetToneFLTG
            					; break;
0089C:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH3_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[2], (int)AX.U);
0089D:      						BX=		dtxperc
0089F:      						call		dtxSetPercFLTG
            					; break;
008A0:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH4_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[3], (int)AX.U);
008A1:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
008A3:      						call		dtxSetToneFLTG
            					; break;
008A4:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_USER_CMD:
            					; break;
            
            				; case DTX_REST:
            				@dtxdoe_case_DTX_REST_label_0948:
            				; {
            					; //       H           L
            					; // +---------+--------------------------------+
            					; // | 0 0 0 0 | active bit for tone ctrl / flag|
            					; // +---------+--------------------------------+
            
            					; // TONE_FLAG as PlayChannel
            
            					; dtxPlayChannel &= (unsigned long)~AX.U;
008A5:      						AR=		-1
008A6:      						AX=		AX ^ AR
008A7:      						I1=		dtxPlayChannel
008A9:      						AR=		rm[I1]
008AA:      						rm[I1]=		AR & AX
            
            					; dtxPlayInfo &= (unsigned long)~AX.U;
008AB:      						I1=		dtxPlayInfo
008AD:      						AR=		rm[I1]
008AE:      						rm[I1]=		AR & AX
            
            					; break;
008AF:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_NOTEOFF:
            				@dtxdoe_case_DTX_SET_NOTEOFF_label_0948:
            				; {
            					; //       H           L
            					; // +---------+-----------------------------+
            					; // | 0 0 0 0 | active bit for CH_RAMP_FLAG |
            					; // +---------+-----------------------------+
            
            					; // CH_RAMP_FLAG as ReleaseChannel
            
            					; dtxReleaseCh |= (unsigned long)AX.U;
008B0:      						I1=		dtxReleaseCh
008B2:      						AR=		rm[I1]
008B3:      						rm[I1]=		AR | AX
            
            					; PlayInfo &= (unsigned long)~AX.U;
008B4:      						AR=		-1
008B5:      						AX=		AX ^ AR
008B6:      						I1=		dtxPlayInfo
008B8:      						AR=		rm[I1]
008B9:      						rm[I1]=		AR & AX
            
            					; break;
008BA:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_END_SONG:
            				@dtxdoe_case_DTX_END_SONG_label_0948:
            				; default:
            				; {
            					; dtxnote = 0;
008BB:      						I1=		dtxnote
008BD:      						AR=		0
008BE:      						rm[I1++]=	AR
008BF:      						rm[I1]=		AR
            
            					; dtxPlayChannel = 0;
008C0:      						I1=		dtxPlayChannel
008C2:      						rm[I1]=		AR
            
            					; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
008C3:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            					; return false;
008C4:      						clr		Z
008C5:      						rets
            				; }
            			; }
            			@dtxdoe_label_0955:
            
008C6:      			jmp		@dtxdoe_label_0939_1
            		; }
            		; else
            		@dtxdoe_label_0939:
            		; {
            			; // data prc
            
            			; SetChannelData(AX);
008C7:      				call		dtxSetChannelData
            		; }
            		@dtxdoe_label_0939_1:
            
008C8:      		jmp		@dtxdoe_loop_1400
            	; }
            	@dtxdoe_label_0935:
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
008C9:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; return true;
008CA:      		set		Z
008CB:      		rets
            ; }
            
            
            ; --------------------------------------------
            ; void SetTone(toneChannel *tonech, int ins)
            ;
            ; in:
            ;    tonech 	: BX
            ;    ins	: AX
            ;
            ; out:
            ;
            ;
            ; --------------------------------------------
            dtxSetTone:
            ; {
            	; unsigned long adr;
            	; DSP16 AX, BX;
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
008CC:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // read tone index map
            
            	; adr = dtxbaseadr + 16 + ins;
008CD:      		AR=		16
008CE:      		AX=		AX + AR
008CF:      		I1=		dtxbaseadr
008D1:      		AR=		rm[I1++]
008D2:      		AX=		AX + AR
008D3:      		AR=		rm[I1]
008D4:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr & ~1, &dtx);
008D5:      		push		AR
008D6:      		AR=		AX
008D7:      		clr		AR.b0
008D8:      		push		AR
008D9:      		AR=		BP
008DA:      		AR=		AR + 2
008DB:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
008DC:      AR= rm[I1 -- ] 
008DD:      P1 = rm[I1] 
008DE:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
008DF:      		pop		AR
008E0:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
008E1:      PCH = SfContReadWord 
008E2:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; // high byte
            
            	; if(adr & 0x01)
008E3:      		test		AX.b0
008E4:      		if ZR jmp	@dtxst_label_1018
            	; {
            		; AX.U >>= 8;
008E5:      			xchg		AR
008E6:      		jmp		@dtxst_label_1018_1
            	; }
            	; else
            	@dtxst_label_1018:
            	; {
            		; AX.H = 0x00;
            	; }
            	@dtxst_label_1018_1:
008E7:      		AH=		0
008E8:      		AX=		AR
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
008E9:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; AX.U <<= 2;
008EA:      		slz		AX, 2
            
            	; adr = dtxinsbase + AX.U;
008EB:      		I1=		dtxinsbase
008ED:      		AR=		rm[I1++]
008EE:      		AX=		AX + AR
008EF:      		AR=		rm[I1]
008F0:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr, &dtx);
008F1:      		push		AR
008F2:      		push		AX
008F3:      		AR=		BP
008F4:      		AR=		AR + 2
008F5:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
008F6:      AR= rm[I1 -- ] 
008F7:      P1 = rm[I1] 
008F8:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
008F9:      		pop		AR
008FA:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
008FB:      PCH = SfContReadWord 
008FC:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
008FD:      		AX=		AR
            
            	; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
008FE:      PCH = SfContReadWord 
008FF:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00900:      		push		AR
            
            	; tonech->envsta = baseadr + ((unsigned long)BX.U << 16) + (unsigned long)AX.U;
00901:      		I1=		dtxbaseadr + 1
00903:      		AR=		rm[I1--]
00904:      		push		AR
00905:      		AR=		rm[I1]
00906:      		push		AR
00907:      		AR=		DTX_TONE_ENVSTA
00908:      		AR=		AR + BX
00909:      		I1=		AR
0090A:      		pop		AR
0090B:      		rm[I1++]=	AR + AX
0090C:      		pop		AX
0090D:      		pop		AR
0090E:      		rm[I1--]=	AR + AX + C
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
0090F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // restore note pointer
            
            	; spiContReadStart(note, &dtx);
00910:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
00912:      AR= rm[I1 -- ] 
00913:      P1 = rm[I1] 
00914:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
00915:      	rets
            ; }
            
            ; --------------------------------------------
            ; void dtxSetToneFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetToneFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
00916:      		MX=		0x0888
00918:      		AR=		AX
            	#ifdef _MSPEECHDSP_
            		MULSS
            	#else
00919:      		MR=		MX * AR
            	#endif
0091A:      		AR=		DTX_TONE_FLTG
0091B:      		AR=		AR + BX
0091C:      		I1=		AR
            
            	; AR = 0
            	; MR0 = AR
            
0091D:      		rm[I1]=		MR0
            
0091E:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetPercFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetPercFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
            		; MX=		0x0888
            		; AR=		AX
            	; #ifdef _MSPEECHDSP_
            		; MULSS
            	; #else
            		; MR=		MX * AR
            	; #endif
            		; AR=		DTX_PERC_FLTG
            		; AR=		AR + BX
            		; I1=		AR
            		; rm[I1]=		MR0
            
0091F:      		slz		AX, 2
00920:      		set		AX.b0
00921:      		set		AX.b1
00922:      		AR=		DTX_PERC_FLTG
00923:      		AR=		AR + BX
00924:      		I1=		AR
            
            	; AX = 0
            
00925:      		rm[I1]=		AX
            
00926:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetChannelData(DSP16 AX)
            ;
            ; in:
            ;    AX		: AX
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetChannelData:
            ; {
            	; int i, adr;
            	; int mask;
            	; DSP16 BX;
            
            	; mask = 0x01;
00927:      		DX=		1
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
00928:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; for(i = 0; i < MAX_DTX_CHANNEL; i++)
00929:      		CX=		MAX_DTX_CHANNEL - 1
0092A:      		I1=		dtxPlayInfo
0092C:      		BX=		rm[I1]
0092D:      		MX=		dtxtonech
            	@dtxscd_loop_1128:
            	; {
            		; if(PlayInfo & mask)
0092F:      			src		BX, 1
00930:      			if NC jmp	@dtxscd_label_1129
            		; {
            			; if(ch[i].type == dtxChannel::TONE_CHANNEL)
00931:      				test		DX.b2
00932:      				if NZ jmp	@dtxscd_label_1130
            			; {
            				; // read FREQ table in real chip
            
            				; ch[i].tone.envadr = ch[i].tone.envsta;
00933:      					push		BX
00934:      					push		DX
00935:      					AR=		DTX_TONE_ENVSTA
00936:      					AR=		MX + AR
00937:      					I1=		AR
00938:      					BX=		rm[I1++]
00939:      					DX=		rm[I1]
0093A:      					AR=		MX		; DTX_TONE_ENVADR
0093B:      					I1=		AR
0093C:      					rm[I1++]=	BX
0093D:      					rm[I1]=		DX
0093E:      					pop		DX
0093F:      					pop		BX
            
            				; ch[i].tone.TONE.FREQ = DTX_TONE_FREQ[AX.U];
00940:      					AR=		DTX_TONE_TONE
00941:      					AR=		AR + MX
00942:      					I1=		AR
00943:      					P1=		#DTX_TONE_FREQ	; ~~ read stop !!
00946:      					AR=		AX
00947:      					P1=		P1 + AR
00948:      					rm[I1++]=	pm[P1]
            
            				; ch[i].tone.TONECNT.FREQ = 0;
00949:      					AR=		0
0094A:      					rm[I1]=		AR
            
            
0094B:      				jmp		@dtxscd_label_1130_1
            			; }
            			; else
            			@dtxscd_label_1130:
            			; {
            				; memset(&dtxperc, 0, sizeof(dtxperc));
0094C:      					push		CX
0094D:      					I1=		dtxperc + DTX_PERC_FLTI
0094F:      					CX=		DTX_PERC_SIZEOF - 5
00950:      					AR=		0
            				@dtxscd_loop_1337:
00951:      					rm[I1++]=	AR
00952:      					loop		@dtxscd_loop_1337
00953:      					pop		CX
            
            				; // perc索引在 + 128的位址
            
            				; adr = dtxbaseadr + 16 + ((AX.U & 0x3F) | 0x80);
00954:      					AR=		0x3F
00955:      					AX=		AX & AR
00956:      					AR=		0x0090
00958:      					AX=		AX + AR
00959:      					I1=		dtxbaseadr
0095B:      					AR=		rm[I1++]
0095C:      					AX=		AX + AR
0095D:      					AR=		rm[I1]
0095E:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
0095F:      					push		AR
00960:      					push		AX
00961:      					AR=		BP
00962:      					AR=		AR + 2
00963:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
00964:      AR= rm[I1 -- ] 
00965:      P1 = rm[I1] 
00966:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00967:      					pop		AR
00968:      					pop		AR
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
00969:      PCH = SfContReadByte 
0096A:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
0096B:      					AX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
0096C:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; // 打擊樂資訊佔4 bytes
            
            				; AX.U <<= 2;
0096D:      					slz		AX, 2
            
            				; adr = dtxpercbase + AX.U;
0096E:      					I1=		dtxpercbase
00970:      					AR=		rm[I1++]
00971:      					AX=		AX + AR
00972:      					AR=		rm[I1]
00973:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
00974:      					push		AR
00975:      					push		AX
00976:      					AR=		BP
00977:      					AR=		AR + 2
00978:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
00979:      AR= rm[I1 -- ] 
0097A:      P1 = rm[I1] 
0097B:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0097C:      					pop		AR
0097D:      					pop		AR
            
            				; AX = spiContReadWord();
0097E:      					push		BX
0097F:      					push		DX
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00980:      PCH = SfContReadWord 
00981:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00982:      					BX=		AR
            
            				; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00983:      PCH = SfContReadWord 
00984:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00985:      					DX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
00986:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr = baseadr + (((unsigned long)BX.U & 0x00FF) << 16) + (unsigned long)AX.U;
00987:      					push		DX
00988:      					I1=		dtxbaseadr
0098A:      					DX.h=		0
0098B:      					AR=		rm[I1++]
0098C:      					BX=		BX + AR
0098D:      					AR=		rm[I1]
0098E:      					AR=		AR + DX + C
0098F:      					I1=		dtxperc
00991:      					rm[I1++]=	BX
00992:      					rm[I1++]=	AR
            
            				; // FLTP
            
            				; ch[i].perc.FLTP = (BX.U << 3) & 0xFF00;
00993:      					pop		AR
00994:      					slz		AR, 2
00995:      					slz		AR, 1
00996:      					AL=		0
00997:      					I1=		dtxperc + DTX_PERC_FLTP
00999:      					rm[I1]=		AR
0099A:      					pop		DX
0099B:      					pop		BX
            
            				; // pre-cache
            
            				; spiContReadStart(ch[i].perc.insadr, &dtx);
0099C:      					I1=		dtxperc + 1
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
0099E:      AR= rm[I1 -- ] 
0099F:      P1 = rm[I1] 
009A0:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
009A1:      PCH = SfContReadWord 
009A2:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            				; ch[i].perc.TASPAD.BUF = AX.S;
009A3:      					I1=		dtxperc + DTX_PERC_ADPCM_BUF
009A5:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
009A6:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr += 2;
009A7:      					I1=		dtxperc
009A9:      					AR=		rm[I1]
009AA:      					AR=		AR + 2
009AB:      					rm[I1++]=	AR
009AC:      					AR=		rm[I1]
009AD:      					AR=		AR + 0 + C
009AE:      					rm[I1]=		AR
            			; }
            			@dtxscd_label_1130_1:
            
            			; dtxPlayChannel |= mask;
009AF:      				I1=		dtxPlayChannel
009B1:      				AR=		rm[I1]
009B2:      				rm[I1]=		AR | DX
            
            			; dtxReleaseCh &= ~mask;
009B3:      				I1=		dtxReleaseCh
009B5:      				push		DX
009B6:      				AR=		-1
009B7:      				DX=		DX ^ AR
009B8:      				AR=		rm[I1]
009B9:      				rm[I1]=		AR & DX
            
            			; dtxPlayInfo &= ~mask;
009BA:      				I1=		dtxPlayInfo
009BC:      				AR=		rm[I1]
009BD:      				rm[I1]=		AR & DX
009BE:      				pop		DX
            
            			; if(PlayInfo)
009BF:      				AR=		rm[I1]
009C0:      				if ZR jmp	@dtxscd_label_1358
            			; {
            				; spiContReadStart(note, &dtx);
009C1:      					I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
009C3:      AR= rm[I1 -- ] 
009C4:      P1 = rm[I1] 
009C5:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7304,7307,,,,,,,,,,,,,,,,  strat ======
009C6:      PCH = SfContReadByte 
009C7:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
009C8:      					AX=		AR
            
            				; note++;
009C9:      					I1=		dtxnote
009CB:      					AR=		rm[I1]
009CC:      					AR++
009CD:      					rm[I1++]=	AR
009CE:      					AR=		rm[I1]
009CF:      					AR=		AR + 0 + C
009D0:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
009D1:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            			; }
            			@dtxscd_label_1358:
            		; }
            		@dtxscd_label_1129:
            
            		; mask <<= 1;
009D2:      			test		DX.b2
009D3:      			if NZ jmp	@dtxscd_label_1911
009D4:      				AR=		DTX_TONE_SIZEOF
009D5:      				MX=		MX + AR
            		@dtxscd_label_1911:
009D6:      			slz		DX, 1
            
009D7:      		loop		@dtxscd_loop_1128
            	; }
            
            	; spiContReadStart(note, &dtx);
009D8:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
009DA:      AR= rm[I1 -- ] 
009DB:      P1 = rm[I1] 
009DC:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
009DD:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; ~.~---------------------------------------------------
            ; bool dtxFindToneEntry(unsigned long flashadr)
            ;
            ; in:
            ;    AX:BX		- flashadr
            ;
            ; out:
            ;
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            dtxFindToneEntry:
            ; {
            	; dtxbaseadr = flashadr;
009DE:      		I1=		dtxbaseadr
            	#ifdef DTX_WORD_ADR
009E0:      		slz		BX, 1
009E1:      		slc		AX, 1
            	#endif
009E2:      		rm[I1++]=	BX
009E3:      		rm[I1]=		AX
            
            	; dtxsonghdr = flashadr;
009E4:      		I1=		dtxsonghdr
009E6:      		rm[I1++]=	BX
009E7:      		rm[I1]=		AX
            
            	; sfContReadStart(HIADR(&dtxbaseadr));
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
009E8:      AR= rm[I1 -- ] 
009E9:      P1 = rm[I1] 
009EA:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
009EB:      PCH = SfContReadWord 
009EC:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009ED:      		AX=		AR
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
009EE:      PCH = SfContReadWord 
009EF:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; ~~ check "DTX " mark
            
            	; if((AX != 0x5444) || (BX != 0x2058))
009F0:      		BX=		0x2058
009F2:      		SF=		AR - BX
009F3:      		if NZ jmp	@dtxfte_label_1821
009F4:      		AR=		0x5444
009F6:      		SF=		AR - AX
009F7:      		if NZ jmp	@dtxfte_label_1821
009F8:      		jmp		@dtxfte_label_1823
            	@dtxfte_label_1821:
            	; {
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
009F9:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
009FA:      			clr		Z
009FB:      			rets
            	; }
            	@dtxfte_label_1823:
            
            
            	; dtxinsbase = dtxbaseadr + (unsigned long)head->InsAddrEntry;
009FC:      		I1=		dtxbaseadr_l
009FE:      		AX=		rm[I1++]
009FF:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A00:      PCH = SfContReadWord 
00A01:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A02:      		AX=		AX + AR
00A03:      		AR=		0
00A04:      		BX=		BX + AR + C
00A05:      		I1=		dtxinsbase
00A07:      		rm[I1++]=	AX
00A08:      		rm[I1]=		BX
            
            	; dtxpercbase = dtxbaseadr + (unsigned long)head->PercAddrEntry;
00A09:      		I1=		dtxbaseadr_l
00A0B:      		AX=		rm[I1++]
00A0C:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A0D:      PCH = SfContReadWord 
00A0E:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A0F:      		AX=		AX + AR
00A10:      		AR=		0
00A11:      		BX=		BX + AR + C
00A12:      		I1=		dtxpercbase
00A14:      		rm[I1++]=	AX
00A15:      		rm[I1]=		BX
            
            	; dtxsonghdr = dtxbaseadr + (unsigned long)head->SongListEntry;
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A16:      PCH = SfContReadWord 
00A17:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A18:      		AX=		AR
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A19:      PCH = SfContReadWord 
00A1A:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A1B:      		BX=		AR
00A1C:      		I1=		dtxbaseadr_l
00A1E:      		AR=		rm[I1++]
00A1F:      		AX=		AX + AR
00A20:      		AR=		rm[I1]
00A21:      		BX=		BX + AR + C
00A22:      		I1=		dtxsonghdr
00A24:      		rm[I1++]=	AX
00A25:      		rm[I1]=		BX
            
            	; ~~
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
00A26:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; sfContReadStart(HIADR(&dtxsonghdr));
00A27:      		I1=		dtxsonghdr_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
00A29:      AR= rm[I1 -- ] 
00A2A:      P1 = rm[I1] 
00A2B:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; dtxsongcnt = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A2C:      PCH = SfContReadWord 
00A2D:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A2E:      		I1=		dtxsongcnt
00A30:      		rm[I1]=		AR
            
            	; dtxsonghdr += 2;
00A31:      		I1=		dtxsonghdr_l
00A33:      		AR=		rm[I1]
00A34:      		AR=		AR + 2
00A35:      		rm[I1++]=	AR
00A36:      		AR=		rm[I1]
00A37:      		AR=		AR + 0 + C
00A38:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
00A39:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; return true;
00A3A:      		set		Z
00A3B:      		rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~.~------------------------------------------------------------
            ; bool dtxPlaySong(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            dtxPlaySong:
            ; {
            	; if(index >= mp.songcnt)
00A3C:      		I1=		dtxsongcnt
00A3E:      		AR=		rm[I1]
00A3F:      		SF=		AR - AX
00A40:      		if LE jmp	@dtxplaysong_label_1541
00A41:      		jmp		@dtxplaysong_label_1541_1
            	@dtxplaysong_label_1541:
            	; {
            		; return false;
00A42:      			clr		Z
00A43:      			rets
            	; }
            	@dtxplaysong_label_1541_1:
            
            
            	; dtxnote = dtxsonghdr + (index * sizeof(long));
00A44:      		I1=		dtxsonghdr
00A46:      		BX=		rm[I1++]
00A47:      		DX=		rm[I1]
00A48:      		I1=		dtxnote
00A4A:      		AR=		AX
00A4B:      		slz		AR, 2
00A4C:      		rm[I1++]=	BX + AR
00A4D:      		AR=		0
00A4E:      		rm[I1]=		DX + AR + C
            
            	; sfContReadStart(HIADR(&dtxnote));
00A4F:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7291,7295,,,,,,,,,,,,,,,,  strat ======
00A51:      AR= rm[I1 -- ] 
00A52:      P1 = rm[I1] 
00A53:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; lo = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A54:      PCH = SfContReadWord 
00A55:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A56:      		BX=		AR
            
            	; hi = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7298,7301,,,,,,,,,,,,,,,,  strat ======
00A57:      PCH = SfContReadWord 
00A58:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A59:      		DX=		AR
            
            	; dtxnote = dtxbaseadr + (hi << 16) + lo;
00A5A:      		I1=		dtxbaseadr
00A5C:      		AR=		rm[I1++]
00A5D:      		BX=		BX + AR
00A5E:      		AR=		rm[I1]
00A5F:      		DX=		DX + AR + C
00A60:      		I1=		dtxnote
00A62:      		rm[I1++]=	BX
00A63:      		rm[I1]=		DX
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7310,7312,,,,,,,,,,,,,,,,  strat ======
00A64:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; dtxBaseTimer = 0x001F;
00A65:      		AR=		0x001F
00A66:      		I1=		dtxBaseTimer
00A68:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
00A69:      		I1=		dtxEventTimer
00A6B:      		rm[I1]=		AR
            
            	; dtxStartBGServe();
00A6C:      		PCH=		dtxStartBGServe
00A6D:      		lcall		dtxStartBGServe
            
            	; return true;
00A6E:      		set		Z
00A6F:      		rets
            ; }
            
            ; -----------------------------------------------
            
            
            dtxStopSong:
            ; {
00A70:      	I1=		dtxnote
00A72:      	AR=		0
00A73:      	rm[I1++]=	AR
00A74:      	rm[I1++]=	AR
            
00A75:      	I1=		dtxPlayChannel
00A77:      	rm[I1]=		AR
            
00A78:      	rets
            ; }
            
            
            ; -----------------------------------------------
            
            
            dtxCheckSongEnd:
            ; {
00A79:      	I1=		dtxnote
00A7B:      	AR=		rm[I1++]
00A7C:      	AX=		rm[I1]
00A7D:      	AR=		AR | AX
00A7E:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxStartBGServe:
            ; {
            	; ClearIntReq(INT0);
00A7F:      		clr		io[INTREQ].b0
            
            	; EnableInterrupt(INT0);
00A80:      		ena		INT0
            
            	; EnableInterrupts();
00A81:      		eni
            
00A82:      	rets
            ; }
            
            
            
            dtxStopBGServe:
            ; {
            	; DisableInterrupt(INT0);
00A83:      		dsi		INT0
            
            	; ClearIntReq(INT0);
00A84:      		clr		io[INTREQ].b0
            
00A85:      	rets
            ; }
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> Start=========================
            
            sfContReadByte:
            ; {
00A86:      	AR=		P1.hh
00A87:      	sra		AR, 1
00A88:      	P1.hh=		AR
00A89:      	src		P1, 1
00A8A:      	AR=		pm[P1]
00A8B:      	if NC jmp	@sfcrw_label_1736
00A8C:      	push		AR
00A8D:      	AR=		P1.hh
00A8E:      	slc		P1, 1
00A8F:      	slc		AR, 1
00A90:      	P1.hh=		AR
00A91:      	AR=		pm[P1++]
00A92:      	pop		AR
00A93:      	xchg		AR
00A94:      	jmp		@sfcrw_label_1813
            @sfcrw_label_1736:
00A95:      	push		AR
00A96:      	AR=		P1.hh
00A97:      	slc		P1, 1
00A98:      	slc		AR, 1
00A99:      	P1.hh=		AR
00A9A:      	AR=		pm[P1++]
00A9B:      	pop		AR
            @sfcrw_label_1813:
00A9C:      	AH=		0
00A9D:      	rets
            ; }
            
            
            ; ~~~~~~ no word align !!
            
            SfContReadWord:
            ; {
00A9E:      	AR=		P1.hh
00A9F:      	sra		AR, 1
00AA0:      	P1.hh=		AR
00AA1:      	src		P1, 1
00AA2:      	AR=		pm[P1++]
            	
00AA3:      	push		AR
00AA4:      	AR=		P1.hh
00AA5:      	slc		P1, 1
00AA6:      	slc		AR, 1
00AA7:      	P1.hh=		AR
00AA8:      	pop		AR
00AA9:      	rets
            ; }
            
            
            ; --------------------------------------------
            
            macro	mSfContReadStart
            	AR=		rm[I1--]
            	P1=		rm[I1]
            	P1.hh=		AR
            endm
            
            
            macro	mSfContReadWord
            	PCH=		SfContReadWord
            	lcall		SfContReadWord
            endm
            
            
            macro	mSfContReadByte
            	PCH=		SfContReadByte
            	lcall		SfContReadByte
            endm
            
            
            macro mSfContReadStop
            	P1.hh=		0
            endm
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> Start=========================
            
            
            _dtxDoEvent05EA2C8C:
00AAA:      	PCH=		dtxDoEvent
00AAB:      	lcall		dtxDoEvent
            L3F7E7BE2_0:
00AAC:      	AX=		0
00AAD:      	if NZ jmp	L3F7E7BE2_1
00AAE:      	AX=		1
            L3F7E7BE2_1:
00AAF:      	rets
            
            
            
            _dtxFindToneEntry12F3B4ED:
            ; DX:AX just right "flashadr"
00AB0:      	AR=		AX
00AB1:      	BX=		AR
00AB2:      	AR=		DX
00AB3:      	AX=		AR
00AB4:      	PCH=		dtxFindToneEntry
00AB5:      	lcall		dtxFindToneEntry
00AB6:      	jmp		L3F7E7BE2_0
            
            
            _dtxPlaySong5B7DBDA5:
            ; AX - just right "index"
00AB7:      	PCH=		dtxPlaySong
00AB8:      	lcall		dtxPlaySong
00AB9:      	jmp		L3F7E7BE2_0
            
            
            _dtxCheckSongEnd870A9712:
00ABA:      	PCH=		dtxCheckSongEnd
00ABB:      	lcall		dtxCheckSongEnd
00ABC:      	jmp		L3F7E7BE2_0
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ ".\LIB\LIBSUBB3\SBB3_CH0DECV07.OBJ"
            ;
            
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> Start=========================
            
            
            #ifdef _MSPEECHDSP_
            
            Subb3_Init:
            	PCH=            SDSP_Sbb3_Ch0InitV07
            	ljmp		SDSP_Sbb3_Ch0InitV07
            
            Subb3_Dec:
            	PCH=		SDSP_Sbb3_Ch0decV07
            	lcall		SDSP_Sbb3_Ch0decV07
                    AX=		0
                    if NZ jmp	@sdsp_sbb2_ch0dec_a
                    AX=		1
            @sdsp_sbb2_ch0dec_a:
            	rets
            
            #else
            
            Subb3_Init:
0300C:      	PCH=            Sbb3_Ch0InitV07
0300D:      	ljmp		Sbb3_Ch0InitV07
            
            Subb3_Dec:
0300E:      	PCH=		Sbb3_Ch0decV07
0300F:      	lcall		Sbb3_Ch0decV07
03010:              AX=		0
03011:              if NZ jmp	@sdsp_sbb2_ch0dec_a
03012:              AX=		1
            @sdsp_sbb2_ch0dec_a:
03013:      	rets
            
            #endif
            
            
            
            ; C function wrapper, may need add more preserve registers
            
            
            Sbb_Skipdata:
            ; {
03014:      	push		AX
03015:      	push		BX
03016:      	push		CX
03017:      	push		DX
03018:      	push		R2
03019:      	push		R3
            
0301A:      	push		R1			; ~~ skip high
0301B:      	push		R0			;         low
            
0301C:      	PCH=		_Sbb_SkipdataE1C72441
0301D:      	lcall		_Sbb_SkipdataE1C72441
            	
0301E:      	pop		R1
0301F:      	pop		R0
03020:      	pop		R3
03021:      	pop		R2
03022:      	pop		DX
03023:      	pop		CX
03024:      	pop		BX
03025:      	pop		AX
03026:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> End=========================
            
            ;=========================Include <DEPS\278206AB_GINIT.S.CODE.ASM> Start=========================
            ; 278206AB_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	return;					
03027:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\278206AB_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
03028:      	P1.hh=		0
03029:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
0302A:      	AR=		pm[P1++]
0302B:      	rm[I1++]=	AR
            @glinit_label_1409:
0302C:      	loop		@glinit_loop_1409
0302D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
0302E:      	AR=		AX
0302F:      	MX=		AR
03030:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
03031:      	MACOP=		3
03032:      	MR=		MX * AR
            #endif
            
03033:      	AR=		MR0
03034:      	AX=		AR
03035:      	AR=		MR1
03036:      	DX=		AR
03037:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
03038:      	AR=		AX
03039:      	MX=		AR
0303A:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
0303B:      	MACOP=		0
0303C:      	MR=		MX * AR
            #endif
            
0303D:      	AR=		MR0
0303E:      	AX=		AR
0303F:      	AR=		MR1
03040:      	DX=		AR
03041:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
03042:      	AR=		rm[BP_SAVE]
03043:      	push		AR
03044:      	AR=		BP
03045:      	rm[BP_SAVE]=	AR
03046:      	AR=		AR - 3
03047:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
03048:      	AR=		CX
03049:      	MX=		AR
0304A:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0304B:      	MACOP=		3		; unsigned
0304C:      	MR=		MX * AR
            #endif
            
0304D:      	I1=		rm[BP_SAVE]
0304E:      	AR=		2
0304F:      	I1=		I1 - AR
03050:      	rm[I1++]=	MR0
03051:      	rm[I1++]=	MR1
03052:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
03053:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
03054:      	MACOP=		1		; mx:unsigned / my:signed
03055:      	MR=		MX * AR
            #endif
            
03056:      	AR=		rm[I1]
03057:      	AR=		AR + MR0
03058:      	rm[I1++]=	AR
03059:      	AR=		rm[I1]
0305A:      	AR=		AR + MR1 + C
0305B:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
0305C:      	AR=		BX
0305D:      	MX=		AR
0305E:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
0305F:      	MACOP=		2		; mx:signed / my:unsigned
03060:      	MR=		MX * AR
            #endif
            
03061:      	AR=		rm[I1]
03062:      	AR=		AR + MR0
03063:      	rm[I1++]=	AR
03064:      	AR=		rm[I1]
03065:      	AR=		AR + MR1 + C
03066:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
03067:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
03068:      	MACOP=		0		; mx:signed / my:signed
03069:      	MR=		MX * AR
            #endif
            
0306A:      	AR=		rm[I1]
0306B:      	AR=		AR + MR0
0306C:      	rm[I1]=		AR
            
0306D:      	I1=		rm[BP_SAVE]
0306E:      	CX=		rm[I1--]
0306F:      	DX=		rm[I1--]
03070:      	AX=		rm[I1]
            
03071:      	AR=		3
03072:      	BP=		BP + AR
03073:      	pop		AR
03074:      	rm[BP_SAVE]=	AR
            
03075:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
03076:      	AR=		rm[BP_SAVE]
03077:      	push		AR
03078:      	AR=		BP
03079:      	rm[BP_SAVE]=	AR
0307A:      	AR=		AR - 3
0307B:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
0307C:      	AR=		CX
0307D:      	MX=		AR
0307E:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0307F:      	MACOP=		3		; unsigned
03080:      	MR=		MX * AR
            #endif
            
03081:      	I1=		rm[BP_SAVE]
03082:      	AR=		2
03083:      	I1=		I1 - AR
03084:      	rm[I1++]=	MR0
03085:      	rm[I1++]=	MR1
03086:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
03087:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
03088:      	MR=		MX * AR
            #endif
            
03089:      	AR=		rm[I1]
0308A:      	AR=		AR + MR0
0308B:      	rm[I1++]=	AR
0308C:      	AR=		rm[I1]
0308D:      	AR=		AR + MR1 + C
0308E:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
0308F:      	AR=		BX
03090:      	MX=		AR
03091:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
03092:      	MR=		MX * AR
            #endif
            
03093:      	AR=		rm[I1]
03094:      	AR=		AR + MR0
03095:      	rm[I1++]=	AR
03096:      	AR=		rm[I1]
03097:      	AR=		AR + MR1 + C
03098:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
03099:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0309A:      	MR=		MX * AR
            #endif
            
0309B:      	AR=		rm[I1]
0309C:      	AR=		AR + MR0
0309D:      	rm[I1]=		AR
            
0309E:      	I1=		rm[BP_SAVE]
0309F:      	CX=		rm[I1--]
030A0:      	DX=		rm[I1--]
030A1:      	AX=		rm[I1]
            
030A2:      	AR=		3
030A3:      	BP=		BP + AR
030A4:      	pop		AR
030A5:      	rm[BP_SAVE]=	AR
            
030A6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
030A7:      		DX=		0
            	; unsigned char count = 16;
030A8:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
030A9:      			slz		AX, 1
            		; reste <<= 1;
030AA:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
030AB:      			AR=		DX
030AC:      			AR-=		CX
030AD:      			AR=		0
030AE:      			AR=		AR - 0 + C - 1
030AF:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
030B0:      				AR=		CX
030B1:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
030B2:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
030B3:      		R0--
030B4:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
030B5:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
030B6:      		R1=		0
030B7:      		AR=		0
030B8:      		test		AX.b15
030B9:      		if ZR jmp	@divsword_label_1833
030BA:      			AX=		AR - AX
030BB:      			set		R1.b0
            		@divsword_label_1833:
030BC:      		test		CX.b15
030BD:      		if ZR jmp	@divsword_label_1834
030BE:      			CX=		AR - CX
030BF:      			set		R1.b1
            		@divsword_label_1834:
030C0:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
030C1:      		AR=		R1
030C2:      		slz		AR, 1
030C3:      		AR^=		R1
030C4:      		test		AR.b1
030C5:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
030C6:      			AR=		0
030C7:      			AX=		AR - AX
030C8:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
030C9:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
030CA:      		R0=		0	; L
030CB:      		R1=		0	; H
            	; unsigned char count = 32;
030CC:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
030CD:      			slz		AX, 1
030CE:      			slc		DX, 1
            		; reste <<= 1;
030CF:      			slc		R0, 1
030D0:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
030D1:      			AR=		R0
030D2:      			AR-=		CX
030D3:      			AR=		R1
030D4:      			AR=		AR - BX + C - 1
030D5:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
030D6:      				AR=		CX
030D7:      				R0=		R0 - AR
030D8:      				AR=		BX
030D9:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
030DA:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
030DB:      		R2--
030DC:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
030DD:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
030DE:      		R3=		0
030DF:      		AR=		0
030E0:      		test		DX.b15
030E1:      		if ZR jmp	@divslong_label_1759
030E2:      			AX=		AR - AX
030E3:      			DX=		AR - DX + C - 1
030E4:      			set		R3.b0
            		@divslong_label_1759:
030E5:      		test		BX.b15
030E6:      		if ZR jmp	@divslong_label_1800
030E7:      			CX=		AR - CX
030E8:      			BX=		AR - BX + C - 1
030E9:      			set		R3.b1
            		@divslong_label_1800:
030EA:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
030EB:      		AR=		R3
030EC:      		slz		AR, 1
030ED:      		AR^=		R3
030EE:      		test		AR.b1
030EF:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
030F0:      			AR=		0
030F1:      			AX=		AR - AX
030F2:      			DX=		AR - DX + C - 1
030F3:      			R0=		AR - R0
030F4:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
030F5:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
030F6:      	call		sfx_DIV_AX_CX
030F7:      	AR=		DX
030F8:      	AX=		AR
030F9:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
030FA:      	call		sfx_IDIV_AX_CX
030FB:      	AR=		DX
030FC:      	AX=		AR
030FD:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
030FE:      	call		sfx_DIVLONG
030FF:      	AR=		R0
03100:      	AX=		AR
03101:      	AR=		R1
03102:      	DX=		AR
03103:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
03104:      	call		sfx_IDIVLONG
03105:      	AR=		R0
03106:      	AX=		AR
03107:      	AR=		R1
03108:      	DX=		AR
03109:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
0310A:      	AR=		AX
0310B:      	P1=		P1 + AR
0310C:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
0310D:      	AR=		AX
0310E:      	I1=		I1 + AR
0310F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
03110:      	AR=		CX
03111:      	AX=		AX + AR
03112:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
03113:      	AR=		AX
03114:      	P1=		P1 - AR
03115:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
03116:      	AR=		AX
03117:      	I1=		I1 - AR
03118:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
03119:      	AR=		CX
0311A:      	AX=		AX + AR
0311B:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
0311C:      	pm[P1++]=	AX
0311D:      	pm[P1--]=	DX
0311E:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
0311F:      	pm[P1++]=	CX
03120:      	pm[P1--]=	BX
03121:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
03122:      	BX=		0
03123:      	CX.h=		0
03124:      	test		CX.b7
03125:      	if ZR jmp	@c2lcx_label_1800
03126:      	CX.h=		0xFF
03127:      	BX=		-1
            @c2lcx_label_1800:
03128:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
03129:      	DX=		0
0312A:      	AX.h=		0
0312B:      	test		AX.b7
0312C:      	if ZR jmp	@c2lax_label_1800
0312D:      	AX.h=		0xFF
0312E:      	DX=		-1
            @c2lax_label_1800:
0312F:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
03130:      	push		AX
03131:      	push		CX
03132:      	pop		AX
03133:      	pop		CX
03134:      	push		DX
03135:      	push		BX
03136:      	pop		DX
03137:      	pop		BX
03138:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
03139:      	AR=		DX
0313A:      	DX=		0
0313B:      	AR=		AR | AX
0313C:      	AX=		1
0313D:      	if ZR jmp	@longnotl_label_1120
0313E:      	AX=		0
            @longnotl_label_1120:
0313F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
03140:      	DX=		0
03141:      	BX=		0
            sfx_CMPLONG_JNE:
03142:      	AR=		CX
03143:      	AX=		AX - AR
03144:      	AR=		BX
03145:      	AR=		DX - AR + C - 1
03146:      	AR=		AR | AX
03147:      	if EQ jmp	@sfx_cl_jne_f
03148:      	set		Z		; true
03149:      	rets
            @sfx_cl_jne_f:
0314A:      	clr		Z		; false
0314B:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
0314C:      	DX=		0
0314D:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
0314E:      	AR=		AX
0314F:      	CX=		CX - AR
03150:      	AR=		DX
03151:      	AR=		BX - AR + C - 1
03152:      	AR=		AR | CX
03153:      	if EQ jmp	@sfx_clbcda_jne_f
03154:      	set		Z		; true
03155:      	rets
            @sfx_clbcda_jne_f:
03156:      	clr		Z		; false
03157:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
03158:      	AR=		CX
03159:      	SF=		AX - AR
0315A:      	if EQ jmp	@sfx_ac_jne_f
0315B:      	set		Z
0315C:      	rets
            @sfx_ac_jne_f:
0315D:      	clr		Z
0315E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
0315F:      	AR=		AX
03160:      	SF=		CX - AR
03161:      	if EQ jmp	@sfx_ca_jne_f
03162:      	set		Z
03163:      	rets
            @sfx_ca_jne_f:
03164:      	clr		Z
03165:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
03166:      	DX=		0
03167:      	BX=		0
            sfx_CMPLONG_JE:
03168:      	AR=		CX
03169:      	AX=		AX - AR
0316A:      	AR=		BX
0316B:      	AR=		DX - AR + C - 1
0316C:      	AR=		AR | AX
0316D:      	if NE jmp	@sfx_cl_jz_f
0316E:      	set		Z		; true
0316F:      	rets
            @sfx_cl_jz_f:
03170:      	clr		Z		; false
03171:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
03172:      	DX=		0
03173:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
03174:      	AR=		AX
03175:      	CX=		CX - AR
03176:      	AR=		DX
03177:      	AR=		BX - AR + C - 1
03178:      	AR=		AR | CX
03179:      	if NE jmp	@sfx_clbcda_jz_f
0317A:      	set		Z		; true
0317B:      	rets
            @sfx_clbcda_jz_f:
0317C:      	clr		Z		; false
0317D:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
0317E:      	DX=		0
0317F:      	BX=		0
            sfx_CMPLONG_JG:
03180:      	AR=		CX
03181:      	AX=		AX - AR
03182:      	AR=		BX
03183:      	AR=		DX - AR + C - 1
03184:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
03185:      	AR=		AR | AX
03186:      	if ZR jmp	@sfx_cl_jg_f
            
03187:      	set		Z		; true
03188:      	rets
            @sfx_cl_jg_f:
03189:      	clr		Z		; false
0318A:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
0318B:      	AR=		CX
0318C:      	AX=		AX - AR
0318D:      	AR=		BX
0318E:      	DX=		DX - AR + C - 1
0318F:      	AR=		0
03190:      	AR=		AR - 0 + C - 1
03191:      	if AN jmp	@sfx_cl_jg_f
            
03192:      	AR=		AR | DX		; exclude EQU condition
03193:      	AR=		AR | AX
03194:      	if ZR jmp	@sfx_cl_jg_f
            
03195:      	set		Z		; true
03196:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
03197:      	DX=		0
03198:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
03199:      	AR=		AX
0319A:      	CX=		CX - AR
0319B:      	AR=		DX
0319C:      	AR=		BX - AR + C - 1
0319D:      	if AN jmp	@sfx_clbcda_jg_f
            
0319E:      	AR=		AR | CX		; exclude EQU condition
0319F:      	if ZR jmp	@sfx_clbcda_jg_f
            
031A0:      	set		Z		; true
031A1:      	rets
            @sfx_clbcda_jg_f:
031A2:      	clr		Z		; false
031A3:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
031A4:      	AR=		AX
031A5:      	CX=		CX - AR
031A6:      	AR=		DX
031A7:      	BX=		BX - AR + C - 1
031A8:      	AR=		0
031A9:      	AR=		AR - 0 + C - 1
031AA:      	if AN jmp	@sfx_clbcda_jg_f
            
031AB:      	AR=		AR | BX		; exclude EQU condition
031AC:      	AR=		AR | CX
031AD:      	if ZR jmp	@sfx_clbcda_jg_f
            
031AE:      	set		Z		; true
031AF:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
031B0:      	AR=		CX
031B1:      	SF=		AX - AR
031B2:      	if LE jmp	@sfx_cmp_ac_jg_f
031B3:      	set		Z
031B4:      	rets
            @sfx_cmp_ac_jg_f:
031B5:      	clr		Z
031B6:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
031B7:      	AR=		AX
031B8:      	SF=		CX - AR
031B9:      	if LE jmp	@sfx_cmp_ca_jg_f
031BA:      	set		Z
031BB:      	rets
            @sfx_cmp_ca_jg_f:
031BC:      	clr		Z
031BD:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
031BE:      	DX=		0
031BF:      	BX=		0
            sfx_CMPLONG_JGE:
031C0:      	AR=		CX
031C1:      	AX=		AX - AR
031C2:      	AR=		BX
031C3:      	DX=		DX - AR + C - 1
031C4:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
031C5:      	set		Z		; true
031C6:      	rets
            @sfx_cl_jge_f:
031C7:      	clr		Z		; false
031C8:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
031C9:      	AR=		CX
031CA:      	AX=		AX - AR
031CB:      	AR=		BX
031CC:      	DX=		DX - AR + C - 1
031CD:      	AR=		0
031CE:      	AR=		AR - 0 + C - 1
031CF:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
031D0:      	set		Z		; true
031D1:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
031D2:      	DX=		0
031D3:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
031D4:      	AR=		AX
031D5:      	CX=		CX - AR
031D6:      	AR=		DX
031D7:      	BX=		BX - AR + C - 1
031D8:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
031D9:      	set		Z		; true
031DA:      	rets
            @sfx_clbcda_jge_f:
031DB:      	clr		Z		; false
031DC:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
031DD:      	AR=		AX
031DE:      	CX=		CX - AR
031DF:      	AR=		DX
031E0:      	BX=		BX - AR + C - 1
031E1:      	AR=		0
031E2:      	AR=		AR - 0 + C - 1
031E3:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
031E4:      	set		Z		; true
031E5:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
031E6:      	AR=		CX
031E7:      	SF=		AX - AR
031E8:      	if AN jmp	@sfx_cmp_ac_jge_f
031E9:      	set		Z
031EA:      	rets
            @sfx_cmp_ac_jge_f:
031EB:      	clr		Z
031EC:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
031ED:      	AR=		AX
031EE:      	SF=		CX - AR
031EF:      	if AN jmp	@sfx_cmp_ca_jge_f
031F0:      	set		Z
031F1:      	rets
            @sfx_cmp_ca_jge_f:
031F2:      	clr		Z
031F3:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
031F4:      	DX=		0
031F5:      	BX=		0
            sfx_CMPLONG_JL:
031F6:      	AR=		CX
031F7:      	AX=		AX - AR
031F8:      	AR=		BX
031F9:      	AR=		DX - AR + C - 1
031FA:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
031FB:      	clr		Z		; false
031FC:      	rets
            
            @sfx_cl_jl_chk:
031FD:      	AR=		AR | AX		; exclude EQU condition
031FE:      	if ZR jmp	@sfx_cl_jl_f
031FF:      	set		Z
03200:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
03201:      	AR=		CX
03202:      	AX=		AX - AR
03203:      	AR=		BX
03204:      	DX=		DX - AR + C - 1
03205:      	AR=		0
03206:      	AR=		AR - 0 + C - 1
03207:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
03208:      	clr		Z		; false
03209:      	rets
            
            @sfx_cl_jb_chk:
0320A:      	AR=		AR | DX
0320B:      	AR=		AR | AX		; exclude EQU condition
0320C:      	if ZR jmp	@sfx_cl_jb_f
0320D:      	set		Z
0320E:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
0320F:      	DX=		0
03210:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
03211:      	AR=		AX
03212:      	CX=		CX - AR
03213:      	AR=		DX
03214:      	AR=		BX - AR + C - 1
03215:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
03216:      	clr		Z		; false
03217:      	rets
            
            @sfx_clbcda_jl_chk:
03218:      	AR=		AR | CX		; exclude EQU condition
03219:      	if ZR jmp	@sfx_clbcda_jl_f
0321A:      	set		Z		; true
0321B:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
0321C:      	AR=		AX
0321D:      	CX=		CX - AR
0321E:      	AR=		DX
0321F:      	BX=		BX - AR + C - 1
03220:      	AR=		0
03221:      	AR=		AR - 0 + C - 1
03222:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
03223:      	clr		Z		; false
03224:      	rets
            
            @sfx_clbcda_jb_chk:
03225:      	AR=		AR | CX
03226:      	AR=		AR | BX
03227:      	if ZR jmp	@sfx_clbcda_jb_f
03228:      	set		Z		; true
03229:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
0322A:      	AR=		CX
0322B:      	SF=		AX - AR
0322C:      	if GE jmp	@sfx_cmp_ac_jl_f
0322D:      	set		Z
0322E:      	rets
            @sfx_cmp_ac_jl_f:
0322F:      	clr		Z
03230:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
03231:      	AR=		AX
03232:      	SF=		CX - AR
03233:      	if GE jmp	@sfx_cmp_ca_jl_f
03234:      	set		Z
03235:      	rets
            @sfx_cmp_ca_jl_f:
03236:      	clr		Z
03237:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
03238:      	DX=		0
03239:      	BX=		0
            sfx_CMPLONG_JLE:
0323A:      	AR=		CX
0323B:      	AX=		AX - AR
0323C:      	AR=		BX
0323D:      	AR=		DX - AR + C - 1
0323E:      	if AN jmp	@sfx_cl_jle_t
            
0323F:      	AR=		AR | AX		; include EQU condition
03240:      	if ZR jmp	@sfx_cl_jle_t
            
03241:      	clr		Z		; false
03242:      	rets
            @sfx_cl_jle_t:
03243:      	set		Z		; true
03244:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
03245:      	AR=		CX
03246:      	AX=		AX - AR
03247:      	AR=		BX
03248:      	DX=		DX - AR + C - 1
03249:      	AR=		0
0324A:      	AR=		AR - 0 + C - 1
0324B:      	if AN jmp	@sfx_cl_jle_t
            
0324C:      	AR=		AR | DX
0324D:      	AR=		AR | AX
0324E:      	if ZR jmp	@sfx_cl_jle_t
            
0324F:      	clr		Z		; false
03250:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
03251:      	DX=		0
03252:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
03253:      	AR=		AX
03254:      	CX=		CX - AR
03255:      	AR=		DX
03256:      	AR=		BX - AR + C - 1
03257:      	if AN jmp	@sfx_clbcda_jle_t
            
03258:      	AR=		AR | CX		; include EQU condition
03259:      	if ZR jmp	@sfx_clbcda_jle_t
            
0325A:      	clr		Z		; false
0325B:      	rets
            @sfx_clbcda_jle_t:
0325C:      	set		Z		; true
0325D:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
0325E:      	AR=		AX
0325F:      	CX=		CX - AR
03260:      	AR=		DX
03261:      	BX=		BX - AR + C - 1
03262:      	AR=		0
03263:      	AR=		AR - 0 + C - 1
03264:      	if AN jmp	@sfx_clbcda_jle_t
            
03265:      	AR=		AR | BX
03266:      	AR=		AR | CX
03267:      	if ZR jmp	@sfx_clbcda_jle_t
            
03268:      	clr		Z		; false
03269:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
0326A:      	AR=		CX
0326B:      	SF=		AX - AR
0326C:      	if LE jmp	@sfx_cmp_ac_jl_t
0326D:      	clr		Z
0326E:      	rets
            @sfx_cmp_ac_jl_t:
0326F:      	set		Z
03270:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
03271:      	AR=		AX
03272:      	SF=		CX - AR
03273:      	if LE jmp	@sfx_cmp_ca_jl_t
03274:      	clr		Z
03275:      	rets
            @sfx_cmp_ca_jl_t:
03276:      	set		Z
03277:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
03278:      	DW 0xFFFE
            @sfx_ortable_1:
03279:      	DW 0xFFFC
            @sfx_ortable_2:
0327A:      	DW 0xFFF8
            @sfx_ortable_3:
0327B:      	DW 0xFFF0
            @sfx_ortable_4:
0327C:      	DW 0xFFE0
            @sfx_ortable_5:
0327D:      	DW 0xFFC0
            @sfx_ortable_6:
0327E:      	DW 0xFF80
            @sfx_ortable_7:
0327F:      	DW 0xFF00
            @sfx_ortable_8:
03280:      	DW 0xFE00
            @sfx_ortable_9:
03281:      	DW 0xFC00
            @sfx_ortable_10:
03282:      	DW 0xF800
            @sfx_ortable_11:
03283:      	DW 0xF000
            @sfx_ortable_12:
03284:      	DW 0xE000
            @sfx_ortable_13:
03285:      	DW 0xC000
            @sfx_ortable_14:
03286:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
03287:      	AR=		pm[P1]
03288:      	DX=		DX | AR
03289:      	rets
            
            @sfx_orhigh_dx:
0328A:      	DX=		-1
            @sfx_orlow:
0328B:      	AR=		pm[P1]
0328C:      	AX=		AX | AR
            @sfx_sextw_rets:
0328D:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
0328E:      	P1=		#@sfx_ortable_0
03291:      	test		AX.b0
03292:      	if ZR jmp	@sfx_sextw_rets
03293:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
03294:      	P1=		#@sfx_ortable_1
03297:      	test		AX.b1
03298:      	if ZR jmp	@sfx_sextw_rets
03299:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
0329A:      	P1=		#@sfx_ortable_2
0329D:      	test		AX.b2
0329E:      	if ZR jmp	@sfx_sextw_rets
0329F:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
032A0:      	P1=		#@sfx_ortable_3
032A3:      	test		AX.b3
032A4:      	if ZR jmp	@sfx_sextw_rets
032A5:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
032A6:      	P1=		#@sfx_ortable_4
032A9:      	test		AX.b4
032AA:      	if ZR jmp	@sfx_sextw_rets
032AB:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
032AC:      	P1=		#@sfx_ortable_5
032AF:      	test		AX.b5
032B0:      	if ZR jmp	@sfx_sextw_rets
032B1:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
032B2:      	P1=		#@sfx_ortable_6
032B5:      	test		AX.b6
032B6:      	if ZR jmp	@sfx_sextw_rets
032B7:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
032B8:      	P1=		#@sfx_ortable_7
032BB:      	test		AX.b7
032BC:      	if ZR jmp	@sfx_sextw_rets
032BD:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
032BE:      	P1=		#@sfx_ortable_8
032C1:      	test		AX.b8
032C2:      	if ZR jmp	@sfx_sextw_rets
032C3:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
032C4:      	P1=		#@sfx_ortable_9
032C7:      	test		AX.b9
032C8:      	if ZR jmp	@sfx_sextw_rets
032C9:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
032CA:      	P1=		#@sfx_ortable_10
032CD:      	test		AX.b10
032CE:      	if ZR jmp	@sfx_sextw_rets
032CF:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
032D0:      	P1=		#@sfx_ortable_11
032D3:      	test		AX.b11
032D4:      	if ZR jmp	@sfx_sextw_rets
032D5:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
032D6:      	P1=		#@sfx_ortable_12
032D9:      	test		AX.b12
032DA:      	if ZR jmp	@sfx_sextw_rets
032DB:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
032DC:      	P1=		#@sfx_ortable_13
032DF:      	test		AX.b13
032E0:      	if ZR jmp	@sfx_sextw_rets
032E1:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
032E2:      	P1=		#@sfx_ortable_14
032E5:      	test		AX.b14
032E6:      	if ZR jmp	@sfx_sextw_rets
032E7:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
032E8:      	P1=		#@sfx_ortable_0
032EB:      	test		AX.b0
032EC:      	if ZR jmp	@sfx_sextw_rets
032ED:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
032EE:      	P1=		#@sfx_ortable_1
032F1:      	test		AX.b1
032F2:      	if ZR jmp	@sfx_sextw_rets
032F3:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
032F4:      	P1=		#@sfx_ortable_2
032F7:      	test		AX.b2
032F8:      	if ZR jmp	@sfx_sextw_rets
032F9:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
032FA:      	P1=		#@sfx_ortable_3
032FD:      	test		AX.b3
032FE:      	if ZR jmp	@sfx_sextw_rets
032FF:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
03300:      	P1=		#@sfx_ortable_4
03303:      	test		AX.b4
03304:      	if ZR jmp	@sfx_sextw_rets
03305:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
03306:      	P1=		#@sfx_ortable_5
03309:      	test		AX.b5
0330A:      	if ZR jmp	@sfx_sextw_rets
0330B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
0330C:      	P1=		#@sfx_ortable_6
0330F:      	test		AX.b6
03310:      	if ZR jmp	@sfx_sextw_rets
03311:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
03312:      	P1=		#@sfx_ortable_7
03315:      	test		AX.b7
03316:      	if ZR jmp	@sfx_sextw_rets
03317:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
03318:      	P1=		#@sfx_ortable_8
0331B:      	test		AX.b8
0331C:      	if ZR jmp	@sfx_sextw_rets
0331D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
0331E:      	P1=		#@sfx_ortable_9
03321:      	test		AX.b9
03322:      	if ZR jmp	@sfx_sextw_rets
03323:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
03324:      	P1=		#@sfx_ortable_10
03327:      	test		AX.b10
03328:      	if ZR jmp	@sfx_sextw_rets
03329:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
0332A:      	P1=		#@sfx_ortable_11
0332D:      	test		AX.b11
0332E:      	if ZR jmp	@sfx_sextw_rets
0332F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
03330:      	P1=		#@sfx_ortable_12
03333:      	test		AX.b12
03334:      	if ZR jmp	@sfx_sextw_rets
03335:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
03336:      	P1=		#@sfx_ortable_13
03339:      	test		AX.b13
0333A:      	if ZR jmp	@sfx_sextw_rets
0333B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
0333C:      	P1=		#@sfx_ortable_14
0333F:      	test		AX.b14
03340:      	if ZR jmp	@sfx_sextw_rets
03341:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
03342:      	test		AX.b15
03343:      	if ZR jmp	@sfx_sextw_rets
03344:      	DX=		-1
03345:      	rets
            
            sfx_SignExtL16:
03346:      	P1=		#@sfx_ortable_0
03349:      	test		DX.b0
0334A:      	if ZR jmp	@sfx_sextw_rets
0334B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
0334C:      	P1=		#@sfx_ortable_1
0334F:      	test		DX.b1
03350:      	if ZR jmp	@sfx_sextw_rets
03351:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
03352:      	P1=		#@sfx_ortable_2
03355:      	test		DX.b2
03356:      	if ZR jmp	@sfx_sextw_rets
03357:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
03358:      	P1=		#@sfx_ortable_3
0335B:      	test		DX.b3
0335C:      	if ZR jmp	@sfx_sextw_rets
0335D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
0335E:      	P1=		#@sfx_ortable_4
03361:      	test		DX.b4
03362:      	if ZR jmp	@sfx_sextw_rets
03363:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
03364:      	P1=		#@sfx_ortable_5
03367:      	test		DX.b5
03368:      	if ZR jmp	@sfx_sextw_rets
03369:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
0336A:      	P1=		#@sfx_ortable_6
0336D:      	test		DX.b6
0336E:      	if ZR jmp	@sfx_sextw_rets
0336F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
03370:      	P1=		#@sfx_ortable_7
03373:      	test		DX.b7
03374:      	if ZR jmp	@sfx_sextw_rets
03375:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
03376:      	P1=		#@sfx_ortable_8
03379:      	test		DX.b8
0337A:      	if ZR jmp	@sfx_sextw_rets
0337B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
0337C:      	P1=		#@sfx_ortable_9
0337F:      	test		DX.b9
03380:      	if ZR jmp	@sfx_sextw_rets
03381:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
03382:      	P1=		#@sfx_ortable_10
03385:      	test		DX.b10
03386:      	if ZR jmp	@sfx_sextw_rets
03387:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
03388:      	P1=		#@sfx_ortable_11
0338B:      	test		DX.b11
0338C:      	if ZR jmp	@sfx_sextw_rets
0338D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
0338E:      	P1=		#@sfx_ortable_12
03391:      	test		DX.b12
03392:      	if ZR jmp	@sfx_sextw_rets
03393:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
03394:      	P1=		#@sfx_ortable_13
03397:      	test		DX.b13
03398:      	if ZR jmp	@sfx_sextw_rets
03399:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
0339A:      	P1=		#@sfx_ortable_14
0339D:      	test		DX.b14
0339E:      	if ZR jmp	@sfx_sextw_rets
0339F:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
033A0:      	push		I1
033A1:      	AR=		AX
033A2:      	I1=		AR
033A3:      	AR=		rm[I1]
033A4:      	pop		I1
033A5:      	rm[I1++]=	AR
033A6:      	AX++
033A7:      	loop		@sfx_repmov_ss_loop_1804
033A8:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
033A9:      	AR=		AX
033AA:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
033AB:      	rm[I1++]=	pm[P1++]
033AC:      	loop		@sfx_repmov_sr_loop_1804
033AD:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
033AE:      	AR=		AX
033AF:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
033B0:      	AR=		rm[I1++]
033B1:      	pm[P1++]=	AR
033B2:      	loop		@sfx_repmov_rs_loop_1804
033B3:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
033B4:      	push		P1
033B5:      	AR=		AX
033B6:      	P1=		AR
033B7:      	AR=		pm[P1]
033B8:      	pop		P1
033B9:      	pm[P1++]=	AR
033BA:      	AX++
033BB:      	loop		@sfx_repmov_rr_loop_1804
033BC:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
033BD:      	PCH=	SYS_PROG_ENTRY
033BE:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
033BF:      	DW #EMPTY_INTENTRY
033C0:      	DW #EMPTY_INTENTRY
033C1:      	DW #EMPTY_INTENTRY
033C2:      	DW #EMPTY_INTENTRY
033C3:      	DW #EMPTY_INTENTRY
033C4:      	DW #PWM_ENTRY
            
            // .code ends
            ;;FDSP-IDE V2.64
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
