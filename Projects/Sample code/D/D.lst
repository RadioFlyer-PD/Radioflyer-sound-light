            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\D_CF87A0F9.S.CODE.ASM> Start=========================
            ; D.C Code Start!!;
            VarRM[0:4095]={
             _PLAY59F2A4ED 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlayAdpECABF1D0();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //rjmp void _KeyPlaySubb36031D62D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_A0432E234_0:;					
            _A0432E234_0:
            ; //	
            ; //_A0432E234_1:;					
            _A0432E234_1:
            ; //_A0432E234_2:;					
            _A0432E234_2:
            ; //	_InitialDA4A7CC4();			
0011D:      	pch	= _InitialDA4A7CC4
0011E:      	lcall	_InitialDA4A7CC4
            ; //_A0432E234_3:;					
            _A0432E234_3:
            ; //_A0432E234_4:;					
            _A0432E234_4:
            ; //	_InitKey3C587B6D();			
0011F:      	pch	= _InitKey3C587B6D
00120:      	lcall	_InitKey3C587B6D
            ; //_A0432E234_5:;					
            _A0432E234_5:
            ; //_A0432E234_6:;					
            _A0432E234_6:
            ; //	ADPCM_CHX_Init();			
00121:      	pch	= ADPCM_CHX_Init
00122:      	lcall	ADPCM_CHX_Init
            ; //_A0432E234_7:;					
            _A0432E234_7:
            ; //_A0432E234_8:;					
            _A0432E234_8:
            ; //	_Sub3Initial96BE24F3();			
00123:      	pch	= _Sub3Initial96BE24F3
00124:      	lcall	_Sub3Initial96BE24F3
            ; //_A0432E234_9:;					
            _A0432E234_9:
            ; //	asm set io[0x06].b0;			
00125:      	set io[0x06].b0//
            ; //_A0432E234_10:;					
            _A0432E234_10:
            ; //	sAX	= 0x0000;			
00126:      	AX	= 0x00
            ; //	asm I1 = CopyToBank+0;			
00127:      	I1 = CopyToBank+0//
            ; //	*(__int16*)sSI	= sAX			
00128:      	rm[I1]	= AX
            ; //_A0432E234_11:;					
            _A0432E234_11:
            ; //	sAX	= 0x0000;			
00129:      	AX	= 0x00
            ; //	asm I1 = _PLAY59F2A4ED+0;		
0012A:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
0012B:      	rm[I1]	= AX
            ; //_A0432E234_12:;					
            _A0432E234_12:
            ; //	asm	set io[INTENA].b0		
0012C:      	set io[INTENA].b0
            ; //_A0432E234_13:;					
            _A0432E234_13:
            ; //	asm	eni				
0012D:      	eni
            ; //LF66E16C1_4:;					
            LF66E16C1_4:
            ; //_A0432E234_14:;					
            _A0432E234_14:
            ; //_A0432E234_15:;					
            _A0432E234_15:
            ; //	asm	io[ClrWDT] = AR			
0012E:      	io[ClrWDT] = AR
            ; //	
            ; //_A0432E234_16:;					
            _A0432E234_16:
            ; //_A0432E234_17:;					
            _A0432E234_17:
            ; //	_PollingKey3B90E3B1();			
0012F:      	pch	= _PollingKey3B90E3B1
00130:      	lcall	_PollingKey3B90E3B1
            ; //_A0432E234_18:;					
            _A0432E234_18:
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00131:      	I1 = _PLAY59F2A4ED+0//
            ; //	sAX	= *(__int16*)sSI;		
00132:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00133:      	AR	= AX
            ; //	if(__jnz__)	goto LF66E16C1_6;	
00134:      	if NZ	jmp LF66E16C1_6
            ; //	goto	LF66E16C1_5;			
00135:      	jmp	LF66E16C1_5
            ; //LF66E16C1_6:;					
            LF66E16C1_6:
            ; //	
            ; //_A0432E234_19:;					
            _A0432E234_19:
            ; //_A0432E234_20:;					
            _A0432E234_20:
            ; //	Subb3_Dec();				
00136:      	pch	= Subb3_Dec
00137:      	lcall	Subb3_Dec
            ; //	sfx_CHECKZERO();			
00138:      	AR	= AX
            ; //	if(__jnz__)	goto LF66E16C1_8;	
00139:      	if NZ	jmp LF66E16C1_8
            ; //	goto	LF66E16C1_7;			
0013A:      	jmp	LF66E16C1_7
            ; //LF66E16C1_8:;					
            LF66E16C1_8:
            ; //	
            ; //_A0432E234_21:;					
            _A0432E234_21:
            ; //	sAX	= 0x0000;			
0013B:      	AX	= 0x00
            ; //	asm I1 = _PLAY59F2A4ED+0;		
0013C:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
0013D:      	rm[I1]	= AX
            ; //_A0432E234_22:;					
            _A0432E234_22:
            ; //_A0432E234_23:;					
            _A0432E234_23:
            ; //	_Sub3ZeroFillABFF23AA();		
0013E:      	pch	= _Sub3ZeroFillABFF23AA
0013F:      	lcall	_Sub3ZeroFillABFF23AA
            ; //LF66E16C1_7:;					
            LF66E16C1_7:
            ; //_A0432E234_24:;					
            _A0432E234_24:
            ; //	goto LF66E16C1_9;			
00140:      	jmp	LF66E16C1_9
            ; //LF66E16C1_5:;					
            LF66E16C1_5:
            ; //	
            ; //_A0432E234_25:;					
            _A0432E234_25:
            ; //_A0432E234_26:;					
            _A0432E234_26:
            ; //	_Sub3ZeroFillABFF23AA();		
00141:      	pch	= _Sub3ZeroFillABFF23AA
00142:      	lcall	_Sub3ZeroFillABFF23AA
            ; //LF66E16C1_9:;					
            LF66E16C1_9:
            ; //_A0432E234_27:;					
            _A0432E234_27:
            ; //_A0432E234_28:;					
            _A0432E234_28:
            ; //	goto LF66E16C1_4;			
00143:      	jmp	LF66E16C1_4
            ; //LF66E16C1_3:;					
            LF66E16C1_3:
            ; //LF66E16C1_2:;					
            LF66E16C1_2:
            ; //_A0432E234_29:;					
            _A0432E234_29:
            ; //	return;					
00144:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A0432E234_30:;					
            _A0432E234_30:
            ; //}
            ; //
            ; //rjmp void _KeyPlayAdpECABF1D0()			
            _KeyPlayAdpECABF1D0:
            ; //{
            ; //_A0432E234_31:;					
            _A0432E234_31:
            ; //	
            ; //_A0432E234_32:;					
            _A0432E234_32:
            ; //	sAX	= 0x0000;			
00145:      	AX	= 0x00
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00146:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
00147:      	rm[I1]	= AX
            ; //_A0432E234_33:;					
            _A0432E234_33:
            ; //_A0432E234_34:;					
            _A0432E234_34:
            ; //	asm I1 = _iADPCCACC469+0;		
00148:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00149:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0014A:      	push	AX
            ; //	_playADPCMBACD5AFD(STACK[sSP + 0]);	
0014B:      	pch	= _playADPCMBACD5AFD
0014C:      	lcall	_playADPCMBACD5AFD
            ; //	RESTORESP(1);				
0014D:      	pop	AR
            ; //LF66E16C1_10:;					
            LF66E16C1_10:
            ; //_A0432E234_35:;					
            _A0432E234_35:
            ; //	return;					
0014E:      	rets
            ; //_KeyPlayAdpECABF1D0_end:;			
            _KeyPlayAdpECABF1D0_end:
            ; //_A0432E234_36:;					
            _A0432E234_36:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_A0432E234_37:;					
            _A0432E234_37:
            ; //	
            ; //_A0432E234_38:;					
            _A0432E234_38:
            ; //	asm I1 = _iADPCCACC469+0;		
0014F:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00150:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
00151:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
00152:      	CX	= rm[I1]
            ; //	sCX++;					
00153:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
00154:      	rm[I1]	= CX
            ; //_A0432E234_39:;					
            _A0432E234_39:
            ; //	asm I1 = _iADPCCACC469+0;		
00155:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00156:      	AX	= rm[I1]
            ; //	sCX	= 0x0009;			
00157:      	CX	= 0x09
            ; //	sfx_CMP_AX_CX_JGE();			
00158:      	pch	= sfx_CMP_AX_CX_JGE
00159:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto LF66E16C1_13;	
0015A:      	if ZR	jmp LF66E16C1_13
            ; //	goto	LF66E16C1_12;			
0015B:      	jmp	LF66E16C1_12
            ; //LF66E16C1_13:;					
            LF66E16C1_13:
            ; //_A0432E234_40:;					
            _A0432E234_40:
            ; //	sAX	= 0x0000;			
0015C:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
0015D:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0015E:      	rm[I1]	= AX
            ; //LF66E16C1_12:;					
            LF66E16C1_12:
            ; //_A0432E234_41:;					
            _A0432E234_41:
            ; //_A0432E234_42:;					
            _A0432E234_42:
            ; //_A0432E234_43:;					
            _A0432E234_43:
            ; //	_KeyPlayAdpECABF1D0();			
0015F:      	pch	= _KeyPlayAdpECABF1D0
00160:      	lcall	_KeyPlayAdpECABF1D0
            ; //LF66E16C1_11:;					
            LF66E16C1_11:
            ; //_A0432E234_44:;					
            _A0432E234_44:
            ; //	return;					
00161:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_A0432E234_45:;					
            _A0432E234_45:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_A0432E234_46:;					
            _A0432E234_46:
            ; //	
            ; //_A0432E234_47:;					
            _A0432E234_47:
            ; //	asm I1 = _iADPCCACC469+0;		
00162:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00163:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
00164:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
00165:      	CX	= rm[I1]
            ; //	sCX--;					
00166:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
00167:      	rm[I1]	= CX
            ; //_A0432E234_48:;					
            _A0432E234_48:
            ; //	asm I1 = _iADPCCACC469+0;		
00168:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00169:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
0016A:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
0016B:      	pch	= sfx_CMP_AX_CX_JL
0016C:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LF66E16C1_16;	
0016D:      	if ZR	jmp LF66E16C1_16
            ; //	goto	LF66E16C1_15;			
0016E:      	jmp	LF66E16C1_15
            ; //LF66E16C1_16:;					
            LF66E16C1_16:
            ; //_A0432E234_49:;					
            _A0432E234_49:
            ; //	sAX	= 0x0008;			
0016F:      	AX	= 0x08
            ; //	asm I1 = _iADPCCACC469+0;		
00170:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00171:      	rm[I1]	= AX
            ; //LF66E16C1_15:;					
            LF66E16C1_15:
            ; //_A0432E234_50:;					
            _A0432E234_50:
            ; //_A0432E234_51:;					
            _A0432E234_51:
            ; //_A0432E234_52:;					
            _A0432E234_52:
            ; //	_KeyPlayAdpECABF1D0();			
00172:      	pch	= _KeyPlayAdpECABF1D0
00173:      	lcall	_KeyPlayAdpECABF1D0
            ; //LF66E16C1_14:;					
            LF66E16C1_14:
            ; //_A0432E234_53:;					
            _A0432E234_53:
            ; //	return;					
00174:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_A0432E234_54:;					
            _A0432E234_54:
            ; //}
            ; //
            ; //rjmp void _KeyPlaySubb36031D62D()		
            _KeyPlaySubb36031D62D:
            ; //{
            ; //_A0432E234_55:;					
            _A0432E234_55:
            ; //	
            ; //_A0432E234_56:;					
            _A0432E234_56:
            ; //_A0432E234_57:;					
            _A0432E234_57:
            ; //	_StopAllADPCM9255018D();		
00175:      	pch	= _StopAllADPCM9255018D
00176:      	lcall	_StopAllADPCM9255018D
            ; //_A0432E234_58:;					
            _A0432E234_58:
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00177:      	I1 = _PLAY59F2A4ED+0//
            ; //	sAX	= *(__int16*)sSI;		
00178:      	AX	= rm[I1]
            ; //	sSI	= (int)&_PLAY59F2A4ED;		
00179:      	I1	= _PLAY59F2A4ED
            ; //	sCX	= *(__int16*)sSI;		
0017A:      	CX	= rm[I1]
            ; //	sCX++;					
0017B:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
0017C:      	rm[I1]	= CX
            ; //_A0432E234_59:;					
            _A0432E234_59:
            ; //	asm I1 = _PLAY59F2A4ED+0;		
0017D:      	I1 = _PLAY59F2A4ED+0//
            ; //	sAX	= *(__int16*)sSI;		
0017E:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
0017F:      	CX	= 0x02
            ; //	sfx_CMP_AX_CX_JG();			
00180:      	pch	= sfx_CMP_AX_CX_JG
00181:      	lcall	sfx_CMP_AX_CX_JG
            ; //	if(__je__)	goto LF66E16C1_19;	
00182:      	if ZR	jmp LF66E16C1_19
            ; //	goto	LF66E16C1_18;			
00183:      	jmp	LF66E16C1_18
            ; //LF66E16C1_19:;					
            LF66E16C1_19:
            ; //_A0432E234_60:;					
            _A0432E234_60:
            ; //	sAX	= 0x0001;			
00184:      	AX	= 0x01
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00185:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
00186:      	rm[I1]	= AX
            ; //LF66E16C1_18:;					
            LF66E16C1_18:
            ; //_A0432E234_61:;					
            _A0432E234_61:
            ; //_A0432E234_62:;					
            _A0432E234_62:
            ; //_A0432E234_63:;					
            _A0432E234_63:
            ; //	sAX	= 0x0001;			
00187:      	AX	= 0x01
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00188:      	I1 = _PLAY59F2A4ED+0//
            ; //	asm CX = rm[I1];			
00189:      	CX = rm[I1]//
            ; //	sfx_CMP_AX_CX_JE();			
0018A:      	AR	= AX
0018B:      	SF = AR - CX
            ; //	if(__je__)	goto LF66E16C1_22;	
0018C:      	if ZR	jmp LF66E16C1_22
            ; //	goto	LF66E16C1_20;			
0018D:      	jmp	LF66E16C1_20
            ; //LF66E16C1_22:;					
            LF66E16C1_22:
            ; //	asm AX = #subb0+0;			
0018E:      	AX = #subb0+0//
            ; //	asm DX = #subb0.n2			
00190:      	DX = #subb0.n2
            ; //	asm set DX.b11				
00191:      	set DX.b11
            ; //	goto LF66E16C1_21;			
00192:      	jmp	LF66E16C1_21
            ; //LF66E16C1_20:;					
            LF66E16C1_20:
            ; //	asm AX = #subb1+0;			
00193:      	AX = #subb1+0//
            ; //	asm DX = #subb1.n2			
00195:      	DX = #subb1.n2
            ; //	asm set DX.b11				
00196:      	set DX.b11
            ; //LF66E16C1_21:;					
            LF66E16C1_21:
            ; //	PUSH(sDX);				
00197:      	push	DX
            ; //	PUSH(sAX);				
00198:      	push	AX
            ; //	_Sub3Play422CAD6D(STACK[sSP + 0], STACK[sSP + 1]);
00199:      	pch	= _Sub3Play422CAD6D
0019A:      	lcall	_Sub3Play422CAD6D
            ; //	RESTORESP(2);				
0019B:      	pop	AR
0019C:      	pop	AR
            ; //LF66E16C1_17:;					
            LF66E16C1_17:
            ; //_A0432E234_64:;					
            _A0432E234_64:
            ; //	return;					
0019D:      	rets
            ; //_KeyPlaySubb36031D62D_end:;			
            _KeyPlaySubb36031D62D_end:
            ; //_A0432E234_65:;					
            _A0432E234_65:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayPrev8E98A35A[0], 0x0000, 0x0000, (int)&_KeyPlayAdpECABF1D0[0], 0x0000, 0x0000, (int)&_KeyPlayNextAFBA8CED[0], 0x0000, 
0019E:      DW #_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyPlayAdpECABF1D0,0x0000,0x0000,#_KeyPlayNextAFBA8CED,0x0000,
            ; //	0x0000, (int)&_KeyPlaySubb36031D62D[0], 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
001A6:      DW 0x0000,#_KeyPlaySubb36031D62D,0x0000,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\D_CF87A0F9.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void L0E8FA404_24()			
            L0E8FA404_24:
            ; //{
            ; //_A0432E234_66:;					
            _A0432E234_66:
            ; //	
            ; //_A0432E234_67:;					
            _A0432E234_67:
            ; //	io[0x16]	= 0x0000;		
001AD:      	AR	= 0x00
001AE:      	io[0x16]	= AR
            ; //_A0432E234_68:;					
            _A0432E234_68:
            ; //	io[0x16]	= 0x0000;		
001AF:      	AR	= 0x00
001B0:      	io[0x16]	= AR
            ; //_A0432E234_69:;					
            _A0432E234_69:
            ; //	io[0x16]	= 0x0000;		
001B1:      	AR	= 0x00
001B2:      	io[0x16]	= AR
            ; //_A0432E234_70:;					
            _A0432E234_70:
            ; //	io[0x16]	= 0x0000;		
001B3:      	AR	= 0x00
001B4:      	io[0x16]	= AR
            ; //_A0432E234_71:;					
            _A0432E234_71:
            ; //	io[0x36]	= 0x0000;		
001B5:      	AR	= 0x00
001B6:      	io[0x36]	= AR
            ; //_A0432E234_72:;					
            _A0432E234_72:
            ; //	io[0x36]	= 0x0000;		
001B7:      	AR	= 0x00
001B8:      	io[0x36]	= AR
            ; //_A0432E234_73:;					
            _A0432E234_73:
            ; //	io[0x36]	= 0x0000;		
001B9:      	AR	= 0x00
001BA:      	io[0x36]	= AR
            ; //_A0432E234_74:;					
            _A0432E234_74:
            ; //	io[0x36]	= 0x0000;		
001BB:      	AR	= 0x00
001BC:      	io[0x36]	= AR
            ; //_A0432E234_75:;					
            _A0432E234_75:
            ; //	io[0x36]	= 0x0000;		
001BD:      	AR	= 0x00
001BE:      	io[0x36]	= AR
            ; //_A0432E234_76:;					
            _A0432E234_76:
            ; //	io[0x36]	= 0x0000;		
001BF:      	AR	= 0x00
001C0:      	io[0x36]	= AR
            ; //_A0432E234_77:;					
            _A0432E234_77:
            ; //	io[0x36]	= 0x0000;		
001C1:      	AR	= 0x00
001C2:      	io[0x36]	= AR
            ; //_A0432E234_78:;					
            _A0432E234_78:
            ; //	io[0x36]	= 0x0000;		
001C3:      	AR	= 0x00
001C4:      	io[0x36]	= AR
            ; //_A0432E234_79:;					
            _A0432E234_79:
            ; //	io[0x3E]	= 0x2000;		
001C5:      	AR	= 0x2000
001C7:      	io[0x3E]	= AR
            ; //_A0432E234_80:;					
            _A0432E234_80:
            ; //	io[0x3C]	= 0x003F;		
001C8:      	AR	= 0x3F
001C9:      	io[0x3C]	= AR
            ; //_A0432E234_81:;					
            _A0432E234_81:
            ; //	sAX	= io[0x3C];			
001CA:      	AR	= io[0x3C]
001CB:      	AX	= AR
            ; //_A0432E234_82:;					
            _A0432E234_82:
            ; //	asm	set io[MISC].b9			
001CC:      	set io[MISC].b9
            ; //_A0432E234_83:;					
            _A0432E234_83:
            ; //	asm	set io[MISC].b8			
001CD:      	set io[MISC].b8
            ; //_A0432E234_84:;					
            _A0432E234_84:
            ; //	asm	set io[MISC].b4			
001CE:      	set io[MISC].b4
            ; //L0E8FA404_26:;					
            L0E8FA404_26:
            ; //_A0432E234_85:;					
            _A0432E234_85:
            ; //	return;					
001CF:      	rets
            ; //L0E8FA404_24_end:;				
            L0E8FA404_24_end:
            ; //_A0432E234_86:;					
            _A0432E234_86:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_27()			
            L0E8FA404_27:
            ; //{
            ; //_A0432E234_87:;					
            _A0432E234_87:
            ; //	
            ; //_A0432E234_88:;					
            _A0432E234_88:
            ; //	io[0x04]	= 0x000F;		
001D0:      	AR	= 0x0F
001D1:      	io[0x04]	= AR
            ; //_A0432E234_89:;					
            _A0432E234_89:
            ; //	io[0x05]	= 0xFFFF;		
001D2:      	AR	= 0xFFFF
001D4:      	io[0x05]	= AR
            ; //_A0432E234_90:;					
            _A0432E234_90:
            ; //	io[0x07]	= 0x0000;		
001D5:      	AR	= 0x00
001D6:      	io[0x07]	= AR
            ; //_A0432E234_91:;					
            _A0432E234_91:
            ; //	io[0x08]	= 0xFFFF;		
001D7:      	AR	= 0xFFFF
001D9:      	io[0x08]	= AR
            ; //L0E8FA404_29:;					
            L0E8FA404_29:
            ; //_A0432E234_92:;					
            _A0432E234_92:
            ; //	return;					
001DA:      	rets
            ; //L0E8FA404_27_end:;				
            L0E8FA404_27_end:
            ; //_A0432E234_93:;					
            _A0432E234_93:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_A0432E234_94:;					
            _A0432E234_94:
            ; //	
            ; //_A0432E234_95:;					
            _A0432E234_95:
            ; //	sAX	= 0xFFFF;			
001DB:      	AX	= 0xFFFF
            ; //	asm I1 = _iADPCCACC469+0;		
001DD:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
001DE:      	rm[I1]	= AX
            ; //_A0432E234_96:;					
            _A0432E234_96:
            ; //_A0432E234_97:;					
            _A0432E234_97:
            ; //	NEARCALL(L0E8FA404_24);			
001DF:      	call	L0E8FA404_24
            ; //_A0432E234_98:;					
            _A0432E234_98:
            ; //_A0432E234_99:;					
            _A0432E234_99:
            ; //	NEARCALL(L0E8FA404_27);			
001E0:      	call	L0E8FA404_27
            ; //L0E8FA404_30:;					
            L0E8FA404_30:
            ; //_A0432E234_100:;				
            _A0432E234_100:
            ; //	return;					
001E1:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A0432E234_101:;				
            _A0432E234_101:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> Start=========================
            ; playadp.c Code Start!!;
            VarRM[0:4095]={
             _iADPCCACC469,_adpch30670376[18],_adpFLTG0FBE3CB5,ADPCMY[8] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4);
            ; //rjmp void ADPCM_CHX_Init();
            ; //rjmp void DoADPCM();
            ; //rjmp void _StopAllADPCM9255018D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4)
            _playADPCMBACD5AFD:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //	__int16 _q_1_6;
            ; //						
001E2:      	AR	= rm[BP_SAVE]
001E3:      	push	AR
001E4:      	AR	= BP
001E5:      	rm[BP_SAVE]	= AR
001E6:      	AR	 = -3
001E7:      	BP	+= AR
            ; //_A0432E234_102:;				
            _A0432E234_102:
            ; //	
            ; //_A0432E234_103:;				
            _A0432E234_103:
            ; //	asm AX = _adpch30670376+0;		
001E8:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
001E9:      	AR	= -1
001EA:      	I1	= rm[BP_SAVE]
001EB:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
001EC:      	rm[I1]	= AX
            ; //_A0432E234_104:;				
            _A0432E234_104:
            ; //	_i_1_2+0	= 0x00;			
001ED:      	I1	= rm[BP_SAVE]
001EE:      	AX	= 0x00
001EF:      	rm[I1]	= AX
            ; //L7F5A46A0_33:;					
            L7F5A46A0_33:
            ; //	sSI	= (int)&_i_1_2;			
001F0:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F1:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
001F2:      	CX	= 0x01
            ; //	sfx_CMP_AX_CX_JL();			
001F3:      	pch	= sfx_CMP_AX_CX_JL
001F4:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L7F5A46A0_37;	
001F5:      	if ZR	jmp L7F5A46A0_37
            ; //	goto	L7F5A46A0_35;			
001F6:      	jmp	L7F5A46A0_35
            ; //L7F5A46A0_37:;					
            L7F5A46A0_37:
            ; //	goto L7F5A46A0_34;			
001F7:      	jmp	L7F5A46A0_34
            ; //L7F5A46A0_36:;					
            L7F5A46A0_36:
            ; //	sSI	= (int)&_i_1_2;			
001F8:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F9:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
001FA:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
001FB:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
001FC:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
001FD:      	rm[I1] = CX + AR//
            ; //	goto L7F5A46A0_33;			
001FE:      	jmp	L7F5A46A0_33
            ; //L7F5A46A0_34:;					
            L7F5A46A0_34:
            ; //	
            ; //_A0432E234_105:;				
            _A0432E234_105:
            ; //	sSI	= (int)&_p_1_4;			
001FF:      	AR	= -1
00200:      	I1	= rm[BP_SAVE]
00201:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00202:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00203:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00204:      	AR	= CX
00205:      	AX	+= AR
            ; //	sSI	= sAX;				
00206:      	AR	= AX
00207:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00208:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00209:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
0020A:      	AR	= AX
0020B:      	AR	|= DX
            ; //	if(__jz__)	goto L7F5A46A0_39;	
0020C:      	if ZR	jmp L7F5A46A0_39
            ; //	goto	L7F5A46A0_38;			
0020D:      	jmp	L7F5A46A0_38
            ; //L7F5A46A0_39:;					
            L7F5A46A0_39:
            ; //	
            ; //_A0432E234_106:;				
            _A0432E234_106:
            ; //_A0432E234_107:;				
            _A0432E234_107:
            ; //	sAX	= 0x0012;			
0020E:      	AX	= 0x12
            ; //	PUSH(sAX);				
0020F:      	push	AX
            ; //	sAX	= 0x0000;			
00210:      	AX	= 0x00
            ; //	PUSH(sAX);				
00211:      	push	AX
            ; //	sSI	= (int)&_p_1_4;			
00212:      	AR	= -1
00213:      	I1	= rm[BP_SAVE]
00214:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00215:      	AX	= rm[I1]
            ; //	sDX	= 0;				
00216:      	DX	= 0x00
            ; //	PUSH(sDX);				
00217:      	push	DX
            ; //	PUSH(sAX);				
00218:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00219:      	pch	= _memset5A9D755A
0021A:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
0021B:      	AR	= 4
0021C:      	BP	+= AR
            ; //_A0432E234_108:;				
            _A0432E234_108:
            ; //	asm AX = #_adpdata32993E3B+0;		
0021D:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
0021F:      	push	AX
            ; //	sSI	= (int)&_index_0_4;		
00220:      	AR	= 2
00221:      	I1	= rm[BP_SAVE]
00222:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00223:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
00224:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
00225:      	pch	= sfx_IMUL_AX_CX
00226:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
00227:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00228:      	AR	= CX
00229:      	AX	+= AR
            ; //	sSI	= (int)&_q_1_6;			
0022A:      	AR	= -2
0022B:      	I1	= rm[BP_SAVE]
0022C:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0022D:      	rm[I1]	= AX
            ; //_A0432E234_109:;				
            _A0432E234_109:
            ; //	sSI	= (int)&_p_1_4;			
0022E:      	AR	= -1
0022F:      	I1	= rm[BP_SAVE]
00230:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00231:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00232:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00233:      	AR	= CX
00234:      	AX	+= AR
            ; //	PUSH(sAX);				
00235:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00236:      	AR	= -2
00237:      	I1	= rm[BP_SAVE]
00238:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00239:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
0023A:      	AR	= AX
0023B:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
0023C:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
0023D:      	DX	= pm[P1--]
            ; //	sSI	= POP();			
0023E:      	pop	I1
            ; //	sfx_STORSILONG();			
0023F:      	rm[I1++]	= AX
00240:      	rm[I1--]	= DX
            ; //_A0432E234_110:;				
            _A0432E234_110:
            ; //	sSI	= (int)&_p_1_4;			
00241:      	AR	= -1
00242:      	I1	= rm[BP_SAVE]
00243:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00244:      	AX	= rm[I1]
            ; //	sCX	= 0x0011;			
00245:      	CX	= 0x11
            ; //	sAX	= sAX + sCX;			
00246:      	AR	= CX
00247:      	AX	+= AR
            ; //	PUSH(sAX);				
00248:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00249:      	AR	= -2
0024A:      	I1	= rm[BP_SAVE]
0024B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0024C:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
0024D:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0024E:      	AR	= CX
0024F:      	AX	+= AR
            ; //	sDI	= sAX;				
00250:      	AR	= AX
00251:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00252:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00253:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00254:      	rm[I1]	= AX
            ; //_A0432E234_111:;				
            _A0432E234_111:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
00255:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	PUSH(sAX);				
00256:      	push	AX
            ; //	sSI	= (int)&_i_1_2;			
00257:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00258:      	AX	= rm[I1]
            ; //	
            ; //	sCX	= POP();			
00259:      	pop	CX
            ; //	sAX	= sAX + sCX;			
0025A:      	AR	= CX
0025B:      	AX	+= AR
            ; //	PUSH(sAX);				
0025C:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
0025D:      	AR	= -2
0025E:      	I1	= rm[BP_SAVE]
0025F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00260:      	AX	= rm[I1]
            ; //	sCX	= 0x0003;			
00261:      	CX	= 0x03
            ; //	sAX	= sAX + sCX;			
00262:      	AR	= CX
00263:      	AX	+= AR
            ; //	sDI	= sAX;				
00264:      	AR	= AX
00265:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00266:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00267:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00268:      	rm[I1]	= AX
            ; //_A0432E234_112:;				
            _A0432E234_112:
            ; //	sAX	= 0x0001;			
00269:      	AX	= 0x01
            ; //	goto L7F5A46A0_32;			
0026A:      	jmp	L7F5A46A0_32
            ; //L7F5A46A0_38:;					
            L7F5A46A0_38:
            ; //_A0432E234_113:;				
            _A0432E234_113:
            ; //_A0432E234_114:;				
            _A0432E234_114:
            ; //	sSI	= (int)&_p_1_4;			
0026B:      	AR	= -1
0026C:      	I1	= rm[BP_SAVE]
0026D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0026E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
0026F:      	AR	= -1
00270:      	I1	= rm[BP_SAVE]
00271:      	I1	+= AR
            ; //	asm AR = 0x0012;			
00272:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
00273:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
00274:      	rm[I1] = CX + AR//
            ; //_A0432E234_115:;				
            _A0432E234_115:
            ; //	goto L7F5A46A0_36;			
00275:      	jmp	L7F5A46A0_36
            ; //L7F5A46A0_35:;					
            L7F5A46A0_35:
            ; //_A0432E234_116:;				
            _A0432E234_116:
            ; //	sAX	= 0x0000;			
00276:      	AX	= 0x00
            ; //	goto L7F5A46A0_32;			
00277:      	jmp	L7F5A46A0_32
            ; //L7F5A46A0_32:;					
            L7F5A46A0_32:
            ; //_A0432E234_117:;				
            _A0432E234_117:
            ; //	return;					
00278:      	AR	= 3
00279:      	BP	+= AR
0027A:      	pop	AR
0027B:      	rm[BP_SAVE]	= AR
0027C:      	rets
            ; //_playADPCMBACD5AFD_end:;			
            _playADPCMBACD5AFD_end:
            ; //_A0432E234_118:;				
            _A0432E234_118:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHX_Init()			
            ADPCM_CHX_Init:
            ; //{
            ; //_A0432E234_119:;				
            _A0432E234_119:
            ; //	
            ; //_A0432E234_120:;				
            _A0432E234_120:
            ; //	sAX	= 0x0000;			
0027D:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
0027E:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0027F:      	rm[I1]	= AX
            ; //_A0432E234_121:;				
            _A0432E234_121:
            ; //_A0432E234_122:;				
            _A0432E234_122:
            ; //	sAX	= 0x0012;			
00280:      	AX	= 0x12
            ; //	PUSH(sAX);				
00281:      	push	AX
            ; //	sAX	= 0x0000;			
00282:      	AX	= 0x00
            ; //	PUSH(sAX);				
00283:      	push	AX
            ; //	asm AX = _adpch30670376+0;		
00284:      	AX = _adpch30670376+0//
            ; //	sDX	= 0;				
00285:      	DX	= 0x00
            ; //	PUSH(sDX);				
00286:      	push	DX
            ; //	PUSH(sAX);				
00287:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00288:      	pch	= _memset5A9D755A
00289:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
0028A:      	AR	= 4
0028B:      	BP	+= AR
            ; //L7F5A46A0_40:;					
            L7F5A46A0_40:
            ; //_A0432E234_123:;				
            _A0432E234_123:
            ; //	return;					
0028C:      	rets
            ; //ADPCM_CHX_Init_end:;				
            ADPCM_CHX_Init_end:
            ; //_A0432E234_124:;				
            _A0432E234_124:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_41()			
            L7F5A46A0_41:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
0028D:      	AR	= rm[BP_SAVE]
0028E:      	push	AR
0028F:      	AR	= BP
00290:      	rm[BP_SAVE]	= AR
00291:      	AR	 = -1
00292:      	BP	+= AR
            ; //_A0432E234_125:;				
            _A0432E234_125:
            ; //	
            ; //_A0432E234_126:;				
            _A0432E234_126:
            ; //	asm AX = ADPCMY+0;			
00293:      	AX = ADPCMY+0//
            ; //_A0432E234_127:;				
            _A0432E234_127:
            ; //	asm	AR = AX				
00294:      	AR = AX
            ; //_A0432E234_128:;				
            _A0432E234_128:
            ; //	asm	I0 = AR				
00295:      	I0 = AR
            ; //	
            ; //	
            ; //_A0432E234_129:;				
            _A0432E234_129:
            ; //	_i_1_2+0	= 0x08;			
00296:      	I1	= rm[BP_SAVE]
00297:      	AX	= 0x08
00298:      	rm[I1]	= AX
            ; //L7F5A46A0_45:;					
            L7F5A46A0_45:
            ; //_A0432E234_130:;				
            _A0432E234_130:
            ; //	sSI	= (int)&_i_1_2;			
00299:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0029A:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
0029B:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_46;	
0029C:      	if NZ	jmp L7F5A46A0_46
            ; //	goto	L7F5A46A0_44;			
0029D:      	jmp	L7F5A46A0_44
            ; //L7F5A46A0_46:;					
            L7F5A46A0_46:
            ; //	
            ; //_A0432E234_131:;				
            _A0432E234_131:
            ; //	sAX	= 0x0000;			
0029E:      	AX	= 0x00
            ; //_A0432E234_132:;				
            _A0432E234_132:
            ; //	asm	rm[I0++] = AX			
0029F:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_133:;				
            _A0432E234_133:
            ; //	sSI	= (int)&_i_1_2;			
002A0:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002A1:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
002A2:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
002A3:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
002A4:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
002A5:      	rm[I1] = CX - AR//
            ; //_A0432E234_134:;				
            _A0432E234_134:
            ; //	goto L7F5A46A0_45;			
002A6:      	jmp	L7F5A46A0_45
            ; //L7F5A46A0_44:;					
            L7F5A46A0_44:
            ; //L7F5A46A0_43:;					
            L7F5A46A0_43:
            ; //_A0432E234_135:;				
            _A0432E234_135:
            ; //	return;					
002A7:      	AR	= 1
002A8:      	BP	+= AR
002A9:      	pop	AR
002AA:      	rm[BP_SAVE]	= AR
002AB:      	rets
            ; //L7F5A46A0_41_end:;				
            L7F5A46A0_41_end:
            ; //_A0432E234_136:;				
            _A0432E234_136:
            ; //}
            ; //
            ; //rjmp void DoADPCM()				
            DoADPCM:
            ; //{
            ; //_A0432E234_137:;				
            _A0432E234_137:
            ; //	
            ; //_A0432E234_138:;				
            _A0432E234_138:
            ; //	asm AX = ADPCMY+0;			
002AC:      	AX = ADPCMY+0//
            ; //_A0432E234_139:;				
            _A0432E234_139:
            ; //	asm	AR = AX				
002AD:      	AR = AX
            ; //_A0432E234_140:;				
            _A0432E234_140:
            ; //	asm	I0 = AR				
002AE:      	I0 = AR
            ; //	
            ; //	
            ; //_A0432E234_141:;				
            _A0432E234_141:
            ; //	sAX	= 0x0000;			
002AF:      	AX	= 0x00
            ; //_A0432E234_142:;				
            _A0432E234_142:
            ; //	asm	rm[I0++] = AX			
002B0:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_143:;				
            _A0432E234_143:
            ; //	sAX	= 0x0000;			
002B1:      	AX	= 0x00
            ; //_A0432E234_144:;				
            _A0432E234_144:
            ; //	asm	rm[I0++] = AX			
002B2:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_145:;				
            _A0432E234_145:
            ; //	sAX	= 0x0000;			
002B3:      	AX	= 0x00
            ; //_A0432E234_146:;				
            _A0432E234_146:
            ; //	asm	rm[I0++] = AX			
002B4:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_147:;				
            _A0432E234_147:
            ; //	sAX	= 0x0000;			
002B5:      	AX	= 0x00
            ; //_A0432E234_148:;				
            _A0432E234_148:
            ; //	asm	rm[I0++] = AX			
002B6:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_149:;				
            _A0432E234_149:
            ; //	sAX	= 0x0000;			
002B7:      	AX	= 0x00
            ; //_A0432E234_150:;				
            _A0432E234_150:
            ; //	asm	rm[I0++] = AX			
002B8:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_151:;				
            _A0432E234_151:
            ; //	sAX	= 0x0000;			
002B9:      	AX	= 0x00
            ; //_A0432E234_152:;				
            _A0432E234_152:
            ; //	asm	rm[I0++] = AX			
002BA:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_153:;				
            _A0432E234_153:
            ; //	sAX	= 0x0000;			
002BB:      	AX	= 0x00
            ; //_A0432E234_154:;				
            _A0432E234_154:
            ; //	asm	rm[I0++] = AX			
002BC:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_155:;				
            _A0432E234_155:
            ; //	sAX	= 0x0000;			
002BD:      	AX	= 0x00
            ; //_A0432E234_156:;				
            _A0432E234_156:
            ; //	asm	rm[I0++] = AX			
002BE:      	rm[I0++] = AX
            ; //	
            ; //_A0432E234_157:;				
            _A0432E234_157:
            ; //	asm AX = _adpch30670376+0;		
002BF:      	AX = _adpch30670376+0//
            ; //	asm I1 = ADPCM_Tmpi+0;			
002C0:      	I1 = ADPCM_Tmpi+0//
            ; //	*(__int16*)sSI	= sAX			
002C1:      	rm[I1]	= AX
            ; //_A0432E234_158:;				
            _A0432E234_158:
            ; //	asm I1 = _adpFLTG0FBE3CB5+0;		
002C2:      	I1 = _adpFLTG0FBE3CB5+0//
            ; //	sAX	= *(__int16*)sSI;		
002C3:      	AX	= rm[I1]
            ; //	io[0x3C]	= sAX;			
002C4:      	AR	= AX
002C5:      	io[0x3C]	= AR
            ; //_A0432E234_159:;				
            _A0432E234_159:
            ; //_A0432E234_160:;				
            _A0432E234_160:
            ; //	DecodeChannel();			
002C6:      	pch	= DecodeChannel
002C7:      	lcall	DecodeChannel
            ; //L7F5A46A0_47:;					
            L7F5A46A0_47:
            ; //_A0432E234_161:;				
            _A0432E234_161:
            ; //	return;					
002C8:      	rets
            ; //DoADPCM_end:;					
            DoADPCM_end:
            ; //_A0432E234_162:;				
            _A0432E234_162:
            ; //}
            ; //
            ; //rjmp void _StopAllADPCM9255018D()		
            _StopAllADPCM9255018D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //						
002C9:      	AR	= rm[BP_SAVE]
002CA:      	push	AR
002CB:      	AR	= BP
002CC:      	rm[BP_SAVE]	= AR
002CD:      	AR	 = -2
002CE:      	BP	+= AR
            ; //_A0432E234_163:;				
            _A0432E234_163:
            ; //	
            ; //_A0432E234_164:;				
            _A0432E234_164:
            ; //	_i_1_2+0	= 0x01;			
002CF:      	I1	= rm[BP_SAVE]
002D0:      	AX	= 0x01
002D1:      	rm[I1]	= AX
            ; //_A0432E234_165:;				
            _A0432E234_165:
            ; //	asm AX = _adpch30670376+0;		
002D2:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
002D3:      	AR	= -1
002D4:      	I1	= rm[BP_SAVE]
002D5:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
002D6:      	rm[I1]	= AX
            ; //L7F5A46A0_50:;					
            L7F5A46A0_50:
            ; //_A0432E234_166:;				
            _A0432E234_166:
            ; //	sSI	= (int)&_i_1_2;			
002D7:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002D8:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
002D9:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
002DA:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
002DB:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
002DC:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
002DD:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_51;	
002DE:      	if NZ	jmp L7F5A46A0_51
            ; //	goto	L7F5A46A0_49;			
002DF:      	jmp	L7F5A46A0_49
            ; //L7F5A46A0_51:;					
            L7F5A46A0_51:
            ; //	
            ; //_A0432E234_167:;				
            _A0432E234_167:
            ; //	sSI	= (int)&_p_1_4;			
002E0:      	AR	= -1
002E1:      	I1	= rm[BP_SAVE]
002E2:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002E3:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
002E4:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
002E5:      	AR	= CX
002E6:      	AX	+= AR
            ; //	PUSH(sAX);				
002E7:      	push	AX
            ; //	sAX	= 0x0000;			
002E8:      	AX	= 0x00
            ; //	sDX	= 0x0000;			
002E9:      	DX	= 0x00
            ; //	sSI	= POP();			
002EA:      	pop	I1
            ; //	sfx_STORSILONG();			
002EB:      	rm[I1++]	= AX
002EC:      	rm[I1--]	= DX
            ; //_A0432E234_168:;				
            _A0432E234_168:
            ; //	sSI	= (int)&_p_1_4;			
002ED:      	AR	= -1
002EE:      	I1	= rm[BP_SAVE]
002EF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002F0:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
002F1:      	AR	= -1
002F2:      	I1	= rm[BP_SAVE]
002F3:      	I1	+= AR
            ; //	asm AR = 0x0012;			
002F4:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
002F5:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
002F6:      	rm[I1] = CX + AR//
            ; //_A0432E234_169:;				
            _A0432E234_169:
            ; //	goto L7F5A46A0_50;			
002F7:      	jmp	L7F5A46A0_50
            ; //L7F5A46A0_49:;					
            L7F5A46A0_49:
            ; //L7F5A46A0_48:;					
            L7F5A46A0_48:
            ; //_A0432E234_170:;				
            _A0432E234_170:
            ; //	return;					
002F8:      	AR	= 2
002F9:      	BP	+= AR
002FA:      	pop	AR
002FB:      	rm[BP_SAVE]	= AR
002FC:      	rets
            ; //_StopAllADPCM9255018D_end:;			
            _StopAllADPCM9255018D_end:
            ; //_A0432E234_171:;				
            _A0432E234_171:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_53,L5589D4CE_54,L5589D4CE_55 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_A0432E234_172:;				
            _A0432E234_172:
            ; //	
            ; //_A0432E234_173:;				
            _A0432E234_173:
            ; //	asm clr io[0x04].b0;			
002FD:      	clr io[0x04].b0//
            ; //_A0432E234_174:;				
            _A0432E234_174:
            ; //	asm clr io[0x04].b1;			
002FE:      	clr io[0x04].b1//
            ; //_A0432E234_175:;				
            _A0432E234_175:
            ; //	asm clr io[0x04].b2;			
002FF:      	clr io[0x04].b2//
            ; //_A0432E234_176:;				
            _A0432E234_176:
            ; //	asm clr io[0x04].b3;			
00300:      	clr io[0x04].b3//
            ; //_A0432E234_177:;				
            _A0432E234_177:
            ; //	io[0x1E]	= 0x0005;		
00301:      	AR	= 0x05
00302:      	io[0x1E]	= AR
            ; //_A0432E234_178:;				
            _A0432E234_178:
            ; //	sAX	= 0x000F;			
00303:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
00304:      	AR	= io[0x1F]
00305:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
00306:      	AR	= AX
00307:      	io[0x1F]	= AR
            ; //_A0432E234_179:;				
            _A0432E234_179:
            ; //	sAX	= 0x0000;			
00308:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_53;		
00309:      	I1	= L5589D4CE_53
            ; //	*(__int16*)sSI	= sAX			
0030A:      	rm[I1]	= AX
            ; //_A0432E234_180:;				
            _A0432E234_180:
            ; //	sAX	= 0x0000;			
0030B:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_54;		
0030C:      	I1	= L5589D4CE_54
            ; //	*(__int16*)sSI	= sAX			
0030D:      	rm[I1]	= AX
            ; //_A0432E234_181:;				
            _A0432E234_181:
            ; //	sAX	= 0x0200;			
0030E:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_55;		
00310:      	I1	= L5589D4CE_55
            ; //	*(__int16*)sSI	= sAX			
00311:      	rm[I1]	= AX
            ; //L5589D4CE_56:;					
            L5589D4CE_56:
            ; //_A0432E234_182:;				
            _A0432E234_182:
            ; //	return;					
00312:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_A0432E234_183:;				
            _A0432E234_183:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_57()			
            L5589D4CE_57:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
00313:      	AR	= rm[BP_SAVE]
00314:      	push	AR
00315:      	AR	= BP
00316:      	rm[BP_SAVE]	= AR
00317:      	AR	 = -1
00318:      	BP	+= AR
            ; //_A0432E234_184:;				
            _A0432E234_184:
            ; //	
            ; //_A0432E234_185:;				
            _A0432E234_185:
            ; //	sAX	= 0x000F;			
00319:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
0031A:      	AR	= io[0x07]
0031B:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
0031C:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0031D:      	rm[I1]	= AX
            ; //_A0432E234_186:;				
            _A0432E234_186:
            ; //	sSI	= (int)&_btn_1_2;		
0031E:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0031F:      	AX	= rm[I1]
            ; //	goto L5589D4CE_59;			
00320:      	jmp	L5589D4CE_59
            ; //L5589D4CE_59:;					
            L5589D4CE_59:
            ; //_A0432E234_187:;				
            _A0432E234_187:
            ; //	return;					
00321:      	AR	= 1
00322:      	BP	+= AR
00323:      	pop	AR
00324:      	rm[BP_SAVE]	= AR
00325:      	rets
            ; //L5589D4CE_57_end:;				
            L5589D4CE_57_end:
            ; //_A0432E234_188:;				
            _A0432E234_188:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
00326:      	AR	= rm[BP_SAVE]
00327:      	push	AR
00328:      	AR	= BP
00329:      	rm[BP_SAVE]	= AR
0032A:      	AR	 = -5
0032B:      	BP	+= AR
            ; //_A0432E234_189:;				
            _A0432E234_189:
            ; //	
            ; //_A0432E234_190:;				
            _A0432E234_190:
            ; //_A0432E234_191:;				
            _A0432E234_191:
            ; //	NEARCALL(L5589D4CE_57);			
0032C:      	call	L5589D4CE_57
            ; //	sSI	= (int)&_keynow_1_2;		
0032D:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0032E:      	rm[I1]	= AX
            ; //_A0432E234_192:;				
            _A0432E234_192:
            ; //	asm I1 = L5589D4CE_53+0;		
0032F:      	I1 = L5589D4CE_53+0//
            ; //	sAX	= *(__int16*)sSI;		
00330:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
00331:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00332:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00333:      	pch	= sfx_CMP_AX_CX_JNE
00334:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_62;	
00335:      	if ZR	jmp L5589D4CE_62
            ; //	goto	L5589D4CE_61;			
00336:      	jmp	L5589D4CE_61
            ; //L5589D4CE_62:;					
            L5589D4CE_62:
            ; //	
            ; //_A0432E234_193:;				
            _A0432E234_193:
            ; //	sSI	= (int)&_keynow_1_2;		
00337:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00338:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_53;		
00339:      	I1	= L5589D4CE_53
            ; //	*(__int16*)sSI	= sAX			
0033A:      	rm[I1]	= AX
            ; //_A0432E234_194:;				
            _A0432E234_194:
            ; //	sAX	= 0x0200;			
0033B:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_55;		
0033D:      	I1	= L5589D4CE_55
            ; //	*(__int16*)sSI	= sAX			
0033E:      	rm[I1]	= AX
            ; //_A0432E234_195:;				
            _A0432E234_195:
            ; //	goto L5589D4CE_60;			
0033F:      	jmp	L5589D4CE_60
            ; //L5589D4CE_61:;					
            L5589D4CE_61:
            ; //_A0432E234_196:;				
            _A0432E234_196:
            ; //_A0432E234_197:;				
            _A0432E234_197:
            ; //	asm I1 = L5589D4CE_55+0;		
00340:      	I1 = L5589D4CE_55+0//
            ; //	sAX	= *(__int16*)sSI;		
00341:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00342:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_64;	
00343:      	if NZ	jmp L5589D4CE_64
            ; //	goto	L5589D4CE_63;			
00344:      	jmp	L5589D4CE_63
            ; //L5589D4CE_64:;					
            L5589D4CE_64:
            ; //	
            ; //_A0432E234_198:;				
            _A0432E234_198:
            ; //	asm I1 = L5589D4CE_55+0;		
00345:      	I1 = L5589D4CE_55+0//
            ; //	sAX	= *(__int16*)sSI;		
00346:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00347:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
00348:      	AR	= CX
00349:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_55;		
0034A:      	I1	= L5589D4CE_55
            ; //	*(__int16*)sSI	= sAX			
0034B:      	rm[I1]	= AX
            ; //_A0432E234_199:;				
            _A0432E234_199:
            ; //	goto L5589D4CE_60;			
0034C:      	jmp	L5589D4CE_60
            ; //L5589D4CE_63:;					
            L5589D4CE_63:
            ; //_A0432E234_200:;				
            _A0432E234_200:
            ; //_A0432E234_201:;				
            _A0432E234_201:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
0034D:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
0034F:      	AR	= -4
00350:      	I1	= rm[BP_SAVE]
00351:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00352:      	rm[I1]	= AX
            ; //_A0432E234_202:;				
            _A0432E234_202:
            ; //	sAX	= 0x0200;			
00353:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_55;		
00355:      	I1	= L5589D4CE_55
            ; //	*(__int16*)sSI	= sAX			
00356:      	rm[I1]	= AX
            ; //_A0432E234_203:;				
            _A0432E234_203:
            ; //	asm I1 = L5589D4CE_54+0;		
00357:      	I1 = L5589D4CE_54+0//
            ; //	sAX	= *(__int16*)sSI;		
00358:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_53+0;		
00359:      	I1 = L5589D4CE_53+0//
            ; //	asm AR = rm[I1];			
0035A:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
0035B:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0035C:      	AR	= -2
0035D:      	I1	= rm[BP_SAVE]
0035E:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0035F:      	rm[I1]	= AX
            ; //_A0432E234_204:;				
            _A0432E234_204:
            ; //	asm I1 = L5589D4CE_54+0;		
00360:      	I1 = L5589D4CE_54+0//
            ; //	sAX	= *(__int16*)sSI;		
00361:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00362:      	AR	= -3
00363:      	I1	= rm[BP_SAVE]
00364:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00365:      	rm[I1]	= AX
            ; //_A0432E234_205:;				
            _A0432E234_205:
            ; //	asm I1 = L5589D4CE_53+0;		
00366:      	I1 = L5589D4CE_53+0//
            ; //	sAX	= *(__int16*)sSI;		
00367:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_54;		
00368:      	I1	= L5589D4CE_54
            ; //	*(__int16*)sSI	= sAX			
00369:      	rm[I1]	= AX
            ; //_A0432E234_206:;				
            _A0432E234_206:
            ; //	_i_1_4+0	= 0x05;			
0036A:      	AR	= -1
0036B:      	I1	= rm[BP_SAVE]
0036C:      	I1	+= AR
0036D:      	AX	= 0x05
0036E:      	rm[I1]	= AX
            ; //L5589D4CE_66:;					
            L5589D4CE_66:
            ; //_A0432E234_207:;				
            _A0432E234_207:
            ; //	sSI	= (int)&_i_1_4;			
0036F:      	AR	= -1
00370:      	I1	= rm[BP_SAVE]
00371:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00372:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00373:      	AR	= -1
00374:      	I1	= rm[BP_SAVE]
00375:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00376:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00377:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00378:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00379:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_67;	
0037A:      	if NZ	jmp L5589D4CE_67
            ; //	goto	L5589D4CE_65;			
0037B:      	jmp	L5589D4CE_65
            ; //L5589D4CE_67:;					
            L5589D4CE_67:
            ; //	
            ; //_A0432E234_208:;				
            _A0432E234_208:
            ; //	sAX	= 0;				
0037C:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
0037D:      	AR	= -2
0037E:      	I1	= rm[BP_SAVE]
0037F:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00380:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00381:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_69;		
00382:      	if ZR	jmp L5589D4CE_69
            ; //	sAX	= 1;				
00383:      	AX	= 0x01
            ; //L5589D4CE_69:;					
            L5589D4CE_69:
            ; //	sfx_CHECKZERO();			
00384:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_70;	
00385:      	if NZ	jmp L5589D4CE_70
            ; //	goto	L5589D4CE_68;			
00386:      	jmp	L5589D4CE_68
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //	
            ; //_A0432E234_209:;				
            _A0432E234_209:
            ; //	sAX	= 0;				
00387:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
00388:      	AR	= -3
00389:      	I1	= rm[BP_SAVE]
0038A:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0038B:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0038C:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_72;		
0038D:      	if ZR	jmp L5589D4CE_72
            ; //	sAX	= 1;				
0038E:      	AX	= 0x01
            ; //L5589D4CE_72:;					
            L5589D4CE_72:
            ; //	sfx_CHECKZERO();			
0038F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_73;	
00390:      	if NZ	jmp L5589D4CE_73
            ; //	goto	L5589D4CE_71;			
00391:      	jmp	L5589D4CE_71
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //	
            ; //_A0432E234_210:;				
            _A0432E234_210:
            ; //	sSI	= (int)&_pkey_1_10;		
00392:      	AR	= -4
00393:      	I1	= rm[BP_SAVE]
00394:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00395:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00396:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00397:      	AR	= CX
00398:      	AX	+= AR
            ; //	sDI	= sAX;				
00399:      	AR	= AX
0039A:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0039B:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0039C:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_75;	
0039D:      	if NZ	jmp L5589D4CE_75
            ; //	goto	L5589D4CE_74;			
0039E:      	jmp	L5589D4CE_74
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //_A0432E234_211:;				
            _A0432E234_211:
            ; //_A0432E234_212:;				
            _A0432E234_212:
            ; //	sSI	= (int)&_pkey_1_10;		
0039F:      	AR	= -4
003A0:      	I1	= rm[BP_SAVE]
003A1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003A2:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
003A3:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
003A4:      	AR	= CX
003A5:      	AX	+= AR
            ; //	sDI	= sAX;				
003A6:      	AR	= AX
003A7:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003A8:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
003A9:      	AR	= AX
003AA:      	P1	= AR
003AB:      	P1.hh	= 0
003AC:      	fcall	pm[P1]
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //_A0432E234_213:;				
            _A0432E234_213:
            ; //	goto L5589D4CE_76;			
003AD:      	jmp	L5589D4CE_76
            ; //L5589D4CE_71:;					
            L5589D4CE_71:
            ; //	
            ; //_A0432E234_214:;				
            _A0432E234_214:
            ; //	sSI	= (int)&_pkey_1_10;		
003AE:      	AR	= -4
003AF:      	I1	= rm[BP_SAVE]
003B0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003B1:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
003B2:      	AR	= AX
003B3:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003B4:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
003B5:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_78;	
003B6:      	if NZ	jmp L5589D4CE_78
            ; //	goto	L5589D4CE_77;			
003B7:      	jmp	L5589D4CE_77
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //_A0432E234_215:;				
            _A0432E234_215:
            ; //_A0432E234_216:;				
            _A0432E234_216:
            ; //	sSI	= (int)&_pkey_1_10;		
003B8:      	AR	= -4
003B9:      	I1	= rm[BP_SAVE]
003BA:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003BB:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
003BC:      	AR	= AX
003BD:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003BE:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
003BF:      	AR	= AX
003C0:      	P1	= AR
003C1:      	P1.hh	= 0
003C2:      	fcall	pm[P1]
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //_A0432E234_217:;				
            _A0432E234_217:
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //_A0432E234_218:;				
            _A0432E234_218:
            ; //	goto L5589D4CE_79;			
003C3:      	jmp	L5589D4CE_79
            ; //L5589D4CE_68:;					
            L5589D4CE_68:
            ; //	
            ; //_A0432E234_219:;				
            _A0432E234_219:
            ; //	sAX	= 0;				
003C4:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
003C5:      	AR	= -3
003C6:      	I1	= rm[BP_SAVE]
003C7:      	I1	+= AR
            ; //	asm AR = rm[I1];			
003C8:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
003C9:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_81;		
003CA:      	if ZR	jmp L5589D4CE_81
            ; //	sAX	= 1;				
003CB:      	AX	= 0x01
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	sfx_CHECKZERO();			
003CC:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_82;	
003CD:      	if NZ	jmp L5589D4CE_82
            ; //	goto	L5589D4CE_80;			
003CE:      	jmp	L5589D4CE_80
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //	
            ; //_A0432E234_220:;				
            _A0432E234_220:
            ; //	sSI	= (int)&_pkey_1_10;		
003CF:      	AR	= -4
003D0:      	I1	= rm[BP_SAVE]
003D1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003D2:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
003D3:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
003D4:      	AR	= CX
003D5:      	AX	+= AR
            ; //	sDI	= sAX;				
003D6:      	AR	= AX
003D7:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003D8:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
003D9:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_84;	
003DA:      	if NZ	jmp L5589D4CE_84
            ; //	goto	L5589D4CE_83;			
003DB:      	jmp	L5589D4CE_83
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //_A0432E234_221:;				
            _A0432E234_221:
            ; //_A0432E234_222:;				
            _A0432E234_222:
            ; //	sSI	= (int)&_pkey_1_10;		
003DC:      	AR	= -4
003DD:      	I1	= rm[BP_SAVE]
003DE:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003DF:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
003E0:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
003E1:      	AR	= CX
003E2:      	AX	+= AR
            ; //	sDI	= sAX;				
003E3:      	AR	= AX
003E4:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003E5:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
003E6:      	AR	= AX
003E7:      	P1	= AR
003E8:      	P1.hh	= 0
003E9:      	fcall	pm[P1]
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //_A0432E234_223:;				
            _A0432E234_223:
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //_A0432E234_224:;				
            _A0432E234_224:
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //_A0432E234_225:;				
            _A0432E234_225:
            ; //_A0432E234_226:;				
            _A0432E234_226:
            ; //	sSI	= (int)&_bits_1_6;		
003EA:      	AR	= -2
003EB:      	I1	= rm[BP_SAVE]
003EC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003ED:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003EE:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
003EF:      	AR	= -2
003F0:      	I1	= rm[BP_SAVE]
003F1:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003F2:      	rm[I1]	= AX
            ; //_A0432E234_227:;				
            _A0432E234_227:
            ; //	sSI	= (int)&_bitp_1_8;		
003F3:      	AR	= -3
003F4:      	I1	= rm[BP_SAVE]
003F5:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003F6:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003F7:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
003F8:      	AR	= -3
003F9:      	I1	= rm[BP_SAVE]
003FA:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003FB:      	rm[I1]	= AX
            ; //_A0432E234_228:;				
            _A0432E234_228:
            ; //	sSI	= (int)&_pkey_1_10;		
003FC:      	AR	= -4
003FD:      	I1	= rm[BP_SAVE]
003FE:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003FF:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
00400:      	AR	= -4
00401:      	I1	= rm[BP_SAVE]
00402:      	I1	+= AR
            ; //	asm AR = 0x0003;			
00403:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
00404:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
00405:      	rm[I1] = CX + AR//
            ; //_A0432E234_229:;				
            _A0432E234_229:
            ; //	goto L5589D4CE_66;			
00406:      	jmp	L5589D4CE_66
            ; //L5589D4CE_65:;					
            L5589D4CE_65:
            ; //L5589D4CE_60:;					
            L5589D4CE_60:
            ; //_A0432E234_230:;				
            _A0432E234_230:
            ; //	return;					
00407:      	AR	= 5
00408:      	BP	+= AR
00409:      	pop	AR
0040A:      	rm[BP_SAVE]	= AR
0040B:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_A0432E234_231:;				
            _A0432E234_231:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> Start=========================
            ; sub3play.c Code Start!!;
            VarRM[0:4095]={
             bts_ch0_get_ix[2],PCMYIN_PTR,PCMYOU_PTR,PCMIN,SampleCh0Rate,BaseOn512#PCMY[512],SUBFLTI[4],SUBFLTA
            ,SUBFLTP,SUBFLTG 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _ClearRenderBufB079D01D();
            ; //rjmp void _Sub3Initial96BE24F3();
            ; //rjmp void _Sub3Startup4CD35D6D();
            ; //rjmp void _Sub3ZeroFillABFF23AA();
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1);
            ; //rjmp void Sbb_Ch0GetBts();
            ; //rjmp void _Sbb_SkipdataE1C72441(__int16 _offset_0_4_0, __int16 _offset_0_4_1);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _ClearRenderBufB079D01D()		
            _ClearRenderBufB079D01D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
0040C:      	AR	= rm[BP_SAVE]
0040D:      	push	AR
0040E:      	AR	= BP
0040F:      	rm[BP_SAVE]	= AR
00410:      	AR	 = -1
00411:      	BP	+= AR
            ; //_A0432E234_232:;				
            _A0432E234_232:
            ; //	
            ; //_A0432E234_233:;				
            _A0432E234_233:
            ; //	asm AX = PCMY+0;			
00412:      	AX = PCMY+0//
            ; //_A0432E234_234:;				
            _A0432E234_234:
            ; //	asm	AR = AX				
00414:      	AR = AX
            ; //_A0432E234_235:;				
            _A0432E234_235:
            ; //	asm	I0 = AR				
00415:      	I0 = AR
            ; //	
            ; //	
            ; //_A0432E234_236:;				
            _A0432E234_236:
            ; //	_i_1_2+0	= 0x0200;		
00416:      	I1	= rm[BP_SAVE]
00417:      	AX	= 0x0200
00419:      	rm[I1]	= AX
            ; //LFB78B58C_88:;					
            LFB78B58C_88:
            ; //_A0432E234_237:;				
            _A0432E234_237:
            ; //	sSI	= (int)&_i_1_2;			
0041A:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0041B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0041C:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0041D:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0041E:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0041F:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00420:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_89;	
00421:      	if NZ	jmp LFB78B58C_89
            ; //	goto	LFB78B58C_87;			
00422:      	jmp	LFB78B58C_87
            ; //LFB78B58C_89:;					
            LFB78B58C_89:
            ; //	
            ; //_A0432E234_238:;				
            _A0432E234_238:
            ; //	sAX	= 0x0000;			
00423:      	AX	= 0x00
            ; //_A0432E234_239:;				
            _A0432E234_239:
            ; //	asm	rm[I0++] = AX			
00424:      	rm[I0++] = AX
            ; //_A0432E234_240:;				
            _A0432E234_240:
            ; //	goto LFB78B58C_88;			
00425:      	jmp	LFB78B58C_88
            ; //LFB78B58C_87:;					
            LFB78B58C_87:
            ; //LFB78B58C_86:;					
            LFB78B58C_86:
            ; //_A0432E234_241:;				
            _A0432E234_241:
            ; //	return;					
00426:      	AR	= 1
00427:      	BP	+= AR
00428:      	pop	AR
00429:      	rm[BP_SAVE]	= AR
0042A:      	rets
            ; //_ClearRenderBufB079D01D_end:;			
            _ClearRenderBufB079D01D_end:
            ; //_A0432E234_242:;				
            _A0432E234_242:
            ; //}
            ; //
            ; //rjmp void _Sub3Initial96BE24F3()		
            _Sub3Initial96BE24F3:
            ; //{
            ; //_A0432E234_243:;				
            _A0432E234_243:
            ; //	
            ; //_A0432E234_244:;				
            _A0432E234_244:
            ; //_A0432E234_245:;				
            _A0432E234_245:
            ; //	_ClearRenderBufB079D01D();		
0042B:      	pch	= _ClearRenderBufB079D01D
0042C:      	lcall	_ClearRenderBufB079D01D
            ; //_A0432E234_246:;				
            _A0432E234_246:
            ; //	asm AX = PCMY+0;			
0042D:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
0042F:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00430:      	rm[I1]	= AX
            ; //_A0432E234_247:;				
            _A0432E234_247:
            ; //	asm AX = PCMY+0;			
00431:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
00433:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00434:      	rm[I1]	= AX
            ; //LFB78B58C_90:;					
            LFB78B58C_90:
            ; //_A0432E234_248:;				
            _A0432E234_248:
            ; //	return;					
00435:      	rets
            ; //_Sub3Initial96BE24F3_end:;			
            _Sub3Initial96BE24F3_end:
            ; //_A0432E234_249:;				
            _A0432E234_249:
            ; //}
            ; //
            ; //rjmp void _Sub3Startup4CD35D6D()		
            _Sub3Startup4CD35D6D:
            ; //{
            ; //_A0432E234_250:;				
            _A0432E234_250:
            ; //_A0432E234_251:;				
            _A0432E234_251:
            ; //	asm	dsi				
00436:      	dsi
            ; //_A0432E234_252:;				
            _A0432E234_252:
            ; //	asm	nop				
00437:      	nop
            ; //	
            ; //	
            ; //_A0432E234_253:;				
            _A0432E234_253:
            ; //_A0432E234_254:;				
            _A0432E234_254:
            ; //	_ClearRenderBufB079D01D();		
00438:      	pch	= _ClearRenderBufB079D01D
00439:      	lcall	_ClearRenderBufB079D01D
            ; //_A0432E234_255:;				
            _A0432E234_255:
            ; //	asm	AR = PASR,0			
0043A:      	AR = PASR,0
            ; //_A0432E234_256:;				
            _A0432E234_256:
            ; //	asm AX = PCMY+0;			
0043B:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
0043D:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
0043E:      	rm[I1]	= AX
            ; //_A0432E234_257:;				
            _A0432E234_257:
            ; //	asm AX = PCMY+0;			
0043F:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
00441:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00442:      	rm[I1]	= AX
            ; //_A0432E234_258:;				
            _A0432E234_258:
            ; //	io[0x3B]	= 0x0000;		
00443:      	AR	= 0x00
00444:      	io[0x3B]	= AR
            ; //_A0432E234_259:;				
            _A0432E234_259:
            ; //_A0432E234_260:;				
            _A0432E234_260:
            ; //	Subb3_Init();				
00445:      	pch	= Subb3_Init
00446:      	lcall	Subb3_Init
            ; //LFB78B58C_91:;					
            LFB78B58C_91:
            ; //_A0432E234_261:;				
            _A0432E234_261:
            ; //	return;					
00447:      	rets
            ; //_Sub3Startup4CD35D6D_end:;			
            _Sub3Startup4CD35D6D_end:
            ; //_A0432E234_262:;				
            _A0432E234_262:
            ; //}
            ; //
            ; //rjmp void _Sub3ZeroFillABFF23AA()		
            _Sub3ZeroFillABFF23AA:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00448:      	AR	= rm[BP_SAVE]
00449:      	push	AR
0044A:      	AR	= BP
0044B:      	rm[BP_SAVE]	= AR
0044C:      	AR	 = -1
0044D:      	BP	+= AR
            ; //_A0432E234_263:;				
            _A0432E234_263:
            ; //_A0432E234_264:;				
            _A0432E234_264:
            ; //	asm	push CBL			
0044E:      	push CBL
            ; //	
            ; //_A0432E234_265:;				
            _A0432E234_265:
            ; //	io[0x3B]	= 0x0009;		
0044F:      	AR	= 0x09
00450:      	io[0x3B]	= AR
            ; //	
            ; //_A0432E234_266:;				
            _A0432E234_266:
            ; //	asm I1 = PCMYIN_PTR+0;			
00451:      	I1 = PCMYIN_PTR+0//
            ; //	sAX	= *(__int16*)sSI;		
00452:      	AX	= rm[I1]
            ; //_A0432E234_267:;				
            _A0432E234_267:
            ; //	asm	AR = AX				
00453:      	AR = AX
            ; //_A0432E234_268:;				
            _A0432E234_268:
            ; //	asm	I0 = AR				
00454:      	I0 = AR
            ; //	
            ; //_A0432E234_269:;				
            _A0432E234_269:
            ; //	_i_1_2+0	= 0x0120;		
00455:      	I1	= rm[BP_SAVE]
00456:      	AX	= 0x0120
00458:      	rm[I1]	= AX
            ; //LFB78B58C_94:;					
            LFB78B58C_94:
            ; //_A0432E234_270:;				
            _A0432E234_270:
            ; //	sSI	= (int)&_i_1_2;			
00459:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0045A:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0045B:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0045C:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0045D:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0045E:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0045F:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_95;	
00460:      	if NZ	jmp LFB78B58C_95
            ; //	goto	LFB78B58C_93;			
00461:      	jmp	LFB78B58C_93
            ; //LFB78B58C_95:;					
            LFB78B58C_95:
            ; //	
            ; //_A0432E234_271:;				
            _A0432E234_271:
            ; //	sAX	= 0x0000;			
00462:      	AX	= 0x00
            ; //_A0432E234_272:;				
            _A0432E234_272:
            ; //	asm	rm[I0++] = AX			
00463:      	rm[I0++] = AX
            ; //_A0432E234_273:;				
            _A0432E234_273:
            ; //	goto LFB78B58C_94;			
00464:      	jmp	LFB78B58C_94
            ; //LFB78B58C_93:;					
            LFB78B58C_93:
            ; //_A0432E234_274:;				
            _A0432E234_274:
            ; //_A0432E234_275:;				
            _A0432E234_275:
            ; //	get_I0();				
00465:      	push	I0
00466:      	pop	AX
            ; //	asm I1 = PCMYIN_PTR+0;			
00467:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00468:      	rm[I1]	= AX
            ; //_A0432E234_276:;				
            _A0432E234_276:
            ; //	asm	pop CBL				
00469:      	pop CBL
            ; //LFB78B58C_92:;					
            LFB78B58C_92:
            ; //_A0432E234_277:;				
            _A0432E234_277:
            ; //	return;					
0046A:      	AR	= 1
0046B:      	BP	+= AR
0046C:      	pop	AR
0046D:      	rm[BP_SAVE]	= AR
0046E:      	rets
            ; //_Sub3ZeroFillABFF23AA_end:;			
            _Sub3ZeroFillABFF23AA_end:
            ; //_A0432E234_278:;				
            _A0432E234_278:
            ; //}
            ; //
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1)
            _Sub3Play422CAD6D:
            ; //{						
0046F:      	AR	= rm[BP_SAVE]
00470:      	push	AR
00471:      	AR	= BP
00472:      	rm[BP_SAVE]	= AR
            ; //_A0432E234_279:;				
            _A0432E234_279:
            ; //	
            ; //_A0432E234_280:;				
            _A0432E234_280:
            ; //	sSI	= (int)&_sdata_0_4_0;		
00473:      	AR	= 2
00474:      	I1	= rm[BP_SAVE]
00475:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI++;		
00476:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00477:      	DX	= rm[I1--]
            ; //	asm I1 = bts_ch0_get_ix+0;		
00478:      	I1 = bts_ch0_get_ix+0//
            ; //	sfx_STORSILONG();			
00479:      	rm[I1++]	= AX
0047A:      	rm[I1--]	= DX
            ; //_A0432E234_281:;				
            _A0432E234_281:
            ; //_A0432E234_282:;				
            _A0432E234_282:
            ; //	_Sub3Startup4CD35D6D();			
0047B:      	pch	= _Sub3Startup4CD35D6D
0047C:      	lcall	_Sub3Startup4CD35D6D
            ; //_A0432E234_283:;				
            _A0432E234_283:
            ; //	asm AX = SUBFLTI+0;			
0047D:      	AX = SUBFLTI+0//
            ; //	PUSH(sAX);				
0047E:      	push	AX
            ; //	sAX	= 0x0000;			
0047F:      	AX	= 0x00
            ; //	sSI	= POP();			
00480:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00481:      	rm[I1]	= AX
            ; //_A0432E234_284:;				
            _A0432E234_284:
            ; //	asm AX = SUBFLTI+1;			
00482:      	AX = SUBFLTI+1//
            ; //	PUSH(sAX);				
00483:      	push	AX
            ; //	sAX	= 0x0000;			
00484:      	AX	= 0x00
            ; //	sSI	= POP();			
00485:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00486:      	rm[I1]	= AX
            ; //_A0432E234_285:;				
            _A0432E234_285:
            ; //	asm AX = SUBFLTI+2;			
00487:      	AX = SUBFLTI+2//
            ; //	PUSH(sAX);				
00488:      	push	AX
            ; //	sAX	= 0x0000;			
00489:      	AX	= 0x00
            ; //	sSI	= POP();			
0048A:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0048B:      	rm[I1]	= AX
            ; //_A0432E234_286:;				
            _A0432E234_286:
            ; //	asm AX = SUBFLTI+3;			
0048C:      	AX = SUBFLTI+3//
            ; //	PUSH(sAX);				
0048D:      	push	AX
            ; //	sAX	= 0x0000;			
0048E:      	AX	= 0x00
            ; //	sSI	= POP();			
0048F:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00490:      	rm[I1]	= AX
            ; //_A0432E234_287:;				
            _A0432E234_287:
            ; //	sAX	= 0x0000;			
00491:      	AX	= 0x00
            ; //	asm I1 = SUBFLTA+0;			
00492:      	I1 = SUBFLTA+0//
            ; //	*(__int16*)sSI	= sAX			
00493:      	rm[I1]	= AX
            ; //_A0432E234_288:;				
            _A0432E234_288:
            ; //	asm I1 = SampleCh0Rate+0;		
00494:      	I1 = SampleCh0Rate+0//
            ; //	sAX	= *(__int16*)sSI;		
00495:      	AX	= rm[I1]
            ; //	asm I1 = SUBFLTP+0;			
00496:      	I1 = SUBFLTP+0//
            ; //	*(__int16*)sSI	= sAX			
00497:      	rm[I1]	= AX
            ; //_A0432E234_289:;				
            _A0432E234_289:
            ; //	sAX	= 0x003F;			
00498:      	AX	= 0x3F
            ; //	asm I1 = SUBFLTG+0;			
00499:      	I1 = SUBFLTG+0//
            ; //	*(__int16*)sSI	= sAX			
0049A:      	rm[I1]	= AX
            ; //_A0432E234_290:;				
            _A0432E234_290:
            ; //	asm	set io[INTENA].b0		
0049B:      	set io[INTENA].b0
            ; //_A0432E234_291:;				
            _A0432E234_291:
            ; //	asm	eni				
0049C:      	eni
            ; //LFB78B58C_96:;					
            LFB78B58C_96:
            ; //_A0432E234_292:;				
            _A0432E234_292:
            ; //	return;					
0049D:      	pop	AR
0049E:      	rm[BP_SAVE]	= AR
0049F:      	rets
            ; //_Sub3Play422CAD6D_end:;				
            _Sub3Play422CAD6D_end:
            ; //_A0432E234_293:;				
            _A0432E234_293:
            ; //}
            ; //
            ; //rjmp void Sbb_Ch0GetBts()			
            Sbb_Ch0GetBts:
            ; //{
            ; //_A0432E234_294:;				
            _A0432E234_294:
            ; //_A0432E234_295:;				
            _A0432E234_295:
            ; //	asm	push I1				
004A0:      	push I1
            ; //_A0432E234_296:;				
            _A0432E234_296:
            ; //	asm	push P1				
004A1:      	push P1
            ; //_A0432E234_297:;				
            _A0432E234_297:
            ; //	asm	push AX				
004A2:      	push AX
            ; //_A0432E234_298:;				
            _A0432E234_298:
            ; //	asm	push BX				
004A3:      	push BX
            ; //_A0432E234_299:;				
            _A0432E234_299:
            ; //	asm	push CX				
004A4:      	push CX
            ; //_A0432E234_300:;				
            _A0432E234_300:
            ; //	asm	push DX				
004A5:      	push DX
            ; //_A0432E234_301:;				
            _A0432E234_301:
            ; //	asm	AR = P1.hh			
004A6:      	AR = P1.hh
            ; //_A0432E234_302:;				
            _A0432E234_302:
            ; //	asm	push AR				
004A7:      	push AR
            ; //	
            ; //_A0432E234_303:;				
            _A0432E234_303:
            ; //_A0432E234_304:;				
            _A0432E234_304:
            ; //_A0432E234_305:;				
            _A0432E234_305:
            ; //	asm I1 = bts_ch0_get_ix+0;		
004A8:      	I1 = bts_ch0_get_ix+0//
            ; //	sAX	= *(__int16*)sSI++;		
004A9:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
004AA:      	DX	= rm[I1--]
            ; //	sSI	= (int)&bts_ch0_get_ix[0];	
004AB:      	I1	= bts_ch0_get_ix
            ; //	PUSH(sAX);				
004AC:      	push	AX
            ; //	PUSH(sDX);				
004AD:      	push	DX
            ; //	sfx_GETSILONG_BXCX();			
004AE:      	CX	= rm[I1++]
004AF:      	BX	= rm[I1--]
            ; //	sAX = 0x0001;				
004B0:      	AX	= 0x01
            ; //	sDX = 0x0000;				
004B1:      	DX	= 0x00
            ; //	sfx_ADDLONG_BXCX_DXAX();		
004B2:      	AR	= AX
004B3:      	CX	= CX + AR
004B4:      	AR	= DX
004B5:      	BX	= BX + AR + C
            ; //	sfx_STORSILONG_BXCX();			
004B6:      	rm[I1++]	= CX
004B7:      	rm[I1--]	= BX
            ; //	sDX	= POP();			
004B8:      	pop	DX
            ; //	sAX	= POP();			
004B9:      	pop	AX
            ; //	PUSH(sDX);				
004BA:      	push	DX
            ; //	PUSH(sAX);				
004BB:      	push	AX
            ; //	_lptr_read(STACK[sSP + 0], STACK[sSP + 1]);
004BC:      	pch	= _lptr_read
004BD:      	lcall	_lptr_read
            ; //	RESTORESP(2);				
004BE:      	pop	AR
004BF:      	pop	AR
            ; //	PUSH(sAX);				
004C0:      	push	AX
            ; //	vXCHG(STACK[sSP + 0]);			
004C1:      	AR	= AX
004C2:      	AX	= xchg AR
            ; //	RESTORESP(1);				
004C3:      	pop	AR
            ; //_A0432E234_306:;				
            _A0432E234_306:
            ; //	asm	pop AR				
004C4:      	pop AR
            ; //_A0432E234_307:;				
            _A0432E234_307:
            ; //	asm	P1.hh = AR			
004C5:      	P1.hh = AR
            ; //_A0432E234_308:;				
            _A0432E234_308:
            ; //	asm	pop DX				
004C6:      	pop DX
            ; //_A0432E234_309:;				
            _A0432E234_309:
            ; //	asm	pop CX				
004C7:      	pop CX
            ; //_A0432E234_310:;				
            _A0432E234_310:
            ; //	asm	pop BX				
004C8:      	pop BX
            ; //	
            ; //_A0432E234_311:;				
            _A0432E234_311:
            ; //_A0432E234_312:;				
            _A0432E234_312:
            ; //	asintax();				
            ; //_A0432E234_313:;				
            _A0432E234_313:
            ; //	asm	AR = AX				
004C9:      	AR = AX
            ; //_A0432E234_314:;				
            _A0432E234_314:
            ; //	asm	pop AX				
004CA:      	pop AX
            ; //_A0432E234_315:;				
            _A0432E234_315:
            ; //	asm	pop P1				
004CB:      	pop P1
            ; //_A0432E234_316:;				
            _A0432E234_316:
            ; //	asm	pop I1				
004CC:      	pop I1
            ; //LFB78B58C_97:;					
            LFB78B58C_97:
            ; //_A0432E234_317:;				
            _A0432E234_317:
            ; //	return;					
004CD:      	rets
            ; //Sbb_Ch0GetBts_end:;				
            Sbb_Ch0GetBts_end:
            ; //_A0432E234_318:;				
            _A0432E234_318:
            ; //}
            ; //
            ; //rjmp void _Sbb_SkipdataE1C72441(__int16 _offset_0_4_0, __int16 _offset_0_4_1)
            _Sbb_SkipdataE1C72441:
            ; //{
            ; //						
004CE:      	AR	= rm[BP_SAVE]
004CF:      	push	AR
004D0:      	AR	= BP
004D1:      	rm[BP_SAVE]	= AR
            ; //LFB78B58C_98:;					
            LFB78B58C_98:
            ; //_A0432E234_319:;				
            _A0432E234_319:
            ; //	return;					
004D2:      	pop	AR
004D3:      	rm[BP_SAVE]	= AR
004D4:      	rets
            ; //_Sbb_SkipdataE1C72441_end:;			
            _Sbb_SkipdataE1C72441_end:
            ; //_A0432E234_320:;				
            _A0432E234_320:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> End=========================
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> Start=========================
            
            ; ~.~------------------------------------------
            ; void PWM_ENTRY(void) interrupt 0
            ; ---------------------------------------------
            PWM_ENTRY:
            ; {
004D5:      	clr 		io[INTREQ].b0	; Clear Int0 Request!!
004D6:      	set		io[PortCI].b0
004D7:      	push		AX
004D8:      	push		BX
004D9:      	push		CX
004DA:      	push		DX
004DB:      	push		R0
004DC:      	push		R1
004DD:      	push		R2
004DE:      	push		R3
004DF:      	push		I0
004E0:      	push		I1
004E1:      	push		P1
004E2:      	AR=		P1.hh
004E3:      	push		AR
004E4:      	push		P0
004E5:      	AR=		P0.hh
004E6:      	push		AR
004E7:      	push		MX
004E8:      	push		MR0
004E9:      	push		MR1
004EA:      	push		MR2
004EB:      	push		CBL
            #ifdef _MSPEECHDSP_
            
            #else
004EC:      	push		MACOP
004ED:      	MACOP=		0
            #endif
            
004EE:      	CBL=		0
            
004EF:      	I1=		ADPCMY
004F0:      	io[DACL]=	rm[I1++2]
004F1:      	io[DACL]=	rm[I1++2]
004F2:      	io[DACL]=	rm[I1++2]
004F3:      	io[DACL]=	rm[I1++2]
            
004F4:      	PCH=		DoADPCM
004F5:      	lcall		DoADPCM
            	
            	; -=-=-=-=-=-=-=-=-=-
            	; dtx + subband3 sound mix
            
004F6:      	I1=		SUBFLTI
004F7:      	FLTI=		rm[I1++]
004F8:      	FLTI=		rm[I1++]
004F9:      	FLTI=		rm[I1++]
004FA:      	FLTI=		rm[I1++]
004FB:      	FLTA=		rm[I1++]
004FC:      	FLTP=		rm[I1++]
004FD:      	FLTG=		rm[I1]
004FE:      	AR=		FLTO
            
004FF:      	MX=		1
00500:      	CBL=		9
            
00501:      	I1=		ADPCMY
00502:      	I0=		rm[PCMYOU_PTR]
00503:      	CX=		3
            @pwm_loop_1340:
00504:      	if FA jmp	@pwm_label_1340
            
00505:      	AR=		rm[I0++]
00506:      	FLTI=		AR
            @pwm_label_1340:
00507:      	AR=		FLTO
            
            #ifdef _MSPEECHDSP_	
            	MULSS
            #else
00508:      	MR=		MX * AR
            #endif
            	; ~~ can not use SATV because subband3 use it already
00509:      	AX=		rm[I1++]
0050A:      	AR=		MR0
0050B:      	AX=		AX + AR
0050C:      	AR=		rm[I1--]
0050D:      	AR=		AR + MR1 + C
0050E:      	if AN jmp	@pwm_label_1021
0050F:      	SF=		AR - 0
00510:      	if NE jmp	@pwm_label_1149
00511:      	test		AX.b15
00512:      	if ZR jmp	@pwm_label_1022
            @pwm_label_1149:
00513:      	AX=		0x7FFF
00515:      	jmp		@pwm_label_1022
            @pwm_label_1021:
00516:      	SF=		AR - 0xFF
00517:      	if NE jmp	@pwm_label_1149_1
00518:      	test		AX.b15
00519:      	if NZ jmp	@pwm_label_1022
            @pwm_label_1149_1:
0051A:      	AX=		0x8001
            @pwm_label_1022:
0051C:      	rm[I1++2]=	AX
0051D:      	loop		@pwm_loop_1340
            
0051E:      	I1=		SUBFLTI
0051F:      	rm[I1++]=	FLTI
00520:      	rm[I1++]=	FLTI
00521:      	rm[I1++]=	FLTI
00522:      	rm[I1++]=	FLTI
00523:      	rm[I1++]=	FLTA
            
00524:      	rm[PCMYOU_PTR]=	I0
            
            	; -=-=-=-=-=-=-=-=-=-
            
            
            #ifdef _MSPEECHDSP_
            
            #else
00525:      	pop		MACOP
            #endif
00526:      	pop		CBL
00527:      	pop		MR2
00528:      	pop		MR1
00529:      	pop		MR0
0052A:      	pop		MX
0052B:      	pop		AR
0052C:      	P0.hh=		AR
0052D:      	pop		P0
0052E:      	pop		AR
0052F:      	P1.hh=		AR
00530:      	pop		P1
00531:      	pop		I1
00532:      	pop		I0
00533:      	pop		R3
00534:      	pop		R2
00535:      	pop		R1
00536:      	pop		R0
00537:      	pop		DX
00538:      	pop		CX
00539:      	pop		BX
0053A:      	pop		AX
0053B:      	clr		io[PortCI].b0
0053C:      	reti
            
            PWM_ENTRY_END:	
            ; }
            
            
            
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> End=========================
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> Start=========================
            
            
            ; ~~ assembly function in C form...
            
            ; ---------------------------------------------
            
            ; --------------------------------------------------------------
            
            ; -----------------------------------------------------------------
            
            
            
            #define ADPDEC_BUFFER_COUNT	4
            
            
            ///////////////////////////////////////////////////////////////////////////////////////////////
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; --------------------------
            
            ClearAudioBuffer:
            ; {
0053D:      	CX=		ADPDEC_BUFFER_COUNT
0053E:      	I1=		ADPCMY
0053F:      	AR=		0
            @clrbuf_loop_1659:
00540:      	rm[I1++]=	AR
00541:      	rm[I1++]=	AR
00542:      	loop		@clrbuf_loop_1659
            
00543:      	rets
            ; }
            
            
            ; ------------------------------------------------
            
            
            ; ADPCM structure
            
            ; typedef struct _ADPSTRU {
            	; int PCMData;
            	; int ADPDEC[9];
            	; lptr_t adpptr;
            	; int FLTI[4];
            	; int FLTA;
            	; int FLTP;
            ; }ADPSTRU;
            
            
            ; ------------------------------------------------
            
            ADPCM_ChxGetBts:
            ; {
00544:      	push		I1
00545:      	push		AX
00546:      	push		P1
00547:      	AR=		P1.hh
00548:      	push		AR
            
            	; LoadAR(_lptr_read(ADPCM_Tmpi->adpptr++));
00549:      		I1=		rm[ADPCM_Tmpi]
0054A:      		AR=		10
0054B:      		I1=		I1 + AR
0054C:      		P1=		rm[I1++]	; low
0054D:      		AR=		rm[I1]		; high
0054E:      		P1.hh=		AR
            
0054F:      		AX=		pm[P1++]
            
00550:      		AR=		P1.hh		; high
00551:      		set		AR.b11
00552:      		rm[I1--]=	AR
00553:      		rm[I1]=		P1		; low
            
00554:      	pop		AR
00555:      	P1.hh=		AR
00556:      	pop		P1
00557:      	AR=		AX
00558:      	pop		AX
00559:      	pop		I1
0055A:      	rets
            ; }
            
            
            ; --------------------------------------------------
            
            ADPDEC_PRAM_START:
            
            #ifdef ADPCM_USE_PRAM
            __DecodeChannel:
            #else
            DecodeChannel:
            #endif
            ; {
            	; if(ADPCM_Tmpi->adpptr)
0055B:      		I1=		rm[ADPCM_Tmpi]
0055C:      		AR=		10
0055D:      		I1=		I1 + AR
0055E:      		AR=		rm[I1++]
0055F:      		AX=		rm[I1]
00560:      		AR=		AR | AX
00561:      		if ZR jmp	@decodech_label_1654
            	; {
            		; BackupFilter();
            		
            		#ifdef _MSPEECHDSP_
            		
            		#else
00562:      			MACOP=		0
            		#endif
00563:      			I1=		rm[ADPCM_Tmpi]
00564:      			AR=		12
00565:      			I1=		I1 + AR
00566:      			FLTI=		rm[I1++]
00567:      			FLTI=		rm[I1++]
00568:      			FLTI=		rm[I1++]
00569:      			FLTI=		rm[I1++]
0056A:      			FLTA=		rm[I1++]
0056B:      			FLTP=		rm[I1]
0056C:      			AR=		0x3F
0056D:      			FLTG=		AR
0056E:      			AR=		FLTO
            
            		; set_I0(PCMYIN_PTR);
0056F:      			I0=		ADPCMY
            
            		; for(i = 0; i < 32; i++)
00570:      			CX=		ADPDEC_BUFFER_COUNT - 1
            		@decodech_loop_1408:
            		; {
            			; if(!FA())
00571:      				if FA jmp	@decodech_label_1408
            			; {
            				; if(ADPCM_decoder())
00572:      					push		CX
00573:      					push		I0
00574:      					PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
00575:      					lcall           SDSP_ADPCM_4Bit_SingleCH_decoder
00576:      					AX=		0
00577:      					if NZ jmp	@decodech_label_1614
00578:      					AX=		1
            				@decodech_label_1614:
00579:      					pop		I0
0057A:      					pop		CX
0057B:      					AR=		AX
0057C:      					if ZR jmp	@decodech_label_1658
            				; {
            					; ADPCM_Tmpi->adpptr = 0;
0057D:      						I1=		rm[ADPCM_Tmpi]
0057E:      						AR=		10
0057F:      						I1=		I1 + AR
00580:      						AR=		0
00581:      						rm[I1++]=	AR
00582:      						rm[I1++]=	AR
            
            					; return;
00583:      						P1.hh=		0
00584:      						rets
            				; }
            				@decodech_label_1658:
            
            				; FLTI = ADPCM_Tmpi->PCMData;
00585:      					I1=		rm[ADPCM_Tmpi]
00586:      					AR=		rm[I1]
00587:      					FLTI=		AR
            			; }
            			@decodech_label_1408:
            
            
            			; MixToBuf();
00588:      				MX=		1
00589:      				AR=		FLTO
            			#ifdef _MSPEECHDSP_
            				MULSS
            			#else
0058A:      				MR=		MX * AR
            			#endif
0058B:      				AX=		rm[I0]
0058C:      				AR=		MR0
0058D:      				rm[I0++]=	AR + AX
0058E:      				AX=		rm[I0]
0058F:      				AR=		MR1
00590:      				rm[I0++]=	AR + AX + C
00591:      			loop		@decodech_loop_1408
            		; }
            
            		; BackupFilter();
00592:      			I1=		rm[ADPCM_Tmpi]
00593:      			AR=		12
00594:      			I1=		I1 + AR
00595:      			rm[I1++]=	FLTI
00596:      			rm[I1++]=	FLTI
00597:      			rm[I1++]=	FLTI
00598:      			rm[I1++]=	FLTI
00599:      			rm[I1++]=	FLTA
            
            	; }
            	@decodech_label_1654:
            
0059A:      	P1.hh=		0
0059B:      	rets
            ; }
            
            __DecodeChannel_end:
            
            ; --------------------------------------------------
            ; --------------------------------------------------
            
            ADPDEC_PRAM_START_END:
            
            ; ---------------------------------------------------
            
            
            #ifdef ADPCM_USE_PRAM
            
            DecodeChannel:
            
            #ifdef PRAM_BANK
            		P1=		#__DecodeChannel
            		AX=		#__DecodeChannel_end
            		PCH=		sfx_DynFindPRG
            		lcall		sfx_DynFindPRG
            		if NZ jmp	@decoch_label_1431
            		
            		fjmp		pm[P0]
            	@decoch_label_1431:
            		PCH=		sfx_DynBooking
            		lcall		sfx_DynBooking
            		if ZR jmp	@decoch_label_1432
            
            		P0.hh=		0
            		jmp		__DecodeChannel
            	@decoch_label_1432:
            		PCH=		sfx_DynCache
            		lcall		sfx_DynCache
            		fjmp		pm[P0]
            #else
            	jmp		__DecodeChannel
            #endif
            
            
            #endif
            
            ; ----------------------------------------------------
            
            
            ; ---------------------------------------------------
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> End=========================
            
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> Start=========================
            ; linkfile.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void ADPCM_CH0_Data();
            ; //naked void ADPCM_CH1_Data();
            ; //naked void ADPCM_CH2_Data();
            ; //naked void ADPCM_CH3_Data();
            ; //naked void ADPCM_CH4_Data();
            ; //naked void ADPCM_CH5_Data();
            ; //naked void subb0();
            ; //naked void subb1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _adpdata32993E3B[28] = {		
            _adpdata32993E3B:
            ; //	(int)&ADPCM_CH0_Data, (int)&ADPCM_CH0_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH1_Data, (int)&ADPCM_CH1_Data.h|0x0800, 0x3FFF, 0x003F, 
0059C:      DW #ADPCM_CH0_Data,#ADPCM_CH0_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH1_Data,#ADPCM_CH1_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH2_Data, (int)&ADPCM_CH2_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH3_Data, (int)&ADPCM_CH3_Data.h|0x0800, 0x3FFF, 0x003F, 
005A4:      DW #ADPCM_CH2_Data,#ADPCM_CH2_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH3_Data,#ADPCM_CH3_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH4_Data, (int)&ADPCM_CH4_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH5_Data, (int)&ADPCM_CH5_Data.h|0x0800, 0x3FFF, 0x003F, 
005AC:      DW #ADPCM_CH4_Data,#ADPCM_CH4_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH5_Data,#ADPCM_CH5_Data.h|0x0800,0x3FFF,0x003F,
            ; //	0x0000, 0x0000, 0x0000, 0x0000		
005B4:      DW 0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void ADPCM_CH0_Data()			
            ADPCM_CH0_Data:
            ; //{
            ; //	asm	DW "adpcm\bird_8000_4-12.xam"	
03365:      DW "adpcm\bird_8000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH1_Data()			
            ADPCM_CH1_Data:
            ; //{
            ; //	asm	DW "adpcm\horse_16000_4-12.xam"	
056A9:      DW "adpcm\horse_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH2_Data()			
            ADPCM_CH2_Data:
            ; //{
            ; //	asm	DW "adpcm\2cat_16000_4-12.xam"	
06E7B:      DW "adpcm\2cat_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH3_Data()			
            ADPCM_CH3_Data:
            ; //{
            ; //	asm	DW "adpcm\cat_16000_4-12.xam"	
076C0:      DW "adpcm\cat_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH4_Data()			
            ADPCM_CH4_Data:
            ; //{
            ; //	asm	DW "adpcm\Dog_Barking_002_16000_4-12.xam"
089FA:      DW "adpcm\Dog_Barking_002_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH5_Data()			
            ADPCM_CH5_Data:
            ; //{
            ; //	asm	DW "adpcm\duck_A1S_16000_4-12.xam"
093C1:      DW "adpcm\duck_A1S_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void subb0()				
            subb0:
            ; //{
            ; //	asm	DW "subband3\03_kid1_12K@15Kbps.t3z"
096BF:      DW "subband3\03_kid1_12K@15Kbps.t3z"
            ; //}
            ; //
            ; //naked void subb1()				
            subb1:
            ; //{
            ; //	asm	DW "subband3\06_Story_12K1@27K8bps.t3z"
0D88A:      DW "subband3\06_Story_12K1@27K8bps.t3z"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
005B8:      	AR=		BP
005B9:      	AR=		AR + 1		; ~~ value
005BA:      	I1=		AR
005BB:      	AR=		SATV
005BC:      	AR=		rm[I1++]
005BD:      	SATV=		AR
005BE:      	AR=		rm[I1++]
005BF:      	SATV=		AR
005C0:      	AR=		SATV
005C1:      	AX=		AR
005C2:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
005C3:      	AR=		BP
005C4:      	AR=		AR + 1		; ~~ value
005C5:      	I1=		AR
005C6:      	ADPHD=		rm[I1]
005C7:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
005C8:      	AR=		ADPHD
005C9:      	AX=		AR
005CA:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
005CB:      	AR=		BP
005CC:      	AR=		AR + 1		; ~~ value
005CD:      	I1=		AR
005CE:      	ADPDAT=		rm[I1]
005CF:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
005D0:      	AR=		ADPDAT
005D1:      	AX=		AR
005D2:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
005D3:      	AR=		ADPPCM
005D4:      	AX=		AR
005D5:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
005D6:      	AR=		CBL
005D7:      	AX=		AR
005D8:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
005D9:      	AR=		FLTO
005DA:      	AX=		AR
005DB:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
005DC:      	AR=		FLTA
005DD:      	AX=		AR
005DE:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
005DF:      	AR=		FLTP
005E0:      	AX=		AR
005E1:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
005E2:      	set		io[STATUS].b5
005E3:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
005E4:      	clr		io[STATUS].b5
005E5:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
005E6:      	set		io[STATUS].b8
005E7:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
005E8:      	clr		io[STATUS].b8
005E9:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
005EA:      	set		io[STATUS].b9
005EB:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
005EC:      	clr		io[STATUS].b9
005ED:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
005EE:      	set		io[STATUS].b11
005EF:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
005F0:      	clr		io[STATUS].b11
005F1:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
005F2:      	set		io[STATUS].b12
005F3:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
005F4:      	clr		io[STATUS].b12
005F5:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
005F6:      	set		io[STATUS].b13
005F7:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
005F8:      	clr		io[STATUS].b13
005F9:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
005FA:      	AR=		BP
005FB:      	AR=		AR + 1		; ~~ value
005FC:      	I1=		AR
005FD:      	AR=		rm[I1]
005FE:      	io[INTENA]=	AR
005FF:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
00600:      	AR=		io[INTENA]
00601:      	AX=		AR
00602:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
00603:      	AR=		BP
00604:      	AR=		AR + 1		; ~~ value
00605:      	I1=		AR
00606:      	AR=		rm[I1]
00607:      	io[INTREQ]	=AR
00608:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
00609:      	AR=		io[INTREQ]
0060A:      	AX=		AR
0060B:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
0060C:      	AR=		BP
0060D:      	AR=		AR + 1		; ~~ value
0060E:      	I1=		AR
0060F:      	AR=		rm[I1]
00610:      	io[IntVect]	=AR
00611:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
00612:      	AR=		io[IntVect]
00613:      	AX=		AR
00614:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
00615:      	AR=		io[IOC_PA]
00616:      	AX=		AR
00617:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
00618:      	AR=		io[IOC_PB]
00619:      	AX=		AR
0061A:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
0061B:      	AR=		io[IOC_PC]
0061C:      	AX=		AR
0061D:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
0061E:      	AR=		io[PortA]
0061F:      	AX=		AR
00620:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
00621:      	AR=		io[PortB]
00622:      	AX=		AR
00623:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
00624:      	AR=		io[PortC]
00625:      	AX=		AR
00626:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
00627:      	AR=		BP
00628:      	AR=		AR + 1		; ~~ value
00629:      	I1=		AR
0062A:      	AR=		rm[I1]
0062B:      	io[SPI_CTL]=	AR
0062C:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
0062D:      	AR=		io[SPI_CTL]
0062E:      	AX=		AR
0062F:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
00630:      	AR=		BP
00631:      	AR=		AR + 1		; ~~ value
00632:      	I1=		AR
00633:      	AR=		rm[I1]
00634:      	io[SPI_DAT]=	AR
00635:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
00636:      	AR=		io[SPI_DAT]
00637:      	AX=		AR
00638:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
00639:      	AR=		BP
0063A:      	AR=		AR + 1		; ~~ value
0063B:      	I1=		AR
0063C:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
0063D:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
0063E:      	AR=		io[MISC]
0063F:      	AX=		AR
00640:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
00641:      	AX=		AR
00642:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
00643:      	AR=		MACOP
00644:      	AX=		AR
00645:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
00646:      	AR=		BP
00647:      	AR=		AR + 1
00648:      	I1=		AR
00649:      	AR=		rm[I1]
0064A:      	xchg		AR
0064B:      	AX=		AR
0064C:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
0064D:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
0064E:      	AX=		rm[I0]
0064F:      	rets
            
            read_I0P:
00650:      	AX=		rm[I0++]
00651:      	rets
            
            read_I0P2:
00652:      	AX=		rm[I0++2]
00653:      	rets
            
            read_I0M:
00654:      	AX=		rm[I0--]
00655:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
00656:      	AR=		I0
00657:      	AX=		AR
00658:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
00659:      	AX=		pm[P0]
0065A:      	rets
            
            read_P0P:
0065B:      	AX=		pm[P0++]
0065C:      	rets
            
            read_P0M:
0065D:      	AX=		pm[P0--]
0065E:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
0065F:      	AR=		P0
00660:      	AX=		AR
00661:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
00662:      	AX=		1
00663:      	if FA jmp	@fa_label_1504
00664:      	AX=		0
            @fa_label_1504:
00665:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> Start=========================
            _lptr_read:
00666:      	AR=		DX
00667:      	test		AR.b11
00668:      	if ZR jmp	@_lptr_read_label_1510
            
00669:      	P1.hh=		AR
0066A:      	AR=		AX
0066B:      	P1=		AR
0066C:      	AX=		pm[P1]
0066D:      	P1.hh=		0
0066E:      	rets
            
            @_lptr_read_label_1510:
            
0066F:      	AR=		AX
00670:      	I1=		AR
00671:      	AX=		rm[I1]
00672:      	rets
            
            
            _lptr_read32:
00673:      	AR=		DX
00674:      	test		AR.b11
00675:      	if ZR jmp	@_lptr_read_label_1510_32
            
00676:      	P1.hh=		AR
00677:      	AR=		AX
00678:      	P1=		AR
00679:      	AX=		pm[P1++]
0067A:      	DX=		pm[P1]
0067B:      	P1.hh=		0
0067C:      	rets
            
            @_lptr_read_label_1510_32:
            
0067D:      	AR=		AX
0067E:      	I1=		AR
0067F:      	AX=		rm[I1++]
00680:      	DX=		rm[I1]
00681:      	rets
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> End=========================
            
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libc\memset.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_sC3E11DB1:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
00682:      	AR	= rm[BP_SAVE]
00683:      	push	AR
00684:      	AR	= BP
00685:      	rm[BP_SAVE]	= AR
00686:      	AR	 = -1
00687:      	BP	+= AR
            ; //_A0432E234_321:;				
            _A0432E234_321:
            ; //	
            ; //_A0432E234_322:;				
            _A0432E234_322:
            ; //	sSI	= (int)&_s_0_4;			
00688:      	AR	= 2
00689:      	I1	= rm[BP_SAVE]
0068A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0068B:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
0068C:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0068D:      	rm[I1]	= AX
            ; //LF2D2B0F3_101:;					
            LF2D2B0F3_101:
            ; //_A0432E234_323:;				
            _A0432E234_323:
            ; //	sSI	= (int)&_n_0_8;			
0068E:      	AR	= 4
0068F:      	I1	= rm[BP_SAVE]
00690:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00691:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00692:      	AR	= 4
00693:      	I1	= rm[BP_SAVE]
00694:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00695:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00696:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00697:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00698:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_102;	
00699:      	if NZ	jmp LF2D2B0F3_102
            ; //	goto	LF2D2B0F3_100;			
0069A:      	jmp	LF2D2B0F3_100
            ; //LF2D2B0F3_102:;					
            LF2D2B0F3_102:
            ; //_A0432E234_324:;				
            _A0432E234_324:
            ; //	sSI	= (int)&_ret_1_2;		
0069B:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0069C:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0069D:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
0069E:      	AR	= 3
0069F:      	I1	= rm[BP_SAVE]
006A0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006A1:      	AX	= rm[I1]
            ; //	sSI	= POP();			
006A2:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
006A3:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
006A4:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
006A5:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
006A6:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
006A7:      	rm[I1] = AX + AR//
            ; //_A0432E234_325:;				
            _A0432E234_325:
            ; //	goto LF2D2B0F3_101;			
006A8:      	jmp	LF2D2B0F3_101
            ; //LF2D2B0F3_100:;					
            LF2D2B0F3_100:
            ; //_A0432E234_326:;				
            _A0432E234_326:
            ; //	sSI	= (int)&_s_0_4;			
006A9:      	AR	= 2
006AA:      	I1	= rm[BP_SAVE]
006AB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006AC:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_99;			
006AD:      	jmp	LF2D2B0F3_99
            ; //LF2D2B0F3_99:;					
            LF2D2B0F3_99:
            ; //_A0432E234_327:;				
            _A0432E234_327:
            ; //	return;					
006AE:      	AR	= 1
006AF:      	BP	+= AR
006B0:      	pop	AR
006B1:      	rm[BP_SAVE]	= AR
006B2:      	rets
            ; //_memset_sC3E11DB1_end:;				
            _memset_sC3E11DB1_end:
            ; //_A0432E234_328:;				
            _A0432E234_328:
            ; //}
            ; //
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_rC7200006:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
006B3:      	AR	= rm[BP_SAVE]
006B4:      	push	AR
006B5:      	AR	= BP
006B6:      	rm[BP_SAVE]	= AR
006B7:      	AR	 = -1
006B8:      	BP	+= AR
            ; //_A0432E234_329:;				
            _A0432E234_329:
            ; //	
            ; //_A0432E234_330:;				
            _A0432E234_330:
            ; //	sSI	= (int)&_s_0_4;			
006B9:      	AR	= 2
006BA:      	I1	= rm[BP_SAVE]
006BB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006BC:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
006BD:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
006BE:      	rm[I1]	= AX
            ; //LF2D2B0F3_105:;					
            LF2D2B0F3_105:
            ; //_A0432E234_331:;				
            _A0432E234_331:
            ; //	sSI	= (int)&_n_0_8;			
006BF:      	AR	= 4
006C0:      	I1	= rm[BP_SAVE]
006C1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006C2:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
006C3:      	AR	= 4
006C4:      	I1	= rm[BP_SAVE]
006C5:      	I1	+= AR
            ; //	asm AR = 0x0001;			
006C6:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
006C7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
006C8:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
006C9:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_106;	
006CA:      	if NZ	jmp LF2D2B0F3_106
            ; //	goto	LF2D2B0F3_104;			
006CB:      	jmp	LF2D2B0F3_104
            ; //LF2D2B0F3_106:;					
            LF2D2B0F3_106:
            ; //_A0432E234_332:;				
            _A0432E234_332:
            ; //	sSI	= (int)&_ret_1_2;		
006CC:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
006CD:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006CE:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
006CF:      	AR	= 3
006D0:      	I1	= rm[BP_SAVE]
006D1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006D2:      	AX	= rm[I1]
            ; //	sSI	= POP();			
006D3:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
006D4:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
006D5:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
006D6:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
006D7:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
006D8:      	rm[I1] = AX + AR//
            ; //_A0432E234_333:;				
            _A0432E234_333:
            ; //	goto LF2D2B0F3_105;			
006D9:      	jmp	LF2D2B0F3_105
            ; //LF2D2B0F3_104:;					
            LF2D2B0F3_104:
            ; //_A0432E234_334:;				
            _A0432E234_334:
            ; //	sSI	= (int)&_s_0_4;			
006DA:      	AR	= 2
006DB:      	I1	= rm[BP_SAVE]
006DC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006DD:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_103;			
006DE:      	jmp	LF2D2B0F3_103
            ; //LF2D2B0F3_103:;					
            LF2D2B0F3_103:
            ; //_A0432E234_335:;				
            _A0432E234_335:
            ; //	return;					
006DF:      	AR	= 1
006E0:      	BP	+= AR
006E1:      	pop	AR
006E2:      	rm[BP_SAVE]	= AR
006E3:      	rets
            ; //_memset_rC7200006_end:;				
            _memset_rC7200006_end:
            ; //_A0432E234_336:;				
            _A0432E234_336:
            ; //}
            ; //
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10)
            _memset5A9D755A:
            ; //{						
006E4:      	AR	= rm[BP_SAVE]
006E5:      	push	AR
006E6:      	AR	= BP
006E7:      	rm[BP_SAVE]	= AR
            ; //_A0432E234_337:;				
            _A0432E234_337:
            ; //	
            ; //_A0432E234_338:;				
            _A0432E234_338:
            ; //	sAX	= (int)&_s_0_4_0;		
006E8:      	AR	= 2
006E9:      	AX	= rm[BP_SAVE]
006EA:      	AX	+= AR
            ; //	sCX	= 0x0001;			
006EB:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
006EC:      	AR	= CX
006ED:      	AX	+= AR
            ; //	sSI	= sAX;				
006EE:      	AR	= AX
006EF:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006F0:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
006F1:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_109;	
006F2:      	if NZ	jmp LF2D2B0F3_109
            ; //	goto	LF2D2B0F3_108;			
006F3:      	jmp	LF2D2B0F3_108
            ; //LF2D2B0F3_109:;					
            LF2D2B0F3_109:
            ; //_A0432E234_339:;				
            _A0432E234_339:
            ; //_A0432E234_340:;				
            _A0432E234_340:
            ; //	sSI	= (int)&_n_0_10;		
006F4:      	AR	= 5
006F5:      	I1	= rm[BP_SAVE]
006F6:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006F7:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006F8:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
006F9:      	AR	= 4
006FA:      	I1	= rm[BP_SAVE]
006FB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006FC:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006FD:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
006FE:      	AR	= 2
006FF:      	AX	= rm[BP_SAVE]
00700:      	AX	+= AR
            ; //	sSI	= sAX;				
00701:      	AR	= AX
00702:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
00703:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00704:      	push	AX
            ; //	_memset_rC7200006(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
00705:      	call	_memset_rC7200006
            ; //	RESTORESP(3);				
00706:      	AR	= 3
00707:      	BP	+= AR
            ; //	sDX	= 0x0800;			
00708:      	DX	= 0x0800
            ; //	goto LF2D2B0F3_107;			
0070A:      	jmp	LF2D2B0F3_107
            ; //LF2D2B0F3_108:;					
            LF2D2B0F3_108:
            ; //_A0432E234_341:;				
            _A0432E234_341:
            ; //_A0432E234_342:;				
            _A0432E234_342:
            ; //_A0432E234_343:;				
            _A0432E234_343:
            ; //	sSI	= (int)&_n_0_10;		
0070B:      	AR	= 5
0070C:      	I1	= rm[BP_SAVE]
0070D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0070E:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0070F:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
00710:      	AR	= 4
00711:      	I1	= rm[BP_SAVE]
00712:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00713:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00714:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
00715:      	AR	= 2
00716:      	AX	= rm[BP_SAVE]
00717:      	AX	+= AR
            ; //	sSI	= sAX;				
00718:      	AR	= AX
00719:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0071A:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0071B:      	push	AX
            ; //	_memset_sC3E11DB1(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
0071C:      	call	_memset_sC3E11DB1
            ; //	RESTORESP(3);				
0071D:      	AR	= 3
0071E:      	BP	+= AR
            ; //	sDX	= 0;				
0071F:      	DX	= 0x00
            ; //	goto LF2D2B0F3_107;			
00720:      	jmp	LF2D2B0F3_107
            ; //LF2D2B0F3_107:;					
            LF2D2B0F3_107:
            ; //_A0432E234_344:;				
            _A0432E234_344:
            ; //	return;					
00721:      	pop	AR
00722:      	rm[BP_SAVE]	= AR
00723:      	rets
            ; //_memset5A9D755A_end:;				
            _memset5A9D755A_end:
            ; //_A0432E234_345:;				
            _A0432E234_345:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libadpcm\adp12.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> Start=========================
            ; .\lib\libsubb3\sub3_cshell.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> Start=========================
            
            
            
            
            
            _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E:
            ; {
00724:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
00725:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder	; Z fail
00726:              AX=		1
00727:              if NZ jmp	L9E1082DD_0
00728:              AX=		0
            L9E1082DD_0:
00729:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\XDSP_ADPCM_4BIT_DECV04.OBJ"
            ;
            
            ;
            #LINKOBJ ".\LIB\LIBSUBB3\SBB3_CH0DECV07.OBJ"
            ;
            
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> Start=========================
            
            
            #ifdef _MSPEECHDSP_
            
            Subb3_Init:
            	PCH=            SDSP_Sbb3_Ch0InitV07
            	ljmp		SDSP_Sbb3_Ch0InitV07
            
            Subb3_Dec:
            	PCH=		SDSP_Sbb3_Ch0decV07
            	lcall		SDSP_Sbb3_Ch0decV07
                    AX=		0
                    if NZ jmp	@sdsp_sbb2_ch0dec_a
                    AX=		1
            @sdsp_sbb2_ch0dec_a:
            	rets
            
            #else
            
            Subb3_Init:
02FAC:      	PCH=            Sbb3_Ch0InitV07
02FAD:      	ljmp		Sbb3_Ch0InitV07
            
            Subb3_Dec:
02FAE:      	PCH=		Sbb3_Ch0decV07
02FAF:      	lcall		Sbb3_Ch0decV07
02FB0:              AX=		0
02FB1:              if NZ jmp	@sdsp_sbb2_ch0dec_a
02FB2:              AX=		1
            @sdsp_sbb2_ch0dec_a:
02FB3:      	rets
            
            #endif
            
            
            
            ; C function wrapper, may need add more preserve registers
            
            
            Sbb_Skipdata:
            ; {
02FB4:      	push		AX
02FB5:      	push		BX
02FB6:      	push		CX
02FB7:      	push		DX
02FB8:      	push		R2
02FB9:      	push		R3
            
02FBA:      	push		R1			; ~~ skip high
02FBB:      	push		R0			;         low
            
02FBC:      	PCH=		_Sbb_SkipdataE1C72441
02FBD:      	lcall		_Sbb_SkipdataE1C72441
            	
02FBE:      	pop		R1
02FBF:      	pop		R0
02FC0:      	pop		R3
02FC1:      	pop		R2
02FC2:      	pop		DX
02FC3:      	pop		CX
02FC4:      	pop		BX
02FC5:      	pop		AX
02FC6:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> End=========================
            
            ;=========================Include <DEPS\278206AB_GINIT.S.CODE.ASM> Start=========================
            ; 278206AB_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	return;					
02FC7:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\278206AB_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
02FC8:      	P1.hh=		0
02FC9:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
02FCA:      	AR=		pm[P1++]
02FCB:      	rm[I1++]=	AR
            @glinit_label_1409:
02FCC:      	loop		@glinit_loop_1409
02FCD:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
02FCE:      	AR=		AX
02FCF:      	MX=		AR
02FD0:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02FD1:      	MACOP=		3
02FD2:      	MR=		MX * AR
            #endif
            
02FD3:      	AR=		MR0
02FD4:      	AX=		AR
02FD5:      	AR=		MR1
02FD6:      	DX=		AR
02FD7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
02FD8:      	AR=		AX
02FD9:      	MX=		AR
02FDA:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
02FDB:      	MACOP=		0
02FDC:      	MR=		MX * AR
            #endif
            
02FDD:      	AR=		MR0
02FDE:      	AX=		AR
02FDF:      	AR=		MR1
02FE0:      	DX=		AR
02FE1:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
02FE2:      	AR=		rm[BP_SAVE]
02FE3:      	push		AR
02FE4:      	AR=		BP
02FE5:      	rm[BP_SAVE]=	AR
02FE6:      	AR=		AR - 3
02FE7:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
02FE8:      	AR=		CX
02FE9:      	MX=		AR
02FEA:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02FEB:      	MACOP=		3		; unsigned
02FEC:      	MR=		MX * AR
            #endif
            
02FED:      	I1=		rm[BP_SAVE]
02FEE:      	AR=		2
02FEF:      	I1=		I1 - AR
02FF0:      	rm[I1++]=	MR0
02FF1:      	rm[I1++]=	MR1
02FF2:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
02FF3:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
02FF4:      	MACOP=		1		; mx:unsigned / my:signed
02FF5:      	MR=		MX * AR
            #endif
            
02FF6:      	AR=		rm[I1]
02FF7:      	AR=		AR + MR0
02FF8:      	rm[I1++]=	AR
02FF9:      	AR=		rm[I1]
02FFA:      	AR=		AR + MR1 + C
02FFB:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
02FFC:      	AR=		BX
02FFD:      	MX=		AR
02FFE:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
02FFF:      	MACOP=		2		; mx:signed / my:unsigned
03000:      	MR=		MX * AR
            #endif
            
03001:      	AR=		rm[I1]
03002:      	AR=		AR + MR0
03003:      	rm[I1++]=	AR
03004:      	AR=		rm[I1]
03005:      	AR=		AR + MR1 + C
03006:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
03007:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
03008:      	MACOP=		0		; mx:signed / my:signed
03009:      	MR=		MX * AR
            #endif
            
0300A:      	AR=		rm[I1]
0300B:      	AR=		AR + MR0
0300C:      	rm[I1]=		AR
            
0300D:      	I1=		rm[BP_SAVE]
0300E:      	CX=		rm[I1--]
0300F:      	DX=		rm[I1--]
03010:      	AX=		rm[I1]
            
03011:      	AR=		3
03012:      	BP=		BP + AR
03013:      	pop		AR
03014:      	rm[BP_SAVE]=	AR
            
03015:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
03016:      	AR=		rm[BP_SAVE]
03017:      	push		AR
03018:      	AR=		BP
03019:      	rm[BP_SAVE]=	AR
0301A:      	AR=		AR - 3
0301B:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
0301C:      	AR=		CX
0301D:      	MX=		AR
0301E:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0301F:      	MACOP=		3		; unsigned
03020:      	MR=		MX * AR
            #endif
            
03021:      	I1=		rm[BP_SAVE]
03022:      	AR=		2
03023:      	I1=		I1 - AR
03024:      	rm[I1++]=	MR0
03025:      	rm[I1++]=	MR1
03026:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
03027:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
03028:      	MR=		MX * AR
            #endif
            
03029:      	AR=		rm[I1]
0302A:      	AR=		AR + MR0
0302B:      	rm[I1++]=	AR
0302C:      	AR=		rm[I1]
0302D:      	AR=		AR + MR1 + C
0302E:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
0302F:      	AR=		BX
03030:      	MX=		AR
03031:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
03032:      	MR=		MX * AR
            #endif
            
03033:      	AR=		rm[I1]
03034:      	AR=		AR + MR0
03035:      	rm[I1++]=	AR
03036:      	AR=		rm[I1]
03037:      	AR=		AR + MR1 + C
03038:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
03039:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0303A:      	MR=		MX * AR
            #endif
            
0303B:      	AR=		rm[I1]
0303C:      	AR=		AR + MR0
0303D:      	rm[I1]=		AR
            
0303E:      	I1=		rm[BP_SAVE]
0303F:      	CX=		rm[I1--]
03040:      	DX=		rm[I1--]
03041:      	AX=		rm[I1]
            
03042:      	AR=		3
03043:      	BP=		BP + AR
03044:      	pop		AR
03045:      	rm[BP_SAVE]=	AR
            
03046:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
03047:      		DX=		0
            	; unsigned char count = 16;
03048:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
03049:      			slz		AX, 1
            		; reste <<= 1;
0304A:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
0304B:      			AR=		DX
0304C:      			AR-=		CX
0304D:      			AR=		0
0304E:      			AR=		AR - 0 + C - 1
0304F:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
03050:      				AR=		CX
03051:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
03052:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
03053:      		R0--
03054:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
03055:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
03056:      		R1=		0
03057:      		AR=		0
03058:      		test		AX.b15
03059:      		if ZR jmp	@divsword_label_1833
0305A:      			AX=		AR - AX
0305B:      			set		R1.b0
            		@divsword_label_1833:
0305C:      		test		CX.b15
0305D:      		if ZR jmp	@divsword_label_1834
0305E:      			CX=		AR - CX
0305F:      			set		R1.b1
            		@divsword_label_1834:
03060:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
03061:      		AR=		R1
03062:      		slz		AR, 1
03063:      		AR^=		R1
03064:      		test		AR.b1
03065:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
03066:      			AR=		0
03067:      			AX=		AR - AX
03068:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
03069:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
0306A:      		R0=		0	; L
0306B:      		R1=		0	; H
            	; unsigned char count = 32;
0306C:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
0306D:      			slz		AX, 1
0306E:      			slc		DX, 1
            		; reste <<= 1;
0306F:      			slc		R0, 1
03070:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
03071:      			AR=		R0
03072:      			AR-=		CX
03073:      			AR=		R1
03074:      			AR=		AR - BX + C - 1
03075:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
03076:      				AR=		CX
03077:      				R0=		R0 - AR
03078:      				AR=		BX
03079:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
0307A:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
0307B:      		R2--
0307C:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
0307D:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
0307E:      		R3=		0
0307F:      		AR=		0
03080:      		test		DX.b15
03081:      		if ZR jmp	@divslong_label_1759
03082:      			AX=		AR - AX
03083:      			DX=		AR - DX + C - 1
03084:      			set		R3.b0
            		@divslong_label_1759:
03085:      		test		BX.b15
03086:      		if ZR jmp	@divslong_label_1800
03087:      			CX=		AR - CX
03088:      			BX=		AR - BX + C - 1
03089:      			set		R3.b1
            		@divslong_label_1800:
0308A:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
0308B:      		AR=		R3
0308C:      		slz		AR, 1
0308D:      		AR^=		R3
0308E:      		test		AR.b1
0308F:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
03090:      			AR=		0
03091:      			AX=		AR - AX
03092:      			DX=		AR - DX + C - 1
03093:      			R0=		AR - R0
03094:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
03095:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
03096:      	call		sfx_DIV_AX_CX
03097:      	AR=		DX
03098:      	AX=		AR
03099:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
0309A:      	call		sfx_IDIV_AX_CX
0309B:      	AR=		DX
0309C:      	AX=		AR
0309D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
0309E:      	call		sfx_DIVLONG
0309F:      	AR=		R0
030A0:      	AX=		AR
030A1:      	AR=		R1
030A2:      	DX=		AR
030A3:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
030A4:      	call		sfx_IDIVLONG
030A5:      	AR=		R0
030A6:      	AX=		AR
030A7:      	AR=		R1
030A8:      	DX=		AR
030A9:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
030AA:      	AR=		AX
030AB:      	P1=		P1 + AR
030AC:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
030AD:      	AR=		AX
030AE:      	I1=		I1 + AR
030AF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
030B0:      	AR=		CX
030B1:      	AX=		AX + AR
030B2:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
030B3:      	AR=		AX
030B4:      	P1=		P1 - AR
030B5:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
030B6:      	AR=		AX
030B7:      	I1=		I1 - AR
030B8:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
030B9:      	AR=		CX
030BA:      	AX=		AX + AR
030BB:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
030BC:      	pm[P1++]=	AX
030BD:      	pm[P1--]=	DX
030BE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
030BF:      	pm[P1++]=	CX
030C0:      	pm[P1--]=	BX
030C1:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
030C2:      	BX=		0
030C3:      	CX.h=		0
030C4:      	test		CX.b7
030C5:      	if ZR jmp	@c2lcx_label_1800
030C6:      	CX.h=		0xFF
030C7:      	BX=		-1
            @c2lcx_label_1800:
030C8:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
030C9:      	DX=		0
030CA:      	AX.h=		0
030CB:      	test		AX.b7
030CC:      	if ZR jmp	@c2lax_label_1800
030CD:      	AX.h=		0xFF
030CE:      	DX=		-1
            @c2lax_label_1800:
030CF:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
030D0:      	push		AX
030D1:      	push		CX
030D2:      	pop		AX
030D3:      	pop		CX
030D4:      	push		DX
030D5:      	push		BX
030D6:      	pop		DX
030D7:      	pop		BX
030D8:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
030D9:      	AR=		DX
030DA:      	DX=		0
030DB:      	AR=		AR | AX
030DC:      	AX=		1
030DD:      	if ZR jmp	@longnotl_label_1120
030DE:      	AX=		0
            @longnotl_label_1120:
030DF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
030E0:      	DX=		0
030E1:      	BX=		0
            sfx_CMPLONG_JNE:
030E2:      	AR=		CX
030E3:      	AX=		AX - AR
030E4:      	AR=		BX
030E5:      	AR=		DX - AR + C - 1
030E6:      	AR=		AR | AX
030E7:      	if EQ jmp	@sfx_cl_jne_f
030E8:      	set		Z		; true
030E9:      	rets
            @sfx_cl_jne_f:
030EA:      	clr		Z		; false
030EB:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
030EC:      	DX=		0
030ED:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
030EE:      	AR=		AX
030EF:      	CX=		CX - AR
030F0:      	AR=		DX
030F1:      	AR=		BX - AR + C - 1
030F2:      	AR=		AR | CX
030F3:      	if EQ jmp	@sfx_clbcda_jne_f
030F4:      	set		Z		; true
030F5:      	rets
            @sfx_clbcda_jne_f:
030F6:      	clr		Z		; false
030F7:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
030F8:      	AR=		CX
030F9:      	SF=		AX - AR
030FA:      	if EQ jmp	@sfx_ac_jne_f
030FB:      	set		Z
030FC:      	rets
            @sfx_ac_jne_f:
030FD:      	clr		Z
030FE:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
030FF:      	AR=		AX
03100:      	SF=		CX - AR
03101:      	if EQ jmp	@sfx_ca_jne_f
03102:      	set		Z
03103:      	rets
            @sfx_ca_jne_f:
03104:      	clr		Z
03105:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
03106:      	DX=		0
03107:      	BX=		0
            sfx_CMPLONG_JE:
03108:      	AR=		CX
03109:      	AX=		AX - AR
0310A:      	AR=		BX
0310B:      	AR=		DX - AR + C - 1
0310C:      	AR=		AR | AX
0310D:      	if NE jmp	@sfx_cl_jz_f
0310E:      	set		Z		; true
0310F:      	rets
            @sfx_cl_jz_f:
03110:      	clr		Z		; false
03111:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
03112:      	DX=		0
03113:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
03114:      	AR=		AX
03115:      	CX=		CX - AR
03116:      	AR=		DX
03117:      	AR=		BX - AR + C - 1
03118:      	AR=		AR | CX
03119:      	if NE jmp	@sfx_clbcda_jz_f
0311A:      	set		Z		; true
0311B:      	rets
            @sfx_clbcda_jz_f:
0311C:      	clr		Z		; false
0311D:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
0311E:      	DX=		0
0311F:      	BX=		0
            sfx_CMPLONG_JG:
03120:      	AR=		CX
03121:      	AX=		AX - AR
03122:      	AR=		BX
03123:      	AR=		DX - AR + C - 1
03124:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
03125:      	AR=		AR | AX
03126:      	if ZR jmp	@sfx_cl_jg_f
            
03127:      	set		Z		; true
03128:      	rets
            @sfx_cl_jg_f:
03129:      	clr		Z		; false
0312A:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
0312B:      	AR=		CX
0312C:      	AX=		AX - AR
0312D:      	AR=		BX
0312E:      	DX=		DX - AR + C - 1
0312F:      	AR=		0
03130:      	AR=		AR - 0 + C - 1
03131:      	if AN jmp	@sfx_cl_jg_f
            
03132:      	AR=		AR | DX		; exclude EQU condition
03133:      	AR=		AR | AX
03134:      	if ZR jmp	@sfx_cl_jg_f
            
03135:      	set		Z		; true
03136:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
03137:      	DX=		0
03138:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
03139:      	AR=		AX
0313A:      	CX=		CX - AR
0313B:      	AR=		DX
0313C:      	AR=		BX - AR + C - 1
0313D:      	if AN jmp	@sfx_clbcda_jg_f
            
0313E:      	AR=		AR | CX		; exclude EQU condition
0313F:      	if ZR jmp	@sfx_clbcda_jg_f
            
03140:      	set		Z		; true
03141:      	rets
            @sfx_clbcda_jg_f:
03142:      	clr		Z		; false
03143:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
03144:      	AR=		AX
03145:      	CX=		CX - AR
03146:      	AR=		DX
03147:      	BX=		BX - AR + C - 1
03148:      	AR=		0
03149:      	AR=		AR - 0 + C - 1
0314A:      	if AN jmp	@sfx_clbcda_jg_f
            
0314B:      	AR=		AR | BX		; exclude EQU condition
0314C:      	AR=		AR | CX
0314D:      	if ZR jmp	@sfx_clbcda_jg_f
            
0314E:      	set		Z		; true
0314F:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
03150:      	AR=		CX
03151:      	SF=		AX - AR
03152:      	if LE jmp	@sfx_cmp_ac_jg_f
03153:      	set		Z
03154:      	rets
            @sfx_cmp_ac_jg_f:
03155:      	clr		Z
03156:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
03157:      	AR=		AX
03158:      	SF=		CX - AR
03159:      	if LE jmp	@sfx_cmp_ca_jg_f
0315A:      	set		Z
0315B:      	rets
            @sfx_cmp_ca_jg_f:
0315C:      	clr		Z
0315D:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
0315E:      	DX=		0
0315F:      	BX=		0
            sfx_CMPLONG_JGE:
03160:      	AR=		CX
03161:      	AX=		AX - AR
03162:      	AR=		BX
03163:      	DX=		DX - AR + C - 1
03164:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
03165:      	set		Z		; true
03166:      	rets
            @sfx_cl_jge_f:
03167:      	clr		Z		; false
03168:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
03169:      	AR=		CX
0316A:      	AX=		AX - AR
0316B:      	AR=		BX
0316C:      	DX=		DX - AR + C - 1
0316D:      	AR=		0
0316E:      	AR=		AR - 0 + C - 1
0316F:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
03170:      	set		Z		; true
03171:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
03172:      	DX=		0
03173:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
03174:      	AR=		AX
03175:      	CX=		CX - AR
03176:      	AR=		DX
03177:      	BX=		BX - AR + C - 1
03178:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
03179:      	set		Z		; true
0317A:      	rets
            @sfx_clbcda_jge_f:
0317B:      	clr		Z		; false
0317C:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
0317D:      	AR=		AX
0317E:      	CX=		CX - AR
0317F:      	AR=		DX
03180:      	BX=		BX - AR + C - 1
03181:      	AR=		0
03182:      	AR=		AR - 0 + C - 1
03183:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
03184:      	set		Z		; true
03185:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
03186:      	AR=		CX
03187:      	SF=		AX - AR
03188:      	if AN jmp	@sfx_cmp_ac_jge_f
03189:      	set		Z
0318A:      	rets
            @sfx_cmp_ac_jge_f:
0318B:      	clr		Z
0318C:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
0318D:      	AR=		AX
0318E:      	SF=		CX - AR
0318F:      	if AN jmp	@sfx_cmp_ca_jge_f
03190:      	set		Z
03191:      	rets
            @sfx_cmp_ca_jge_f:
03192:      	clr		Z
03193:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
03194:      	DX=		0
03195:      	BX=		0
            sfx_CMPLONG_JL:
03196:      	AR=		CX
03197:      	AX=		AX - AR
03198:      	AR=		BX
03199:      	AR=		DX - AR + C - 1
0319A:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
0319B:      	clr		Z		; false
0319C:      	rets
            
            @sfx_cl_jl_chk:
0319D:      	AR=		AR | AX		; exclude EQU condition
0319E:      	if ZR jmp	@sfx_cl_jl_f
0319F:      	set		Z
031A0:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
031A1:      	AR=		CX
031A2:      	AX=		AX - AR
031A3:      	AR=		BX
031A4:      	DX=		DX - AR + C - 1
031A5:      	AR=		0
031A6:      	AR=		AR - 0 + C - 1
031A7:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
031A8:      	clr		Z		; false
031A9:      	rets
            
            @sfx_cl_jb_chk:
031AA:      	AR=		AR | DX
031AB:      	AR=		AR | AX		; exclude EQU condition
031AC:      	if ZR jmp	@sfx_cl_jb_f
031AD:      	set		Z
031AE:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
031AF:      	DX=		0
031B0:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
031B1:      	AR=		AX
031B2:      	CX=		CX - AR
031B3:      	AR=		DX
031B4:      	AR=		BX - AR + C - 1
031B5:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
031B6:      	clr		Z		; false
031B7:      	rets
            
            @sfx_clbcda_jl_chk:
031B8:      	AR=		AR | CX		; exclude EQU condition
031B9:      	if ZR jmp	@sfx_clbcda_jl_f
031BA:      	set		Z		; true
031BB:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
031BC:      	AR=		AX
031BD:      	CX=		CX - AR
031BE:      	AR=		DX
031BF:      	BX=		BX - AR + C - 1
031C0:      	AR=		0
031C1:      	AR=		AR - 0 + C - 1
031C2:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
031C3:      	clr		Z		; false
031C4:      	rets
            
            @sfx_clbcda_jb_chk:
031C5:      	AR=		AR | CX
031C6:      	AR=		AR | BX
031C7:      	if ZR jmp	@sfx_clbcda_jb_f
031C8:      	set		Z		; true
031C9:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
031CA:      	AR=		CX
031CB:      	SF=		AX - AR
031CC:      	if GE jmp	@sfx_cmp_ac_jl_f
031CD:      	set		Z
031CE:      	rets
            @sfx_cmp_ac_jl_f:
031CF:      	clr		Z
031D0:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
031D1:      	AR=		AX
031D2:      	SF=		CX - AR
031D3:      	if GE jmp	@sfx_cmp_ca_jl_f
031D4:      	set		Z
031D5:      	rets
            @sfx_cmp_ca_jl_f:
031D6:      	clr		Z
031D7:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
031D8:      	DX=		0
031D9:      	BX=		0
            sfx_CMPLONG_JLE:
031DA:      	AR=		CX
031DB:      	AX=		AX - AR
031DC:      	AR=		BX
031DD:      	AR=		DX - AR + C - 1
031DE:      	if AN jmp	@sfx_cl_jle_t
            
031DF:      	AR=		AR | AX		; include EQU condition
031E0:      	if ZR jmp	@sfx_cl_jle_t
            
031E1:      	clr		Z		; false
031E2:      	rets
            @sfx_cl_jle_t:
031E3:      	set		Z		; true
031E4:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
031E5:      	AR=		CX
031E6:      	AX=		AX - AR
031E7:      	AR=		BX
031E8:      	DX=		DX - AR + C - 1
031E9:      	AR=		0
031EA:      	AR=		AR - 0 + C - 1
031EB:      	if AN jmp	@sfx_cl_jle_t
            
031EC:      	AR=		AR | DX
031ED:      	AR=		AR | AX
031EE:      	if ZR jmp	@sfx_cl_jle_t
            
031EF:      	clr		Z		; false
031F0:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
031F1:      	DX=		0
031F2:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
031F3:      	AR=		AX
031F4:      	CX=		CX - AR
031F5:      	AR=		DX
031F6:      	AR=		BX - AR + C - 1
031F7:      	if AN jmp	@sfx_clbcda_jle_t
            
031F8:      	AR=		AR | CX		; include EQU condition
031F9:      	if ZR jmp	@sfx_clbcda_jle_t
            
031FA:      	clr		Z		; false
031FB:      	rets
            @sfx_clbcda_jle_t:
031FC:      	set		Z		; true
031FD:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
031FE:      	AR=		AX
031FF:      	CX=		CX - AR
03200:      	AR=		DX
03201:      	BX=		BX - AR + C - 1
03202:      	AR=		0
03203:      	AR=		AR - 0 + C - 1
03204:      	if AN jmp	@sfx_clbcda_jle_t
            
03205:      	AR=		AR | BX
03206:      	AR=		AR | CX
03207:      	if ZR jmp	@sfx_clbcda_jle_t
            
03208:      	clr		Z		; false
03209:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
0320A:      	AR=		CX
0320B:      	SF=		AX - AR
0320C:      	if LE jmp	@sfx_cmp_ac_jl_t
0320D:      	clr		Z
0320E:      	rets
            @sfx_cmp_ac_jl_t:
0320F:      	set		Z
03210:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
03211:      	AR=		AX
03212:      	SF=		CX - AR
03213:      	if LE jmp	@sfx_cmp_ca_jl_t
03214:      	clr		Z
03215:      	rets
            @sfx_cmp_ca_jl_t:
03216:      	set		Z
03217:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
03218:      	DW 0xFFFE
            @sfx_ortable_1:
03219:      	DW 0xFFFC
            @sfx_ortable_2:
0321A:      	DW 0xFFF8
            @sfx_ortable_3:
0321B:      	DW 0xFFF0
            @sfx_ortable_4:
0321C:      	DW 0xFFE0
            @sfx_ortable_5:
0321D:      	DW 0xFFC0
            @sfx_ortable_6:
0321E:      	DW 0xFF80
            @sfx_ortable_7:
0321F:      	DW 0xFF00
            @sfx_ortable_8:
03220:      	DW 0xFE00
            @sfx_ortable_9:
03221:      	DW 0xFC00
            @sfx_ortable_10:
03222:      	DW 0xF800
            @sfx_ortable_11:
03223:      	DW 0xF000
            @sfx_ortable_12:
03224:      	DW 0xE000
            @sfx_ortable_13:
03225:      	DW 0xC000
            @sfx_ortable_14:
03226:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
03227:      	AR=		pm[P1]
03228:      	DX=		DX | AR
03229:      	rets
            
            @sfx_orhigh_dx:
0322A:      	DX=		-1
            @sfx_orlow:
0322B:      	AR=		pm[P1]
0322C:      	AX=		AX | AR
            @sfx_sextw_rets:
0322D:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
0322E:      	P1=		#@sfx_ortable_0
03231:      	test		AX.b0
03232:      	if ZR jmp	@sfx_sextw_rets
03233:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
03234:      	P1=		#@sfx_ortable_1
03237:      	test		AX.b1
03238:      	if ZR jmp	@sfx_sextw_rets
03239:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
0323A:      	P1=		#@sfx_ortable_2
0323D:      	test		AX.b2
0323E:      	if ZR jmp	@sfx_sextw_rets
0323F:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
03240:      	P1=		#@sfx_ortable_3
03243:      	test		AX.b3
03244:      	if ZR jmp	@sfx_sextw_rets
03245:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
03246:      	P1=		#@sfx_ortable_4
03249:      	test		AX.b4
0324A:      	if ZR jmp	@sfx_sextw_rets
0324B:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
0324C:      	P1=		#@sfx_ortable_5
0324F:      	test		AX.b5
03250:      	if ZR jmp	@sfx_sextw_rets
03251:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
03252:      	P1=		#@sfx_ortable_6
03255:      	test		AX.b6
03256:      	if ZR jmp	@sfx_sextw_rets
03257:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
03258:      	P1=		#@sfx_ortable_7
0325B:      	test		AX.b7
0325C:      	if ZR jmp	@sfx_sextw_rets
0325D:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
0325E:      	P1=		#@sfx_ortable_8
03261:      	test		AX.b8
03262:      	if ZR jmp	@sfx_sextw_rets
03263:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
03264:      	P1=		#@sfx_ortable_9
03267:      	test		AX.b9
03268:      	if ZR jmp	@sfx_sextw_rets
03269:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
0326A:      	P1=		#@sfx_ortable_10
0326D:      	test		AX.b10
0326E:      	if ZR jmp	@sfx_sextw_rets
0326F:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
03270:      	P1=		#@sfx_ortable_11
03273:      	test		AX.b11
03274:      	if ZR jmp	@sfx_sextw_rets
03275:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
03276:      	P1=		#@sfx_ortable_12
03279:      	test		AX.b12
0327A:      	if ZR jmp	@sfx_sextw_rets
0327B:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
0327C:      	P1=		#@sfx_ortable_13
0327F:      	test		AX.b13
03280:      	if ZR jmp	@sfx_sextw_rets
03281:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
03282:      	P1=		#@sfx_ortable_14
03285:      	test		AX.b14
03286:      	if ZR jmp	@sfx_sextw_rets
03287:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
03288:      	P1=		#@sfx_ortable_0
0328B:      	test		AX.b0
0328C:      	if ZR jmp	@sfx_sextw_rets
0328D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
0328E:      	P1=		#@sfx_ortable_1
03291:      	test		AX.b1
03292:      	if ZR jmp	@sfx_sextw_rets
03293:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
03294:      	P1=		#@sfx_ortable_2
03297:      	test		AX.b2
03298:      	if ZR jmp	@sfx_sextw_rets
03299:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
0329A:      	P1=		#@sfx_ortable_3
0329D:      	test		AX.b3
0329E:      	if ZR jmp	@sfx_sextw_rets
0329F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
032A0:      	P1=		#@sfx_ortable_4
032A3:      	test		AX.b4
032A4:      	if ZR jmp	@sfx_sextw_rets
032A5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
032A6:      	P1=		#@sfx_ortable_5
032A9:      	test		AX.b5
032AA:      	if ZR jmp	@sfx_sextw_rets
032AB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
032AC:      	P1=		#@sfx_ortable_6
032AF:      	test		AX.b6
032B0:      	if ZR jmp	@sfx_sextw_rets
032B1:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
032B2:      	P1=		#@sfx_ortable_7
032B5:      	test		AX.b7
032B6:      	if ZR jmp	@sfx_sextw_rets
032B7:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
032B8:      	P1=		#@sfx_ortable_8
032BB:      	test		AX.b8
032BC:      	if ZR jmp	@sfx_sextw_rets
032BD:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
032BE:      	P1=		#@sfx_ortable_9
032C1:      	test		AX.b9
032C2:      	if ZR jmp	@sfx_sextw_rets
032C3:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
032C4:      	P1=		#@sfx_ortable_10
032C7:      	test		AX.b10
032C8:      	if ZR jmp	@sfx_sextw_rets
032C9:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
032CA:      	P1=		#@sfx_ortable_11
032CD:      	test		AX.b11
032CE:      	if ZR jmp	@sfx_sextw_rets
032CF:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
032D0:      	P1=		#@sfx_ortable_12
032D3:      	test		AX.b12
032D4:      	if ZR jmp	@sfx_sextw_rets
032D5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
032D6:      	P1=		#@sfx_ortable_13
032D9:      	test		AX.b13
032DA:      	if ZR jmp	@sfx_sextw_rets
032DB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
032DC:      	P1=		#@sfx_ortable_14
032DF:      	test		AX.b14
032E0:      	if ZR jmp	@sfx_sextw_rets
032E1:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
032E2:      	test		AX.b15
032E3:      	if ZR jmp	@sfx_sextw_rets
032E4:      	DX=		-1
032E5:      	rets
            
            sfx_SignExtL16:
032E6:      	P1=		#@sfx_ortable_0
032E9:      	test		DX.b0
032EA:      	if ZR jmp	@sfx_sextw_rets
032EB:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
032EC:      	P1=		#@sfx_ortable_1
032EF:      	test		DX.b1
032F0:      	if ZR jmp	@sfx_sextw_rets
032F1:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
032F2:      	P1=		#@sfx_ortable_2
032F5:      	test		DX.b2
032F6:      	if ZR jmp	@sfx_sextw_rets
032F7:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
032F8:      	P1=		#@sfx_ortable_3
032FB:      	test		DX.b3
032FC:      	if ZR jmp	@sfx_sextw_rets
032FD:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
032FE:      	P1=		#@sfx_ortable_4
03301:      	test		DX.b4
03302:      	if ZR jmp	@sfx_sextw_rets
03303:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
03304:      	P1=		#@sfx_ortable_5
03307:      	test		DX.b5
03308:      	if ZR jmp	@sfx_sextw_rets
03309:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
0330A:      	P1=		#@sfx_ortable_6
0330D:      	test		DX.b6
0330E:      	if ZR jmp	@sfx_sextw_rets
0330F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
03310:      	P1=		#@sfx_ortable_7
03313:      	test		DX.b7
03314:      	if ZR jmp	@sfx_sextw_rets
03315:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
03316:      	P1=		#@sfx_ortable_8
03319:      	test		DX.b8
0331A:      	if ZR jmp	@sfx_sextw_rets
0331B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
0331C:      	P1=		#@sfx_ortable_9
0331F:      	test		DX.b9
03320:      	if ZR jmp	@sfx_sextw_rets
03321:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
03322:      	P1=		#@sfx_ortable_10
03325:      	test		DX.b10
03326:      	if ZR jmp	@sfx_sextw_rets
03327:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
03328:      	P1=		#@sfx_ortable_11
0332B:      	test		DX.b11
0332C:      	if ZR jmp	@sfx_sextw_rets
0332D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
0332E:      	P1=		#@sfx_ortable_12
03331:      	test		DX.b12
03332:      	if ZR jmp	@sfx_sextw_rets
03333:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
03334:      	P1=		#@sfx_ortable_13
03337:      	test		DX.b13
03338:      	if ZR jmp	@sfx_sextw_rets
03339:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
0333A:      	P1=		#@sfx_ortable_14
0333D:      	test		DX.b14
0333E:      	if ZR jmp	@sfx_sextw_rets
0333F:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
03340:      	push		I1
03341:      	AR=		AX
03342:      	I1=		AR
03343:      	AR=		rm[I1]
03344:      	pop		I1
03345:      	rm[I1++]=	AR
03346:      	AX++
03347:      	loop		@sfx_repmov_ss_loop_1804
03348:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
03349:      	AR=		AX
0334A:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
0334B:      	rm[I1++]=	pm[P1++]
0334C:      	loop		@sfx_repmov_sr_loop_1804
0334D:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
0334E:      	AR=		AX
0334F:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
03350:      	AR=		rm[I1++]
03351:      	pm[P1++]=	AR
03352:      	loop		@sfx_repmov_rs_loop_1804
03353:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
03354:      	push		P1
03355:      	AR=		AX
03356:      	P1=		AR
03357:      	AR=		pm[P1]
03358:      	pop		P1
03359:      	pm[P1++]=	AR
0335A:      	AX++
0335B:      	loop		@sfx_repmov_rr_loop_1804
0335C:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
0335D:      	PCH=	SYS_PROG_ENTRY
0335E:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
0335F:      	DW #EMPTY_INTENTRY
03360:      	DW #EMPTY_INTENTRY
03361:      	DW #EMPTY_INTENTRY
03362:      	DW #EMPTY_INTENTRY
03363:      	DW #EMPTY_INTENTRY
03364:      	DW #PWM_ENTRY
            
            // .code ends
            ;;FDSP-IDE V2.64
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
