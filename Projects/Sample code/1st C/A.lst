            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\A_5C91FC9D.S.CODE.ASM> Start=========================
            ; A.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //interrupt void _PWM99B23D7D();
            ; //void _WakeupProc94A410F9();
            ; //void _main();
            ; //void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //interrupt void _PWM99B23D7D()			
            _PWM99B23D7D:
            ; //{						
0011D:      	push ax
0011E:      	push bx
0011F:      	push cx
00120:      	push dx
00121:      	push r0
00122:      	push r1
00123:      	push r2
00124:      	push r3
00125:      	push i1
00126:      	push p1
00127:      	push mx
00128:      	push mr0
00129:      	push mr1
0012A:      	push mr2
0012B:      	ar = p1.hh
0012C:      	push ar
            ; //_A0FBC1636_0:;					
            _A0FBC1636_0:
            ; //_A0FBC1636_1:;					
            _A0FBC1636_1:
            ; //	asm	clr io[INTREQ].b0		
0012D:      	clr io[INTREQ].b0
            ; //_A0FBC1636_2:;					
            _A0FBC1636_2:
            ; //	asm	push AX				
0012E:      	push AX
            ; //_A0FBC1636_3:;					
            _A0FBC1636_3:
            ; //	asm	push I0				
0012F:      	push I0
            ; //_A0FBC1636_4:;					
            _A0FBC1636_4:
            ; //	asm	push I1				
00130:      	push I1
            ; //_A0FBC1636_5:;					
            _A0FBC1636_5:
            ; //	asm	pop I1				
00131:      	pop I1
            ; //_A0FBC1636_6:;					
            _A0FBC1636_6:
            ; //	asm	pop I0				
00132:      	pop I0
            ; //_A0FBC1636_7:;					
            _A0FBC1636_7:
            ; //	asm	pop AX				
00133:      	pop AX
            ; //	
            ; //LC114AE18_2:;					
            LC114AE18_2:
            ; //_A0FBC1636_8:;					
            _A0FBC1636_8:
            ; //	return;					
00134:      	pop ar
00135:      	p1.hh = ar
00136:      	pop mr2
00137:      	pop mr1
00138:      	pop mr0
00139:      	pop mx
0013A:      	pop p1
0013B:      	pop i1
0013C:      	pop r3
0013D:      	pop r2
0013E:      	pop r1
0013F:      	pop r0
00140:      	pop dx
00141:      	pop cx
00142:      	pop bx
00143:      	pop ax
00144:      	reti
            ; //_PWM99B23D7D_end:;				
            _PWM99B23D7D_end:
            ; //_A0FBC1636_9:;					
            _A0FBC1636_9:
            ; //}
            ; //
            ; //void _WakeupProc94A410F9()			
            _WakeupProc94A410F9:
            ; //{
            ; //_A0FBC1636_10:;					
            _A0FBC1636_10:
            ; //_A0FBC1636_11:;					
            _A0FBC1636_11:
            ; //	asm	io[ClrWDT] = AR			
00145:      	io[ClrWDT] = AR
            ; //	
            ; //LC114AE18_3:;					
            LC114AE18_3:
            ; //_A0FBC1636_12:;					
            _A0FBC1636_12:
            ; //	return;					
00146:      	rets
            ; //_WakeupProc94A410F9_end:;			
            _WakeupProc94A410F9_end:
            ; //_A0FBC1636_13:;					
            _A0FBC1636_13:
            ; //}
            ; //
            ; //void _main()					
            _main:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00147:      	AR	= rm[BP_SAVE]
00148:      	push	AR
00149:      	AR	= BP
0014A:      	rm[BP_SAVE]	= AR
0014B:      	AR	 = -1
0014C:      	BP	+= AR
            ; //_A0FBC1636_14:;					
            _A0FBC1636_14:
            ; //	
            ; //_A0FBC1636_15:;					
            _A0FBC1636_15:
            ; //	_i_1_2+0	= 0x00;			
0014D:      	I1	= rm[BP_SAVE]
0014E:      	AX	= 0x00
0014F:      	rm[I1]	= AX
            ; //_A0FBC1636_16:;					
            _A0FBC1636_16:
            ; //_A0FBC1636_17:;					
            _A0FBC1636_17:
            ; //	_InitialDA4A7CC4();			
00150:      	pch	= _InitialDA4A7CC4
00151:      	lcall	_InitialDA4A7CC4
            ; //LC114AE18_6:;					
            LC114AE18_6:
            ; //_A0FBC1636_18:;					
            _A0FBC1636_18:
            ; //_A0FBC1636_19:;					
            _A0FBC1636_19:
            ; //	asm	io[ClrWDT] = AR			
00152:      	io[ClrWDT] = AR
            ; //	
            ; //_A0FBC1636_20:;					
            _A0FBC1636_20:
            ; //_A0FBC1636_21:;					
            _A0FBC1636_21:
            ; //	sAX	= 0x0064;			
00153:      	AX	= 0x64
            ; //	PUSH(sAX);				
00154:      	push	AX
            ; //	_delay6F9F34ED(STACK[sSP + 0]);		
00155:      	pch	= _delay6F9F34ED
00156:      	lcall	_delay6F9F34ED
            ; //	RESTORESP(1);				
00157:      	pop	AR
            ; //_A0FBC1636_22:;					
            _A0FBC1636_22:
            ; //_A0FBC1636_23:;					
            _A0FBC1636_23:
            ; //	sSI	= (int)&_i_1_2;			
00158:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00159:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0015A:      	push	AX
            ; //	sAX	= 0x0007;			
0015B:      	AX	= 0x07
            ; //	PUSH(sAX);				
0015C:      	push	AX
            ; //	outp(STACK[sSP + 0], STACK[sSP + 1]);	
0015D:      	pch	= outp
0015E:      	lcall	outp
            ; //	RESTORESP(2);				
0015F:      	pop	AR
00160:      	pop	AR
            ; //_A0FBC1636_24:;					
            _A0FBC1636_24:
            ; //	sSI	= (int)&_i_1_2;			
00161:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00162:      	AX	= rm[I1]
            ; //	sCX	= 0x000F;			
00163:      	CX	= 0x0F
            ; //	sfx_CMP_AX_CX_JL();			
00164:      	pch	= sfx_CMP_AX_CX_JL
00165:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LC114AE18_8;	
00166:      	if ZR	jmp LC114AE18_8
            ; //	goto	LC114AE18_7;			
00167:      	pch =	LC114AE18_7
00168:      	ljmp	LC114AE18_7
            ; //LC114AE18_8:;					
            LC114AE18_8:
            ; //_A0FBC1636_25:;					
            _A0FBC1636_25:
            ; //	sSI	= (int)&_i_1_2;			
00169:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0016A:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0016B:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0016C:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0016D:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
0016E:      	rm[I1] = CX + AR//
            ; //	goto LC114AE18_9;			
0016F:      	pch =	LC114AE18_9
00170:      	ljmp	LC114AE18_9
            ; //LC114AE18_7:;					
            LC114AE18_7:
            ; //_A0FBC1636_26:;					
            _A0FBC1636_26:
            ; //	_i_1_2+0	= 0x00;			
00171:      	I1	= rm[BP_SAVE]
00172:      	AX	= 0x00
00173:      	rm[I1]	= AX
            ; //LC114AE18_9:;					
            LC114AE18_9:
            ; //_A0FBC1636_27:;					
            _A0FBC1636_27:
            ; //_A0FBC1636_28:;					
            _A0FBC1636_28:
            ; //	goto LC114AE18_6;			
00174:      	pch =	LC114AE18_6
00175:      	ljmp	LC114AE18_6
            ; //LC114AE18_5:;					
            LC114AE18_5:
            ; //LC114AE18_4:;					
            LC114AE18_4:
            ; //_A0FBC1636_29:;					
            _A0FBC1636_29:
            ; //	return;					
00176:      	AR	= 1
00177:      	BP	+= AR
00178:      	pop	AR
00179:      	rm[BP_SAVE]	= AR
0017A:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A0FBC1636_30:;					
            _A0FBC1636_30:
            ; //}
            ; //
            ; //void _InitialDA4A7CC4()				
            _InitialDA4A7CC4:
            ; //{
            ; //_A0FBC1636_31:;					
            _A0FBC1636_31:
            ; //	
            ; //_A0FBC1636_32:;					
            _A0FBC1636_32:
            ; //	sAX	= 0x003F;			
0017B:      	AX	= 0x3F
            ; //_A0FBC1636_33:;					
            _A0FBC1636_33:
            ; //	asm	AR = AX				
0017C:      	AR = AX
            ; //_A0FBC1636_34:;					
            _A0FBC1636_34:
            ; //	asm	FLTG = AR			
0017D:      	FLTG = AR
            ; //	
            ; //	
            ; //_A0FBC1636_35:;					
            _A0FBC1636_35:
            ; //	sAX	= 0x1FFF;			
0017E:      	AX	= 0x1FFF
            ; //_A0FBC1636_36:;					
            _A0FBC1636_36:
            ; //	asm	AR = AX				
00180:      	AR = AX
            ; //_A0FBC1636_37:;					
            _A0FBC1636_37:
            ; //	asm	FLTP = AR			
00181:      	FLTP = AR
            ; //	
            ; //	
            ; //_A0FBC1636_38:;					
            _A0FBC1636_38:
            ; //	sAX	= 0x0008;			
00182:      	AX	= 0x08
            ; //_A0FBC1636_39:;					
            _A0FBC1636_39:
            ; //	asm	AR = AX				
00183:      	AR = AX
            ; //_A0FBC1636_40:;					
            _A0FBC1636_40:
            ; //	asm	CBL = AR			
00184:      	CBL = AR
            ; //	
            ; //_A0FBC1636_41:;					
            _A0FBC1636_41:
            ; //	asm	set io[INTENA].b0		
00185:      	set io[INTENA].b0
            ; //_A0FBC1636_42:;					
            _A0FBC1636_42:
            ; //	asm	eni				
00186:      	eni
            ; //	
            ; //_A0FBC1636_43:;					
            _A0FBC1636_43:
            ; //	sAX	= 0x000F;			
00187:      	AX	= 0x0F
            ; //_A0FBC1636_44:;					
            _A0FBC1636_44:
            ; //	asm	AR = AX				
00188:      	AR = AX
            ; //_A0FBC1636_45:;					
            _A0FBC1636_45:
            ; //	asm	io[IOC_PA] = AR			
00189:      	io[IOC_PA] = AR
            ; //	
            ; //	
            ; //_A0FBC1636_46:;					
            _A0FBC1636_46:
            ; //_A0FBC1636_47:;					
            _A0FBC1636_47:
            ; //	_ClearTickCount5DDE4003();		
0018A:      	pch	= _ClearTickCount5DDE4003
0018B:      	lcall	_ClearTickCount5DDE4003
            ; //LC114AE18_10:;					
            LC114AE18_10:
            ; //_A0FBC1636_48:;					
            _A0FBC1636_48:
            ; //	return;					
0018C:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A0FBC1636_49:;					
            _A0FBC1636_49:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\A_5C91FC9D.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\OUTP.ASM> Start=========================
            
            ; ~~ --------------------------
            ; int outp(unsigned int port, unsigned int value)
            outp:
0018D:      	AR=		BP
0018E:      	AR=		AR + 1		; ~~ port
0018F:      	I1=		AR
00190:      	AR=		rm[I1++]
00191:      	AR=		AR & 0x1F
            
            #ifdef _MSPEECHDSP_	
            	P1=		#outp_00
            #else	
00192:      	P1=		#outp_00
00195:      	P1.hh=		0
            #endif
            
00196:      	slz		AR, 1
00197:      	P1=		P1 + AR
00198:      	AR=		rm[I1]
00199:      	fjmp		pm[P1]
            outp_00:
0019A:      	io[0x00]=	AR
0019B:      	rets
            outp_01:
0019C:      	io[0x01]=	AR
0019D:      	rets
            outp_02:
0019E:      	io[0x02]=	AR
0019F:      	rets
            outp_03:
001A0:      	io[0x03]=	AR
001A1:      	rets
            outp_04:
001A2:      	io[0x04]=	AR
001A3:      	rets
            outp_05:
001A4:      	io[0x05]=	AR
001A5:      	rets
            outp_06:
001A6:      	io[0x06]=	AR
001A7:      	rets
            outp_07:
001A8:      	io[0x07]=	AR
001A9:      	rets
            outp_08:
001AA:      	io[0x08]=	AR
001AB:      	rets
            outp_09:
001AC:      	io[0x09]=	AR
001AD:      	rets
            outp_0A:
001AE:      	io[0x0A]=	AR
001AF:      	rets
            outp_0B:
001B0:      	io[0x0B]=	AR
001B1:      	rets
            outp_0C:
001B2:      	io[0x0C]=	AR
001B3:      	rets
            outp_0D:
001B4:      	io[0x0D]=	AR
001B5:      	rets
            outp_0E:
001B6:      	io[0x0E]=	AR
001B7:      	rets
            outp_0F:
001B8:      	io[0x0F]=	AR
001B9:      	rets
            outp_10:
001BA:      	io[0x10]=	AR
001BB:      	rets
            outp_11:
001BC:      	io[0x11]=	AR
001BD:      	rets
            outp_12:
001BE:      	io[0x12]=	AR
001BF:      	rets
            outp_13:
001C0:      	io[0x13]=	AR
001C1:      	rets
            outp_14:
001C2:      	io[0x14]=	AR
001C3:      	rets
            outp_15:
001C4:      	io[0x15]=	AR
001C5:      	rets
            outp_16:
001C6:      	io[0x16]=	AR
001C7:      	rets
            outp_17:
001C8:      	io[0x17]=	AR
001C9:      	rets
            outp_18:
001CA:      	io[0x18]=	AR
001CB:      	rets
            outp_19:
001CC:      	io[0x19]=	AR
001CD:      	rets
            outp_1A:
001CE:      	io[0x1A]=	AR
001CF:      	rets
            outp_1B:
            #ifndef _MSPEECHDSP2_
            	io[0x1B]=	AR
            #endif
001D0:      	rets
            outp_1C:
            	;~ io[0x1C]=	AR
001D1:      	nop
001D2:      	rets
            outp_1D:
001D3:      	io[0x1D]=	AR
001D4:      	rets
            outp_1E:
001D5:      	io[0x1E]=	AR
001D6:      	rets
            outp_1F:
001D7:      	io[0x1F]=	AR
001D8:      	rets
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\OUTP.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> Start=========================
            
            
            _ClearTickCount5DDE4003:
            #ifdef _MFDSP_
            	set		io[MISC].b8
            #else
001D9:      	set		io[MISC].b7
            #endif
001DA:      	set		io[MISC].b15
            	
001DB:      	io[REAL_T]=	AR
001DC:      	AR=		io[REAL_T]
001DD:      	AR=		io[REAL_T]
001DE:      	io[REAL_T]=	AR
001DF:      	rets
            
            ; -----------------------------------------------
            
            _GetTickCount18DC070C:
001E0:      	AX=		0xFFF0
            @gettickcount_loop_1000:
001E2:      	io[ClrWDT]=	AR
001E3:      	AR=		io[REAL_T]
001E4:      	AR=		AR & AX
001E5:      	SF=		AR - AX
001E6:      	if ZR jmp	@gettickcount_loop_1000
001E7:      	AX=		AR
001E8:      	AR=		io[REAL_T]
001E9:      	DX=		AR
001EA:      	rets
            
            	
            ; -----------------------------------------------
            ; void delay(int ms)
            ;
            ; in:
            ;     BP + 1 - int ms
            ;
            ; -----------------------------------------------
            _delay6F9F34ED:
            ; {
001EB:      	AR=		BP
001EC:      	AR=		AR + 1		; ~~ port
001ED:      	I1=		AR
            
            	; unsigned long tick;
            	; unsigned long msr;
            
            	; ~~ 1ms = 32768 ticks
            
            	; msr = (unsigned long)ms << 15;
001EE:      		R0=		0
001EF:      		R1=		rm[I1]
001F0:      		clr		C
001F1:      		src		R1, 1
001F2:      		src		R0, 1
            	
            	; tick = GetTickCount();
001F3:      		call		_GetTickCount18DC070C
001F4:      		AR=		AX
001F5:      		CX=		AR
001F6:      		AR=		DX
001F7:      		BX=		AR
            	
            	; while((GetTickCount() - tick) < msr);
            	@delay_loop_1024:
001F8:      		call		_GetTickCount18DC070C
001F9:      		AR=		CX
001FA:      		AX=		AX - AR
001FB:      		AR=		BX
001FC:      		DX=		DX - AR + C - 1
001FD:      		AR=		R0
001FE:      		AX=		AX - AR
001FF:      		AR=		R1
00200:      		DX=		DX - AR + C - 1
00201:      		AR=		0
00202:      		AR=		AR - 0 + C - 1
00203:      		if AN jmp	@delay_loop_1024
            
00204:      	rets
            ; }
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> End=========================
            
            ;=========================Include <DEPS\34867077_GINIT.S.CODE.ASM> Start=========================
            ; 34867077_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	return;					
00205:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\34867077_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
00206:      	P1.hh=		0
00207:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
00208:      	AR=		pm[P1++]
00209:      	rm[I1++]=	AR
            @glinit_label_1409:
0020A:      	loop		@glinit_loop_1409
0020B:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
0020C:      	AR=		AX
0020D:      	MX=		AR
0020E:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0020F:      	MACOP=		3
00210:      	MR=		MX * AR
            #endif
            
00211:      	AR=		MR0
00212:      	AX=		AR
00213:      	AR=		MR1
00214:      	DX=		AR
00215:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
00216:      	AR=		AX
00217:      	MX=		AR
00218:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00219:      	MACOP=		0
0021A:      	MR=		MX * AR
            #endif
            
0021B:      	AR=		MR0
0021C:      	AX=		AR
0021D:      	AR=		MR1
0021E:      	DX=		AR
0021F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
00220:      	AR=		rm[BP_SAVE]
00221:      	push		AR
00222:      	AR=		BP
00223:      	rm[BP_SAVE]=	AR
00224:      	AR=		AR - 3
00225:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00226:      	AR=		CX
00227:      	MX=		AR
00228:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00229:      	MACOP=		3		; unsigned
0022A:      	MR=		MX * AR
            #endif
            
0022B:      	I1=		rm[BP_SAVE]
0022C:      	AR=		2
0022D:      	I1=		I1 - AR
0022E:      	rm[I1++]=	MR0
0022F:      	rm[I1++]=	MR1
00230:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00231:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
00232:      	MACOP=		1		; mx:unsigned / my:signed
00233:      	MR=		MX * AR
            #endif
            
00234:      	AR=		rm[I1]
00235:      	AR=		AR + MR0
00236:      	rm[I1++]=	AR
00237:      	AR=		rm[I1]
00238:      	AR=		AR + MR1 + C
00239:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
0023A:      	AR=		BX
0023B:      	MX=		AR
0023C:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
0023D:      	MACOP=		2		; mx:signed / my:unsigned
0023E:      	MR=		MX * AR
            #endif
            
0023F:      	AR=		rm[I1]
00240:      	AR=		AR + MR0
00241:      	rm[I1++]=	AR
00242:      	AR=		rm[I1]
00243:      	AR=		AR + MR1 + C
00244:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00245:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00246:      	MACOP=		0		; mx:signed / my:signed
00247:      	MR=		MX * AR
            #endif
            
00248:      	AR=		rm[I1]
00249:      	AR=		AR + MR0
0024A:      	rm[I1]=		AR
            
0024B:      	I1=		rm[BP_SAVE]
0024C:      	CX=		rm[I1--]
0024D:      	DX=		rm[I1--]
0024E:      	AX=		rm[I1]
            
0024F:      	AR=		3
00250:      	BP=		BP + AR
00251:      	pop		AR
00252:      	rm[BP_SAVE]=	AR
            
00253:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
00254:      	AR=		rm[BP_SAVE]
00255:      	push		AR
00256:      	AR=		BP
00257:      	rm[BP_SAVE]=	AR
00258:      	AR=		AR - 3
00259:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
0025A:      	AR=		CX
0025B:      	MX=		AR
0025C:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0025D:      	MACOP=		3		; unsigned
0025E:      	MR=		MX * AR
            #endif
            
0025F:      	I1=		rm[BP_SAVE]
00260:      	AR=		2
00261:      	I1=		I1 - AR
00262:      	rm[I1++]=	MR0
00263:      	rm[I1++]=	MR1
00264:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00265:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00266:      	MR=		MX * AR
            #endif
            
00267:      	AR=		rm[I1]
00268:      	AR=		AR + MR0
00269:      	rm[I1++]=	AR
0026A:      	AR=		rm[I1]
0026B:      	AR=		AR + MR1 + C
0026C:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
0026D:      	AR=		BX
0026E:      	MX=		AR
0026F:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00270:      	MR=		MX * AR
            #endif
            
00271:      	AR=		rm[I1]
00272:      	AR=		AR + MR0
00273:      	rm[I1++]=	AR
00274:      	AR=		rm[I1]
00275:      	AR=		AR + MR1 + C
00276:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00277:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00278:      	MR=		MX * AR
            #endif
            
00279:      	AR=		rm[I1]
0027A:      	AR=		AR + MR0
0027B:      	rm[I1]=		AR
            
0027C:      	I1=		rm[BP_SAVE]
0027D:      	CX=		rm[I1--]
0027E:      	DX=		rm[I1--]
0027F:      	AX=		rm[I1]
            
00280:      	AR=		3
00281:      	BP=		BP + AR
00282:      	pop		AR
00283:      	rm[BP_SAVE]=	AR
            
00284:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
00285:      		DX=		0
            	; unsigned char count = 16;
00286:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00287:      			slz		AX, 1
            		; reste <<= 1;
00288:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00289:      			AR=		DX
0028A:      			AR-=		CX
0028B:      			AR=		0
0028C:      			AR=		AR - 0 + C - 1
0028D:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
0028E:      				AR=		CX
0028F:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00290:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
00291:      		R0--
00292:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
00293:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
00294:      		R1=		0
00295:      		AR=		0
00296:      		test		AX.b15
00297:      		if ZR jmp	@divsword_label_1833
00298:      			AX=		AR - AX
00299:      			set		R1.b0
            		@divsword_label_1833:
0029A:      		test		CX.b15
0029B:      		if ZR jmp	@divsword_label_1834
0029C:      			CX=		AR - CX
0029D:      			set		R1.b1
            		@divsword_label_1834:
0029E:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
0029F:      		AR=		R1
002A0:      		slz		AR, 1
002A1:      		AR^=		R1
002A2:      		test		AR.b1
002A3:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
002A4:      			AR=		0
002A5:      			AX=		AR - AX
002A6:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
002A7:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
002A8:      		R0=		0	; L
002A9:      		R1=		0	; H
            	; unsigned char count = 32;
002AA:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
002AB:      			slz		AX, 1
002AC:      			slc		DX, 1
            		; reste <<= 1;
002AD:      			slc		R0, 1
002AE:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
002AF:      			AR=		R0
002B0:      			AR-=		CX
002B1:      			AR=		R1
002B2:      			AR=		AR - BX + C - 1
002B3:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
002B4:      				AR=		CX
002B5:      				R0=		R0 - AR
002B6:      				AR=		BX
002B7:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
002B8:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
002B9:      		R2--
002BA:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
002BB:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
002BC:      		R3=		0
002BD:      		AR=		0
002BE:      		test		DX.b15
002BF:      		if ZR jmp	@divslong_label_1759
002C0:      			AX=		AR - AX
002C1:      			DX=		AR - DX + C - 1
002C2:      			set		R3.b0
            		@divslong_label_1759:
002C3:      		test		BX.b15
002C4:      		if ZR jmp	@divslong_label_1800
002C5:      			CX=		AR - CX
002C6:      			BX=		AR - BX + C - 1
002C7:      			set		R3.b1
            		@divslong_label_1800:
002C8:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
002C9:      		AR=		R3
002CA:      		slz		AR, 1
002CB:      		AR^=		R3
002CC:      		test		AR.b1
002CD:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
002CE:      			AR=		0
002CF:      			AX=		AR - AX
002D0:      			DX=		AR - DX + C - 1
002D1:      			R0=		AR - R0
002D2:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
002D3:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
002D4:      	call		sfx_DIV_AX_CX
002D5:      	AR=		DX
002D6:      	AX=		AR
002D7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
002D8:      	call		sfx_IDIV_AX_CX
002D9:      	AR=		DX
002DA:      	AX=		AR
002DB:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
002DC:      	call		sfx_DIVLONG
002DD:      	AR=		R0
002DE:      	AX=		AR
002DF:      	AR=		R1
002E0:      	DX=		AR
002E1:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
002E2:      	call		sfx_IDIVLONG
002E3:      	AR=		R0
002E4:      	AX=		AR
002E5:      	AR=		R1
002E6:      	DX=		AR
002E7:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
002E8:      	AR=		AX
002E9:      	P1=		P1 + AR
002EA:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
002EB:      	AR=		AX
002EC:      	I1=		I1 + AR
002ED:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
002EE:      	AR=		CX
002EF:      	AX=		AX + AR
002F0:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
002F1:      	AR=		AX
002F2:      	P1=		P1 - AR
002F3:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
002F4:      	AR=		AX
002F5:      	I1=		I1 - AR
002F6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
002F7:      	AR=		CX
002F8:      	AX=		AX + AR
002F9:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
002FA:      	pm[P1++]=	AX
002FB:      	pm[P1--]=	DX
002FC:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
002FD:      	pm[P1++]=	CX
002FE:      	pm[P1--]=	BX
002FF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
00300:      	BX=		0
00301:      	CX.h=		0
00302:      	test		CX.b7
00303:      	if ZR jmp	@c2lcx_label_1800
00304:      	CX.h=		0xFF
00305:      	BX=		-1
            @c2lcx_label_1800:
00306:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
00307:      	DX=		0
00308:      	AX.h=		0
00309:      	test		AX.b7
0030A:      	if ZR jmp	@c2lax_label_1800
0030B:      	AX.h=		0xFF
0030C:      	DX=		-1
            @c2lax_label_1800:
0030D:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
0030E:      	push		AX
0030F:      	push		CX
00310:      	pop		AX
00311:      	pop		CX
00312:      	push		DX
00313:      	push		BX
00314:      	pop		DX
00315:      	pop		BX
00316:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
00317:      	AR=		DX
00318:      	DX=		0
00319:      	AR=		AR | AX
0031A:      	AX=		1
0031B:      	if ZR jmp	@longnotl_label_1120
0031C:      	AX=		0
            @longnotl_label_1120:
0031D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
0031E:      	DX=		0
0031F:      	BX=		0
            sfx_CMPLONG_JNE:
00320:      	AR=		CX
00321:      	AX=		AX - AR
00322:      	AR=		BX
00323:      	AR=		DX - AR + C - 1
00324:      	AR=		AR | AX
00325:      	if EQ jmp	@sfx_cl_jne_f
00326:      	set		Z		; true
00327:      	rets
            @sfx_cl_jne_f:
00328:      	clr		Z		; false
00329:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
0032A:      	DX=		0
0032B:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
0032C:      	AR=		AX
0032D:      	CX=		CX - AR
0032E:      	AR=		DX
0032F:      	AR=		BX - AR + C - 1
00330:      	AR=		AR | CX
00331:      	if EQ jmp	@sfx_clbcda_jne_f
00332:      	set		Z		; true
00333:      	rets
            @sfx_clbcda_jne_f:
00334:      	clr		Z		; false
00335:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
00336:      	AR=		CX
00337:      	SF=		AX - AR
00338:      	if EQ jmp	@sfx_ac_jne_f
00339:      	set		Z
0033A:      	rets
            @sfx_ac_jne_f:
0033B:      	clr		Z
0033C:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
0033D:      	AR=		AX
0033E:      	SF=		CX - AR
0033F:      	if EQ jmp	@sfx_ca_jne_f
00340:      	set		Z
00341:      	rets
            @sfx_ca_jne_f:
00342:      	clr		Z
00343:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
00344:      	DX=		0
00345:      	BX=		0
            sfx_CMPLONG_JE:
00346:      	AR=		CX
00347:      	AX=		AX - AR
00348:      	AR=		BX
00349:      	AR=		DX - AR + C - 1
0034A:      	AR=		AR | AX
0034B:      	if NE jmp	@sfx_cl_jz_f
0034C:      	set		Z		; true
0034D:      	rets
            @sfx_cl_jz_f:
0034E:      	clr		Z		; false
0034F:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00350:      	DX=		0
00351:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
00352:      	AR=		AX
00353:      	CX=		CX - AR
00354:      	AR=		DX
00355:      	AR=		BX - AR + C - 1
00356:      	AR=		AR | CX
00357:      	if NE jmp	@sfx_clbcda_jz_f
00358:      	set		Z		; true
00359:      	rets
            @sfx_clbcda_jz_f:
0035A:      	clr		Z		; false
0035B:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
0035C:      	DX=		0
0035D:      	BX=		0
            sfx_CMPLONG_JG:
0035E:      	AR=		CX
0035F:      	AX=		AX - AR
00360:      	AR=		BX
00361:      	AR=		DX - AR + C - 1
00362:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
00363:      	AR=		AR | AX
00364:      	if ZR jmp	@sfx_cl_jg_f
            
00365:      	set		Z		; true
00366:      	rets
            @sfx_cl_jg_f:
00367:      	clr		Z		; false
00368:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
00369:      	AR=		CX
0036A:      	AX=		AX - AR
0036B:      	AR=		BX
0036C:      	DX=		DX - AR + C - 1
0036D:      	AR=		0
0036E:      	AR=		AR - 0 + C - 1
0036F:      	if AN jmp	@sfx_cl_jg_f
            
00370:      	AR=		AR | DX		; exclude EQU condition
00371:      	AR=		AR | AX
00372:      	if ZR jmp	@sfx_cl_jg_f
            
00373:      	set		Z		; true
00374:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
00375:      	DX=		0
00376:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
00377:      	AR=		AX
00378:      	CX=		CX - AR
00379:      	AR=		DX
0037A:      	AR=		BX - AR + C - 1
0037B:      	if AN jmp	@sfx_clbcda_jg_f
            
0037C:      	AR=		AR | CX		; exclude EQU condition
0037D:      	if ZR jmp	@sfx_clbcda_jg_f
            
0037E:      	set		Z		; true
0037F:      	rets
            @sfx_clbcda_jg_f:
00380:      	clr		Z		; false
00381:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00382:      	AR=		AX
00383:      	CX=		CX - AR
00384:      	AR=		DX
00385:      	BX=		BX - AR + C - 1
00386:      	AR=		0
00387:      	AR=		AR - 0 + C - 1
00388:      	if AN jmp	@sfx_clbcda_jg_f
            
00389:      	AR=		AR | BX		; exclude EQU condition
0038A:      	AR=		AR | CX
0038B:      	if ZR jmp	@sfx_clbcda_jg_f
            
0038C:      	set		Z		; true
0038D:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
0038E:      	AR=		CX
0038F:      	SF=		AX - AR
00390:      	if LE jmp	@sfx_cmp_ac_jg_f
00391:      	set		Z
00392:      	rets
            @sfx_cmp_ac_jg_f:
00393:      	clr		Z
00394:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
00395:      	AR=		AX
00396:      	SF=		CX - AR
00397:      	if LE jmp	@sfx_cmp_ca_jg_f
00398:      	set		Z
00399:      	rets
            @sfx_cmp_ca_jg_f:
0039A:      	clr		Z
0039B:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
0039C:      	DX=		0
0039D:      	BX=		0
            sfx_CMPLONG_JGE:
0039E:      	AR=		CX
0039F:      	AX=		AX - AR
003A0:      	AR=		BX
003A1:      	DX=		DX - AR + C - 1
003A2:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
003A3:      	set		Z		; true
003A4:      	rets
            @sfx_cl_jge_f:
003A5:      	clr		Z		; false
003A6:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
003A7:      	AR=		CX
003A8:      	AX=		AX - AR
003A9:      	AR=		BX
003AA:      	DX=		DX - AR + C - 1
003AB:      	AR=		0
003AC:      	AR=		AR - 0 + C - 1
003AD:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
003AE:      	set		Z		; true
003AF:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
003B0:      	DX=		0
003B1:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
003B2:      	AR=		AX
003B3:      	CX=		CX - AR
003B4:      	AR=		DX
003B5:      	BX=		BX - AR + C - 1
003B6:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
003B7:      	set		Z		; true
003B8:      	rets
            @sfx_clbcda_jge_f:
003B9:      	clr		Z		; false
003BA:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
003BB:      	AR=		AX
003BC:      	CX=		CX - AR
003BD:      	AR=		DX
003BE:      	BX=		BX - AR + C - 1
003BF:      	AR=		0
003C0:      	AR=		AR - 0 + C - 1
003C1:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
003C2:      	set		Z		; true
003C3:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
003C4:      	AR=		CX
003C5:      	SF=		AX - AR
003C6:      	if AN jmp	@sfx_cmp_ac_jge_f
003C7:      	set		Z
003C8:      	rets
            @sfx_cmp_ac_jge_f:
003C9:      	clr		Z
003CA:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
003CB:      	AR=		AX
003CC:      	SF=		CX - AR
003CD:      	if AN jmp	@sfx_cmp_ca_jge_f
003CE:      	set		Z
003CF:      	rets
            @sfx_cmp_ca_jge_f:
003D0:      	clr		Z
003D1:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
003D2:      	DX=		0
003D3:      	BX=		0
            sfx_CMPLONG_JL:
003D4:      	AR=		CX
003D5:      	AX=		AX - AR
003D6:      	AR=		BX
003D7:      	AR=		DX - AR + C - 1
003D8:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
003D9:      	clr		Z		; false
003DA:      	rets
            
            @sfx_cl_jl_chk:
003DB:      	AR=		AR | AX		; exclude EQU condition
003DC:      	if ZR jmp	@sfx_cl_jl_f
003DD:      	set		Z
003DE:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
003DF:      	AR=		CX
003E0:      	AX=		AX - AR
003E1:      	AR=		BX
003E2:      	DX=		DX - AR + C - 1
003E3:      	AR=		0
003E4:      	AR=		AR - 0 + C - 1
003E5:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
003E6:      	clr		Z		; false
003E7:      	rets
            
            @sfx_cl_jb_chk:
003E8:      	AR=		AR | DX
003E9:      	AR=		AR | AX		; exclude EQU condition
003EA:      	if ZR jmp	@sfx_cl_jb_f
003EB:      	set		Z
003EC:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
003ED:      	DX=		0
003EE:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
003EF:      	AR=		AX
003F0:      	CX=		CX - AR
003F1:      	AR=		DX
003F2:      	AR=		BX - AR + C - 1
003F3:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
003F4:      	clr		Z		; false
003F5:      	rets
            
            @sfx_clbcda_jl_chk:
003F6:      	AR=		AR | CX		; exclude EQU condition
003F7:      	if ZR jmp	@sfx_clbcda_jl_f
003F8:      	set		Z		; true
003F9:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
003FA:      	AR=		AX
003FB:      	CX=		CX - AR
003FC:      	AR=		DX
003FD:      	BX=		BX - AR + C - 1
003FE:      	AR=		0
003FF:      	AR=		AR - 0 + C - 1
00400:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
00401:      	clr		Z		; false
00402:      	rets
            
            @sfx_clbcda_jb_chk:
00403:      	AR=		AR | CX
00404:      	AR=		AR | BX
00405:      	if ZR jmp	@sfx_clbcda_jb_f
00406:      	set		Z		; true
00407:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
00408:      	AR=		CX
00409:      	SF=		AX - AR
0040A:      	if GE jmp	@sfx_cmp_ac_jl_f
0040B:      	set		Z
0040C:      	rets
            @sfx_cmp_ac_jl_f:
0040D:      	clr		Z
0040E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
0040F:      	AR=		AX
00410:      	SF=		CX - AR
00411:      	if GE jmp	@sfx_cmp_ca_jl_f
00412:      	set		Z
00413:      	rets
            @sfx_cmp_ca_jl_f:
00414:      	clr		Z
00415:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
00416:      	DX=		0
00417:      	BX=		0
            sfx_CMPLONG_JLE:
00418:      	AR=		CX
00419:      	AX=		AX - AR
0041A:      	AR=		BX
0041B:      	AR=		DX - AR + C - 1
0041C:      	if AN jmp	@sfx_cl_jle_t
            
0041D:      	AR=		AR | AX		; include EQU condition
0041E:      	if ZR jmp	@sfx_cl_jle_t
            
0041F:      	clr		Z		; false
00420:      	rets
            @sfx_cl_jle_t:
00421:      	set		Z		; true
00422:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
00423:      	AR=		CX
00424:      	AX=		AX - AR
00425:      	AR=		BX
00426:      	DX=		DX - AR + C - 1
00427:      	AR=		0
00428:      	AR=		AR - 0 + C - 1
00429:      	if AN jmp	@sfx_cl_jle_t
            
0042A:      	AR=		AR | DX
0042B:      	AR=		AR | AX
0042C:      	if ZR jmp	@sfx_cl_jle_t
            
0042D:      	clr		Z		; false
0042E:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
0042F:      	DX=		0
00430:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00431:      	AR=		AX
00432:      	CX=		CX - AR
00433:      	AR=		DX
00434:      	AR=		BX - AR + C - 1
00435:      	if AN jmp	@sfx_clbcda_jle_t
            
00436:      	AR=		AR | CX		; include EQU condition
00437:      	if ZR jmp	@sfx_clbcda_jle_t
            
00438:      	clr		Z		; false
00439:      	rets
            @sfx_clbcda_jle_t:
0043A:      	set		Z		; true
0043B:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
0043C:      	AR=		AX
0043D:      	CX=		CX - AR
0043E:      	AR=		DX
0043F:      	BX=		BX - AR + C - 1
00440:      	AR=		0
00441:      	AR=		AR - 0 + C - 1
00442:      	if AN jmp	@sfx_clbcda_jle_t
            
00443:      	AR=		AR | BX
00444:      	AR=		AR | CX
00445:      	if ZR jmp	@sfx_clbcda_jle_t
            
00446:      	clr		Z		; false
00447:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
00448:      	AR=		CX
00449:      	SF=		AX - AR
0044A:      	if LE jmp	@sfx_cmp_ac_jl_t
0044B:      	clr		Z
0044C:      	rets
            @sfx_cmp_ac_jl_t:
0044D:      	set		Z
0044E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
0044F:      	AR=		AX
00450:      	SF=		CX - AR
00451:      	if LE jmp	@sfx_cmp_ca_jl_t
00452:      	clr		Z
00453:      	rets
            @sfx_cmp_ca_jl_t:
00454:      	set		Z
00455:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
00456:      	DW 0xFFFE
            @sfx_ortable_1:
00457:      	DW 0xFFFC
            @sfx_ortable_2:
00458:      	DW 0xFFF8
            @sfx_ortable_3:
00459:      	DW 0xFFF0
            @sfx_ortable_4:
0045A:      	DW 0xFFE0
            @sfx_ortable_5:
0045B:      	DW 0xFFC0
            @sfx_ortable_6:
0045C:      	DW 0xFF80
            @sfx_ortable_7:
0045D:      	DW 0xFF00
            @sfx_ortable_8:
0045E:      	DW 0xFE00
            @sfx_ortable_9:
0045F:      	DW 0xFC00
            @sfx_ortable_10:
00460:      	DW 0xF800
            @sfx_ortable_11:
00461:      	DW 0xF000
            @sfx_ortable_12:
00462:      	DW 0xE000
            @sfx_ortable_13:
00463:      	DW 0xC000
            @sfx_ortable_14:
00464:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
00465:      	AR=		pm[P1]
00466:      	DX=		DX | AR
00467:      	rets
            
            @sfx_orhigh_dx:
00468:      	DX=		-1
            @sfx_orlow:
00469:      	AR=		pm[P1]
0046A:      	AX=		AX | AR
            @sfx_sextw_rets:
0046B:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
0046C:      	P1=		#@sfx_ortable_0
0046F:      	test		AX.b0
00470:      	if ZR jmp	@sfx_sextw_rets
00471:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00472:      	P1=		#@sfx_ortable_1
00475:      	test		AX.b1
00476:      	if ZR jmp	@sfx_sextw_rets
00477:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
00478:      	P1=		#@sfx_ortable_2
0047B:      	test		AX.b2
0047C:      	if ZR jmp	@sfx_sextw_rets
0047D:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
0047E:      	P1=		#@sfx_ortable_3
00481:      	test		AX.b3
00482:      	if ZR jmp	@sfx_sextw_rets
00483:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
00484:      	P1=		#@sfx_ortable_4
00487:      	test		AX.b4
00488:      	if ZR jmp	@sfx_sextw_rets
00489:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
0048A:      	P1=		#@sfx_ortable_5
0048D:      	test		AX.b5
0048E:      	if ZR jmp	@sfx_sextw_rets
0048F:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00490:      	P1=		#@sfx_ortable_6
00493:      	test		AX.b6
00494:      	if ZR jmp	@sfx_sextw_rets
00495:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
00496:      	P1=		#@sfx_ortable_7
00499:      	test		AX.b7
0049A:      	if ZR jmp	@sfx_sextw_rets
0049B:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
0049C:      	P1=		#@sfx_ortable_8
0049F:      	test		AX.b8
004A0:      	if ZR jmp	@sfx_sextw_rets
004A1:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
004A2:      	P1=		#@sfx_ortable_9
004A5:      	test		AX.b9
004A6:      	if ZR jmp	@sfx_sextw_rets
004A7:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
004A8:      	P1=		#@sfx_ortable_10
004AB:      	test		AX.b10
004AC:      	if ZR jmp	@sfx_sextw_rets
004AD:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
004AE:      	P1=		#@sfx_ortable_11
004B1:      	test		AX.b11
004B2:      	if ZR jmp	@sfx_sextw_rets
004B3:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
004B4:      	P1=		#@sfx_ortable_12
004B7:      	test		AX.b12
004B8:      	if ZR jmp	@sfx_sextw_rets
004B9:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
004BA:      	P1=		#@sfx_ortable_13
004BD:      	test		AX.b13
004BE:      	if ZR jmp	@sfx_sextw_rets
004BF:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
004C0:      	P1=		#@sfx_ortable_14
004C3:      	test		AX.b14
004C4:      	if ZR jmp	@sfx_sextw_rets
004C5:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
004C6:      	P1=		#@sfx_ortable_0
004C9:      	test		AX.b0
004CA:      	if ZR jmp	@sfx_sextw_rets
004CB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
004CC:      	P1=		#@sfx_ortable_1
004CF:      	test		AX.b1
004D0:      	if ZR jmp	@sfx_sextw_rets
004D1:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
004D2:      	P1=		#@sfx_ortable_2
004D5:      	test		AX.b2
004D6:      	if ZR jmp	@sfx_sextw_rets
004D7:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
004D8:      	P1=		#@sfx_ortable_3
004DB:      	test		AX.b3
004DC:      	if ZR jmp	@sfx_sextw_rets
004DD:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
004DE:      	P1=		#@sfx_ortable_4
004E1:      	test		AX.b4
004E2:      	if ZR jmp	@sfx_sextw_rets
004E3:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
004E4:      	P1=		#@sfx_ortable_5
004E7:      	test		AX.b5
004E8:      	if ZR jmp	@sfx_sextw_rets
004E9:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
004EA:      	P1=		#@sfx_ortable_6
004ED:      	test		AX.b6
004EE:      	if ZR jmp	@sfx_sextw_rets
004EF:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
004F0:      	P1=		#@sfx_ortable_7
004F3:      	test		AX.b7
004F4:      	if ZR jmp	@sfx_sextw_rets
004F5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
004F6:      	P1=		#@sfx_ortable_8
004F9:      	test		AX.b8
004FA:      	if ZR jmp	@sfx_sextw_rets
004FB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
004FC:      	P1=		#@sfx_ortable_9
004FF:      	test		AX.b9
00500:      	if ZR jmp	@sfx_sextw_rets
00501:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
00502:      	P1=		#@sfx_ortable_10
00505:      	test		AX.b10
00506:      	if ZR jmp	@sfx_sextw_rets
00507:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
00508:      	P1=		#@sfx_ortable_11
0050B:      	test		AX.b11
0050C:      	if ZR jmp	@sfx_sextw_rets
0050D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
0050E:      	P1=		#@sfx_ortable_12
00511:      	test		AX.b12
00512:      	if ZR jmp	@sfx_sextw_rets
00513:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
00514:      	P1=		#@sfx_ortable_13
00517:      	test		AX.b13
00518:      	if ZR jmp	@sfx_sextw_rets
00519:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
0051A:      	P1=		#@sfx_ortable_14
0051D:      	test		AX.b14
0051E:      	if ZR jmp	@sfx_sextw_rets
0051F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
00520:      	test		AX.b15
00521:      	if ZR jmp	@sfx_sextw_rets
00522:      	DX=		-1
00523:      	rets
            
            sfx_SignExtL16:
00524:      	P1=		#@sfx_ortable_0
00527:      	test		DX.b0
00528:      	if ZR jmp	@sfx_sextw_rets
00529:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
0052A:      	P1=		#@sfx_ortable_1
0052D:      	test		DX.b1
0052E:      	if ZR jmp	@sfx_sextw_rets
0052F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00530:      	P1=		#@sfx_ortable_2
00533:      	test		DX.b2
00534:      	if ZR jmp	@sfx_sextw_rets
00535:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
00536:      	P1=		#@sfx_ortable_3
00539:      	test		DX.b3
0053A:      	if ZR jmp	@sfx_sextw_rets
0053B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
0053C:      	P1=		#@sfx_ortable_4
0053F:      	test		DX.b4
00540:      	if ZR jmp	@sfx_sextw_rets
00541:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00542:      	P1=		#@sfx_ortable_5
00545:      	test		DX.b5
00546:      	if ZR jmp	@sfx_sextw_rets
00547:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
00548:      	P1=		#@sfx_ortable_6
0054B:      	test		DX.b6
0054C:      	if ZR jmp	@sfx_sextw_rets
0054D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
0054E:      	P1=		#@sfx_ortable_7
00551:      	test		DX.b7
00552:      	if ZR jmp	@sfx_sextw_rets
00553:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
00554:      	P1=		#@sfx_ortable_8
00557:      	test		DX.b8
00558:      	if ZR jmp	@sfx_sextw_rets
00559:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
0055A:      	P1=		#@sfx_ortable_9
0055D:      	test		DX.b9
0055E:      	if ZR jmp	@sfx_sextw_rets
0055F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00560:      	P1=		#@sfx_ortable_10
00563:      	test		DX.b10
00564:      	if ZR jmp	@sfx_sextw_rets
00565:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
00566:      	P1=		#@sfx_ortable_11
00569:      	test		DX.b11
0056A:      	if ZR jmp	@sfx_sextw_rets
0056B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
0056C:      	P1=		#@sfx_ortable_12
0056F:      	test		DX.b12
00570:      	if ZR jmp	@sfx_sextw_rets
00571:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00572:      	P1=		#@sfx_ortable_13
00575:      	test		DX.b13
00576:      	if ZR jmp	@sfx_sextw_rets
00577:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
00578:      	P1=		#@sfx_ortable_14
0057B:      	test		DX.b14
0057C:      	if ZR jmp	@sfx_sextw_rets
0057D:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
0057E:      	push		I1
0057F:      	AR=		AX
00580:      	I1=		AR
00581:      	AR=		rm[I1]
00582:      	pop		I1
00583:      	rm[I1++]=	AR
00584:      	AX++
00585:      	loop		@sfx_repmov_ss_loop_1804
00586:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
00587:      	AR=		AX
00588:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00589:      	rm[I1++]=	pm[P1++]
0058A:      	loop		@sfx_repmov_sr_loop_1804
0058B:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
0058C:      	AR=		AX
0058D:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
0058E:      	AR=		rm[I1++]
0058F:      	pm[P1++]=	AR
00590:      	loop		@sfx_repmov_rs_loop_1804
00591:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00592:      	push		P1
00593:      	AR=		AX
00594:      	P1=		AR
00595:      	AR=		pm[P1]
00596:      	pop		P1
00597:      	pm[P1++]=	AR
00598:      	AX++
00599:      	loop		@sfx_repmov_rr_loop_1804
0059A:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\FP32RT.ASM> Start=========================
            
            ; ~~-----------------------------------------------------
            ; single precision number (32-bit) float point support for DSP
            ; -------------------------------------------------------
            
            ; -------------------------------------------------------
            ; ~~ porting from SDCC
            ; -------------------------------------------------------
            
            ; +-----------------------------------------------------+-------------------------------------------------+
            ; | DX (BX)                                             | AX (CX)                                         |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ; |  0   | 7  6  5  4  3  2  1  0 |22 21 20 19 18 17 16 | 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ; | sign | e  e  e  e  e  e  e  e | m  m  m  m  m  m  m |  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m |
            ; +------+------------------------+---------------------+-------------------------------------------------+
            ;    15   14 13 12 11 10  9  8  7   6  5  4  3  2  1  0   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            
            
            ; ~~ float -> sign / exp / mantissa
            
            ; ~~ DX:AX / BX:CX - mantissa [31:8]
            
            ; +-------------------------------------------------+--------------------------------------------------+
            ; | DX (BX)                                         | AX (CX)                                          |
            ; +---+---------------------------------------------+-------------------------+------------------------+
            ; | 1 | m  m  m  m  m  m  m  m  m  m  m  m  m  m  m | m  m  m  m  m  m  m  m  | 0  0  0  0  0  0  0  0 |
            ; +---+---------------------------------------------+-------------------------+------------------------+
            ;   H   22 21 20 19 18 17 16 15 14 13 12 11 10 9  8   7  6  5  4  3  2  1  0    -  -  -  -  -  -  -  -
            ;
            
            ; ~~ R0    / R1    - sign and exp
            ; +------------------------+------------------------+
            ; | S  -  -  -  -  -  -  - | e  e  e  e  e  e  e  e |
            ; +------------------------+------------------------+
            ;  15 14 13 12 11 10  9  8   7  6  5  4  3  2  1  0
            
            
            ; ~~ no shift
            
            sfx_GETARG_DANS_FS:
0059B:      	AR=		DX
0059C:      	slz		AR, 1		; ~~ C = sign
0059D:      	xchg		AR
0059E:      	AH=		0
0059F:      	R0=		AR
005A0:      	if NC jmp	@sfx_getarg_dafs_label_1736
005A1:      	set		R0.b15
            @sfx_getarg_dafs_label_1736:
005A2:      	AR=		0x7F
005A3:      	DX=		DX & AR
005A4:      	set		DX.b7		; ~~ HIDDEN 1
005A5:      	rets
            
            ; ~~ ----
            
            sfx_GETARG_DA_FS:
005A6:      	call		sfx_GETARG_DANS_FS
005A7:      	slz		AX, 2
005A8:      	slc		DX, 2
005A9:      	slz		AX, 2
005AA:      	slc		DX, 2
005AB:      	slz		AX, 2
005AC:      	slc		DX, 2
005AD:      	slz		AX, 2
005AE:      	slc		DX, 2
005AF:      	rets
            
            ; ~~ ----
            
            ; ~~ no shift
            
            sfx_GETARG_BCNS_FS:
005B0:      	AR=		BX
005B1:      	slz		AR, 1		; ~~ C = sign
005B2:      	xchg		AR
005B3:      	AH=		0
005B4:      	R1=		AR
005B5:      	if NC jmp	@sfx_getarg_bcfs_label_1736
005B6:      	set		R1.b15
            @sfx_getarg_bcfs_label_1736:
005B7:      	AR=		0x7F
005B8:      	BX=		BX & AR
005B9:      	set		BX.b7		; ~~ HIDDEN 1
005BA:      	rets
            
            ; ~~ ----
            
            sfx_GETARG_BC_FS:
005BB:      	call		sfx_GETARG_BCNS_FS
005BC:      	slz		CX, 2
005BD:      	slc		BX, 2
005BE:      	slz		CX, 2
005BF:      	slc		BX, 2
005C0:      	slz		CX, 2
005C1:      	slc		BX, 2
005C2:      	slz		CX, 2
005C3:      	slc		BX, 2
005C4:      	rets
            
            
            ; ~~ ----
            
            sfx_Normalize_DA_FS:
            ; {
005C5:      	push		CX
005C6:      	CX=		31
            @sfx_normalize_dafs_loop_1609:
005C7:      	test		DX.b15
005C8:      	if NZ jmp	@sfx_normalize_dafs_label_1609
005C9:      	slz		AX, 1
005CA:      	slc		DX, 1
005CB:      	R0--
005CC:      	AR=		R0
005CD:      	clr		AR.b15
005CE:      	if ZR jmp	@sfx_normalize_dafs_label_1609
005CF:      	loop		@sfx_normalize_dafs_loop_1609
            @sfx_normalize_dafs_label_1609:
005D0:      	pop		CX
005D1:      	rets
            ; }
            
            
            
            ; ~~ DX:AX - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_RoundRet_DA_FS:
            ; {
            	; ~~ for register save
            
            	; ~~ round lowest 8-bit to increase accuracy ??
            
            	; AR=		AX
            	; AH=		0
            	; AR=		AR + 0x80		; 0xFF80
            	; if LE jmp	@sfx_roundret_dafs_label_1033
            
            	; test		AX.b8
            	; if ZR jmp	@sfx_roundret_dafs_label_1033
            
            	; ~~ +1
            
005D2:      	AR=		0x0080
005D4:      	AX=		AX + AR
005D5:      	AR=		0
005D6:      	DX=		DX + AR + C
005D7:      	if NC jmp	@sfx_roundret_dafs_label_1033
            	; ~~ overflow
005D8:      	DX.h=		0x80
005D9:      	R0++
            @sfx_roundret_dafs_label_1033:
005DA:      	AR=		AX
005DB:      	AL=		0
005DC:      	AR=		AR | DX
005DD:      	if NZ jmp	sfx_DirectRet_DA_FS
            
            sfx_RetZero_DA_FS:
            	; ~~ float 0.0
005DE:      	AX=		0
005DF:      	DX=		0
005E0:      	rets
            
            
            sfx_DirectRet_DA_FS:
            	; ~~ drop 1-bit  (1.xxx)
005E1:      	slz		AX, 1
005E2:      	slc		DX, 1
            
            	; ~~ 8-bit exp
            
005E3:      	AR=		R0
005E4:      	sra		AR, 2
005E5:      	src		DX, 2
005E6:      	src		AX, 2
005E7:      	sra		AR, 2
005E8:      	src		DX, 2
005E9:      	src		AX, 2
005EA:      	sra		AR, 2
005EB:      	src		DX, 2
005EC:      	src		AX, 2
005ED:      	sra		AR, 2
005EE:      	src		DX, 2
005EF:      	src		AX, 2
            
005F0:      	slz		AR, 1		; ~~ sign bit (sra duplicate)
005F1:      	src		DX, 1
005F2:      	src		AX, 1
005F3:      	rets
            
            sfx_ReturnINF_DA_FS:
005F4:      	AX=		0
005F5:      	DX=		0xFF00
005F7:      	AR=		R0
005F8:      	slz		AR, 1
005F9:      	src		DX, 1
005FA:      	rets
            
            sfx_ReturnNaN_DA_FS:
005FB:      	AX=		0
005FC:      	DX=		0x7FC0
005FE:      	rets
            
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; --------------------------
            ; ~~ int type -> float point
            ; --------------------------
            
            
            ; --------------------------
            ; DX:AX		- in  (long)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_LONGTOFP32:
005FF:      	R0=		0x009E		; ~~ E+31
            
            sfx_LONG2FS_CORE:			; ~~ without exp
00601:      	test		DX.b15
00602:      	if ZR jmp	@sfx_long2fs_label_1004
            
            	; ~~ make it positive if value is negative
            
00603:      	set		R0.b15		; ~~ sign
00604:      	AR=		0
00605:      	AX=		AR - AX
00606:      	DX=		AR - DX + C - 1
            @sfx_long2fs_label_1004:
00607:      	call		sfx_Normalize_DA_FS
00608:      	jmp		sfx_RoundRet_DA_FS
            
            
            
            sfx_LONGTOFP32_BXCX:
00609:      	call		sfx_FP32SWAP
0060A:      	call		sfx_LONGTOFP32
0060B:      	call		sfx_FP32SWAP
0060C:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in  (unsigned long)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_ULONGTOFP32:
            ; {
0060D:      	R0=		0x009E		; ~~ E+31
            sfx_ULONG2FS_CORE:
0060F:      	call		sfx_Normalize_DA_FS
00610:      	jmp		sfx_RoundRet_DA_FS
            ; }
            
            
            ; --------------------------
            
            
            sfx_ULONGTOFP32_BXCX:
00611:      	call		sfx_FP32SWAP
00612:      	call		sfx_ULONGTOFP32
00613:      	call		sfx_FP32SWAP
00614:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_INTTOFP32:
00615:      	AR=		AX
00616:      	DX=		AR
00617:      	AX=		0
00618:      	R0=		0x008E
0061A:      	jmp		sfx_LONG2FS_CORE
            
            
            ; --------------------------
            
            
            sfx_INTTOFP32_BXCX:
0061B:      	call		sfx_FP32SWAP
0061C:      	call		sfx_INTTOFP32
0061D:      	call		sfx_FP32SWAP
0061E:      	rets
            
            
            ; --------------------------
            ; AX		- in  (unsigned int)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_UINTTOFP32:
0061F:      	AR=		AX
00620:      	DX=		AR
00621:      	AX=		0
00622:      	R0=		0x008E
00624:      	jmp		sfx_ULONG2FS_CORE
            
            ; --------------------------
            
            sfx_UINTTOFP32_BXCX:
00625:      	call		sfx_FP32SWAP
00626:      	call		sfx_UINTTOFP32
00627:      	call		sfx_FP32SWAP
00628:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            
            ; --------------------------
            ; DX:AX - mantissa
            ; R0    - sign & exp
            ; AR    - shift count
            ; --------------------------
            sfx_RSHIFT_DA:
            	; ~~ check if 0 shift count
            
00629:      	if ZR jmp	@sfx_rshift_label_1132
            
            	; ~~ adjust exp
0062A:      	push		CX
0062B:      	CX=		AR
0062C:      	AR=		AR + R0
0062D:      	test		AR.b8
0062E:      	if ZR jmp	@sfx_rshift_label_1333
            
0062F:      	AR=		R0
00630:      	AL=		0xFF
            
            @sfx_rshift_label_1333:
00631:      	R0=		AR
00632:      	jmp		@sfx_rshift_label_1335
            @sfx_rshift_loop_1335:
00633:      	clr		C
00634:      	src		DX, 1
00635:      	src		AX, 1
            @sfx_rshift_label_1335:
00636:      	loop		@sfx_rshift_loop_1335
00637:      	pop		CX
            @sfx_rshift_label_1132:
00638:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; DX:AX		- out (long)
            ; --------------------------
            sfx_FP32TOLONG:
00639:      	call		sfx_GETARG_DA_FS
0063A:      	AR=		0x009E
0063C:      	AR=		AR - R0
0063D:      	test		AR.b8
0063E:      	if NZ jmp	@sfx_fs2long_label_1709		; ~~ |X| >= 2^32
            
            	; ~~ lowest 8-bit already zero
            
0063F:      	AH=		0
00640:      	call		sfx_RSHIFT_DA
            
00641:      	test		R0.b15
00642:      	if ZR jmp	@sfx_fs2long_label_1339
            	
            	; ~~ check zero
            
00643:      	AR=		AX
00644:      	AR=		AR | DX
00645:      	if NZ jmp	@sfx_fs2long_label_1116
00646:      	rets
            @sfx_fs2long_label_1116:
            
            	; ~~ negative
            
00647:      	AR=		0
00648:      	AX=		AR - AX
00649:      	DX=		AR - DX + C - 1
0064A:      	AR=		AR - 0 + C - 1
            
            	; ~~ x < -0x80000000
0064B:      	if AN jmp	@sfx_fs2long_label_1420
0064C:      	rets
            
            @sfx_fs2long_label_1339:
            	; ~~ postive
0064D:      	test		DX.b15
0064E:      	if NZ jmp	@sfx_fs2long_label_1421
0064F:      	rets
            
            @sfx_fs2long_label_1709:
            	; ~~ fs2slong_maxval
00650:      	test		R0.b15
00651:      	if ZR jmp	@sfx_fs2long_label_1421
            
            @sfx_fs2long_label_1420:
            	; ~~ check sign bit
00652:      	test		DX.b15
00653:      	if ZR jmp	@sfx_fs2long_label_1118
00654:      	rets
            @sfx_fs2long_label_1118:
            	; ~~ fs2slong_maxval_neg
00655:      	AX=		0
00656:      	DX=		0x8000
00658:      	rets
            
            @sfx_fs2long_label_1421:
            	; ~~ fs2long_maxval_pos
00659:      	AX=		0xFFFF
0065B:      	DX=		0x7FFF
0065D:      	rets
            
            ; --------------------------
            
            sfx_FP32TOLONG_BXCX:
0065E:      	call		sfx_FP32SWAP
0065F:      	call		sfx_FP32TOLONG
00660:      	call		sfx_FP32SWAP
00661:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP32TOULONG:
00662:      	call		sfx_GETARG_DA_FS
00663:      	test		R0.b15
00664:      	if ZR jmp	@sfx_fs2ulong_label_1536
            
            	; ~~ return 0
            
00665:      	AX=		0
00666:      	DX=		0
00667:      	rets
            
            @sfx_fs2ulong_label_1536:
            	; ~~ fs2ulong_int
            
00668:      	AR=		0x009E
0066A:      	AR=		AR - R0
0066B:      	test		AR.b8
0066C:      	if ZR jmp	@sfx_fs2ulong_label_1541
            
            	; ~~ x >= 2^32
            
0066D:      	AX=		0xFF		; ~~ 0xFFFF
0066E:      	DX=		0xFF		; ~~ 0xFFFF
0066F:      	rets
            
            @sfx_fs2ulong_label_1541:
00670:      	AH=		0
00671:      	call		sfx_RSHIFT_DA
00672:      	rets
            
            	
            ; --------------------------
            
            sfx_FP32TOULONG_BXCX:
00673:      	call		sfx_FP32SWAP
00674:      	call		sfx_FP32TOULONG
00675:      	call		sfx_FP32SWAP
00676:      	rets
            	
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (short)
            ; --------------------------
            sfx_FP32TOINT:
00677:      	call		sfx_FP32TOLONG
00678:      	AR=		AX
00679:      	AR=		AR | DX
0067A:      	if NZ jmp	@sfx_fs2int_label_1138
0067B:      	rets
            @sfx_fs2int_label_1138:
0067C:      	test		R0.b15
0067D:      	if ZR jmp	@sfx_fs2int_label_1553
            
            	; ~~ negative
            
0067E:      	AR=		-1
0067F:      	SF=		AR - DX
00680:      	if NE jmp	@sfx_fs2int_label_1609
00681:      	test		AX.b15
00682:      	if ZR jmp	@sfx_fs2int_label_1609
00683:      	rets
            @sfx_fs2int_label_1609:
00684:      	AX=		0x8000
00686:      	rets
            
            
            @sfx_fs2int_label_1553:
            
            	; ~~ positive check
            
00687:      	AR=		DX
00688:      	if NZ jmp	@sfx_fs2int_label_1603_2
00689:      	test		AX.b15
0068A:      	if NZ jmp	@sfx_fs2int_label_1603_2
0068B:      	rets
            @sfx_fs2int_label_1603_2:
0068C:      	AX=		0x7FFF
0068E:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOINT_BXCX:
0068F:      	call		sfx_FP32SWAP
00690:      	call		sfx_FP32TOINT
00691:      	call		sfx_FP32SWAP
00692:      	rets
            	
            
            	
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (ushort)
            ; --------------------------
            sfx_FP32TOUINT:
00693:      	call		sfx_FP32TOULONG
00694:      	AR=		DX
00695:      	if NZ jmp	@sfx_fs2uint_label_1644
00696:      	rets
            @sfx_fs2uint_label_1644:
00697:      	AX=		0xFFFF
00699:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOUINT_BXCX:
0069A:      	call		sfx_FP32SWAP
0069B:      	call		sfx_FP32TOUINT
0069C:      	call		sfx_FP32SWAP
0069D:      	rets
            	
            
            ; ~~-------------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (fp16)
            ; ~~-------------------------------
            sfx_FP32TOFP16:
0069E:      	call		sfx_GETARG_DA_FS
            
0069F:      	AR=		0x70
006A0:      	R0=		R0 - AR
006A1:      	test		R0.b5
006A2:      	if NZ jmp	@sfx_fs2f16_label_1647
006A3:      	AR=		R0
006A4:      	AH=		0
006A5:      	if ZR jmp	@sfx_fs2f16_label_1647
006A6:      	SF=		AR - 0x1F
006A7:      	if GE jmp	@sfx_fs2f16_label_1647
            
            	; ~~ no round
            
            	; ~~ drop hidden 1
006A8:      	slz		AX, 1
006A9:      	slc		DX, 1
            
006AA:      	AR=		DX
006AB:      	AX=		0xE0		; ~~ FFE0
006AC:      	AX=		AR & AX
            
006AD:      	AR=		R0
006AE:      	sra		AR, 2
006AF:      	src		AX, 2
006B0:      	sra		AR, 2
006B1:      	src		AX, 2
006B2:      	sra		AR, 1
006B3:      	src		AX, 1
006B4:      	slz		AR, 1
006B5:      	src		AX, 1
006B6:      	rets
            
            @sfx_fs2f16_label_1647:
            	; ~~ FP16 INF
006B7:      	AX=		0xF800
006B9:      	AR=		R0
006BA:      	slz		AR, 1
006BB:      	src		AX, 1
006BC:      	rets
            
            
            ; --------------------------
            
            sfx_FP32TOFP16_BXCX:
006BD:      	call		sfx_FP32SWAP
006BE:      	call		sfx_FP32TOFP16
006BF:      	call		sfx_FP32SWAP
006C0:      	rets
            
            ; -------------------------------------------
            ; ~~ swap two fp32 value
            ; R0:DX:AX  <-> R1:BX:CX
            ; -------------------------------------------
            
            
            sfx_FP32SWAP_AB:
006C1:      	push		R0
006C2:      	push		R1
006C3:      	pop		R0
006C4:      	pop		R1
006C5:      	push		AX
006C6:      	push		CX
006C7:      	pop		AX
006C8:      	pop		CX
006C9:      	push		DX
006CA:      	push		BX
006CB:      	pop		DX
006CC:      	pop		BX
006CD:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            
            sfx_FP32ADD:
006CE:      	call		sfx_GETARG_DA_FS
006CF:      	call		sfx_GETARG_BC_FS
            
            	; ~~ which exponent is greater ?
            
006D0:      	AR=		R1
006D1:      	push		R0
006D2:      	pop		R2
006D3:      	clr		AR.b15
006D4:      	clr		R2.b15
006D5:      	SF=		AR - R2
006D6:      	if GE jmp	@sfx_fp32add_label_1043
            
006D7:      	call		sfx_FP32SWAP_AB
            
            @sfx_fp32add_label_1043:
006D8:      	AR=		R1
006D9:      	push		R0
006DA:      	pop		R2
006DB:      	clr		AR.b15
006DC:      	clr		R2.b15
006DD:      	AR=		AR - R2
006DE:      	call		sfx_RSHIFT_DA
            
            	; ~~ decide if we need to add or subtract
            
006DF:      	AR=		R0
006E0:      	AR=		AR ^ R1
006E1:      	slz		AR, 1
006E2:      	if AC jmp	@sfx_fp32add_label_1714
            
            	; ~~ add the mantissa (both positive or both negative)
            
006E3:      	AR=		CX
006E4:      	AX=		AX + AR
006E5:      	AR=		BX
006E6:      	DX=		DX + AR + C
006E7:      	if NC jmp	@sfx_fp32add_label_1718
006E8:      	AR=		1
006E9:      	call		sfx_RSHIFT_DA
006EA:      	set		DX.b15			; ~~ hidden 1
            @sfx_fp32add_label_1718:
006EB:      	jmp		@sfx_fp32add_label_1720
            
            @sfx_fp32add_label_1714:
            
            	; ~~ subtract the mantissa (one of them is negative)
            
006EC:      	AR=		CX
006ED:      	AX=		AX - AR
006EE:      	AR=		BX
006EF:      	DX=		DX - AR + C - 1
006F0:      	if AC jmp	@sfx_fp32add_label_1720
            
006F1:      	AR=		0
006F2:      	AX=		AR - AX
006F3:      	DX=		AR - DX + C - 1
006F4:      	not		R0.b15
            @sfx_fp32add_label_1720:
006F5:      	call		sfx_Normalize_DA_FS
006F6:      	jmp		sfx_RoundRet_DA_FS
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32SUB:
006F7:      	not		BX.b15
006F8:      	jmp		sfx_FP32ADD
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32MUL:
            	; ~~ first check if either input is zero
            
006F9:      	AR=		DX
006FA:      	if ZR jmp	sfx_RetZero_DA_FS
006FB:      	AR=		BX
006FC:      	if ZR jmp	sfx_RetZero_DA_FS
            
006FD:      	call		sfx_GETARG_DANS_FS
006FE:      	call		sfx_GETARG_BCNS_FS
            
            	; ~~ compare final sign bit
            
006FF:      	test		R1.b15
00700:      	if ZR jmp	@sfx_fp32mul_label_1026
            
00701:      	not		R0.b15
            @sfx_fp32mul_label_1026:
            
            	; ~~ check if either input is infinity
            
00702:      	AR=		R1
00703:      	AH=		0xFF
00704:      	SF=		AR - 0xFF		; ~~ 0xFFFF
00705:      	if EQ jmp	sfx_ReturnINF_DA_FS
            
00706:      	AR=		R0
00707:      	AH=		0xFF
00708:      	SF=		AR - 0xFF		; ~~ 0xFFFF
00709:      	if EQ jmp	sfx_ReturnINF_DA_FS
            
            
            	; ~~ add the exponents
            
0070A:      	AR=		R1
0070B:      	clr		AR.b15
0070C:      	AR=		AR + R0
0070D:      	test		AR.b8
0070E:      	if NZ jmp	@sfx_fp32mul_label_1322
            
            	; ~~ minus exponents
            
0070F:      	AR=		AR - 126
00710:      	test		AR.b8
00711:      	if ZR jmp	@sfx_fp32mul_label_1103
            
00712:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32mul_label_1322:
            
00713:      	AR=		AR - 126
00714:      	test		AR.b8
00715:      	if ZR jmp	@sfx_fp32mul_label_1103
            
00716:      	jmp		sfx_ReturnINF_DA_FS
            
            @sfx_fp32mul_label_1103:
00717:      	R0=		AR
            
            	; ~~ unsigned multiplay
00718:      	PCH=		sfx_MULLONG
00719:      	lcall		sfx_MULLONG
            
            	; ~~ 48-bit result in CX:DX:AX
            
            	; ~~ drop low 16-bit
            
0071A:      	push		DX
0071B:      	pop		AX
0071C:      	push		CX
0071D:      	pop		DX
0071E:      	test		DX.b15
0071F:      	if NZ jmp	@sfx_fs32mul_label_1326
            
00720:      	call		sfx_Normalize_DA_FS
            @sfx_fs32mul_label_1326:
00721:      	jmp		sfx_RoundRet_DA_FS
            
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; DX:AX		- out (fp32)
            ; --------------------------
            sfx_FP32DIV:
            	; ~~ compute final sign bit
00722:      	test		BX.b15
00723:      	if ZR jmp	@sfx_fp32div_label_1629
            
00724:      	not		DX.b15
            @sfx_fp32div_label_1629:
            
            	; ~~ if divisor is zero, ...
00725:      	AR=		BX
00726:      	if NZ jmp	@sfx_fp32div_label_1639
            	; ~~ if dividend is also zero, return NaN
00727:      	AR=		DX
00728:      	if NZ jmp	@sfx_fp32div_label_1641
00729:      	jmp		sfx_ReturnNaN_DA_FS
            @sfx_fp32div_label_1641:
            	; ~~ but dividend is non-zero, return infinity
0072A:      	jmp		sfx_ReturnINF_DA_FS
            @sfx_fp32div_label_1639:
            	; ~~ if dividend is zero, return zero
0072B:      	AR=		DX
0072C:      	if NZ jmp	@sfx_fp32div_label_1644
0072D:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32div_label_1644:
0072E:      	call		sfx_GETARG_DANS_FS
0072F:      	call		sfx_GETARG_BCNS_FS
            
            	; ~~ if divisor is infinity, ...
00730:      	AR=		R1
00731:      	AH=		0xFF
00732:      	SF=		AR - 0xFF	; ~~ 0xFFFF
00733:      	if NE jmp	@sfx_fp32div_label_1646
00734:      	AR=		R0
00735:      	AH=		0xFF
00736:      	SF=		AR - 0xFF	; ~~ 0xFFFF
00737:      	if NE jmp	@sfx_fp32div_label_1647
00738:      	jmp		sfx_ReturnNaN_DA_FS
            @sfx_fp32div_label_1647:
00739:      	jmp		sfx_RetZero_DA_FS
            
            @sfx_fp32div_label_1646:
            	; ~~ subtract exponents
            
0073A:      	AR=		R1
0073B:      	clr		AR.b15
0073C:      	AR=		R0 - AR
0073D:      	test		AR.b8
0073E:      	if ZR jmp	@sfx_fp32div_label_1649
            
0073F:      	AR=		AR + 127
00740:      	test		AR.b8
00741:      	if ZR jmp	@sfx_fp32div_label_1753
00742:      	jmp		sfx_RetZero_DA_FS
            @sfx_fp32div_label_1649:
            
00743:      	AR=		AR + 127
00744:      	test		AR.b8
00745:      	if ZR jmp	@sfx_fp32div_label_1753
00746:      	jmp		sfx_ReturnINF_DA_FS
            @sfx_fp32div_label_1753:
00747:      	R0=		AR
            
00748:      	AR=		AX
00749:      	AR=		AR - CX
0074A:      	AR=		DX
0074B:      	AR=		AR - BX + C - 1
0074C:      	test		AR.b15
0074D:      	if ZR jmp	@sfx_fp32div_label_1638
            
            	; ~~ need extra bits on a's mantissa
            
0074E:      	slz		AX, 1
0074F:      	slc		DX, 1
00750:      	R0--				; ~~ exponent
            @sfx_fp32div_label_1638:
            
            	; ~~ now we perform repeated substraction of float2 from float1
            
            	; ~~ result - DX:AX
            	; ~~ using 25-bit to make float more accuracy
            
00751:      	push		AX
00752:      	pop		R2
00753:      	push		DX
00754:      	pop		R3
00755:      	DX=		0
00756:      	AX=		0
00757:      	P1=		25
00758:      	push		R0
            @sfx_fp32div_loop_1642:
00759:      	slz		AX, 1
0075A:      	slc		DX, 1
            
            	; ~~ mant1 < mant2
0075B:      		AR=		R2
0075C:      		R0=		AR
0075D:      		AR=		R3
0075E:      		R1=		AR
0075F:      		AR=		CX
00760:      		R0=		R0 - AR
00761:      		AR=		BX
00762:      		R1=		R1 - AR + C - 1
00763:      		test		R1.b15
00764:      		if NZ jmp	@sfx_fp32div_label_1651
            
            	; result |= mask
00765:      		set		AX.b7
            
            	; mant1 -= mant2
00766:      		AR=		CX
00767:      		R2=		R2 - AR
00768:      		AR=		BX
00769:      		R3=		R3 - AR + C - 1
            @sfx_fp32div_label_1651:
            
            	; mantl <<= 1;
0076A:      		slz		R2, 1
0076B:      		slc		R3, 1
            
0076C:      	P1--
0076D:      	if NZ jmp	@sfx_fp32div_loop_1642
0076E:      	pop		R0
            
            @sfx_fp32div_label_0921:
            
0076F:      	call		sfx_Normalize_DA_FS
00770:      	jmp		sfx_RoundRet_DA_FS
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    internal                     ~~ ;
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            
            sfx_FP32CMPU32:
00771:      	clr		DX.b15
00772:      	clr		BX.b15
00773:      	AR=		AX
00774:      	SF=		AR - CX
00775:      	if NE jmp	@sfx_fp32cmpu32_label_1615
00776:      	AR=		DX
00777:      	SF=		AR - BX
00778:      	if NE jmp	@sfx_fp32cmpu32_label_1615
            
00779:      	set		Z
0077A:      	rets
            @sfx_fp32cmpu32_label_1615:
0077B:      	clr		Z
0077C:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            sfx_FP32CHKZERO:
0077D:      	AR=		AX
0077E:      	AR=		AR | CX
0077F:      	if NZ jmp	@sfx_fp32chkzero_label_1620
00780:      	AR=		DX
00781:      	AR=		AR | BX
00782:      	clr		AR.b15
00783:      	if NZ jmp	@sfx_fp32chkzero_label_1620
00784:      	set		Z
00785:      	rets
            @sfx_fp32chkzero_label_1620:
00786:      	clr		Z
00787:      	rets
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; DX:AX  <-->   BX:CX
            
            sfx_FP32SWAP:
00788:      	push		AX
00789:      	push		DX
0078A:      	push		CX
0078B:      	push		BX
0078C:      	pop		DX
0078D:      	pop		AX
0078E:      	pop		BX
0078F:      	pop		CX
00790:      	rets
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    subcc                        ~~ ;
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : EQU
            ;                 0 : not EQU
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JE:
00791:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JE:
00792:      	call		sfx_FP32CHKZERO
00793:      	if ZR jmp	@sfx_fp32equ_label_1622
00794:      	call		sfx_FP32CMPU32
00795:      	if ZR jmp	@sfx_fp32equ_label_1622
00796:      	clr		Z
00797:      	rets
            @sfx_fp32equ_label_1622:
00798:      	set		Z
00799:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : >
            ;                 0 : <=
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JG:
            sfx_CMPFP32_BCDA_JA:
0079A:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JG:
            sfx_CMPFP32_JA:
            	; ~~ backup sign bit
0079B:      	R0=		0
0079C:      	AR=		DX
0079D:      	slz		AR, 1
0079E:      	slc		R0, 1
0079F:      	AR=		BX
007A0:      	slz		AR, 1
007A1:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
007A2:      	call		sfx_FP32CHKZERO
007A3:      	if ZR jmp	@sfx_cmpfp32_jg_label_1641
007A4:      	call		sfx_FP32CMPU32
007A5:      	if ZR jmp	@sfx_cmpfp32_jg_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
007A6:      	AR=		R0
007A7:      	if EQ jmp	@sfx_comfp32_jg_label_1645
007A8:      	SF=		AR - 3
007A9:      	if EQ jmp	@sfx_comfp32_jg_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
007AA:      	SF=		AR - 1
007AB:      	if EQ jmp	@sfx_comfp32_jg_label_1657
            	; ~~ 2  =  -  vs  +   = <
007AC:      	jmp		@sfx_cmpfp32_jg_label_1641
            @sfx_comfp32_jg_label_1645:
            	; ~~ sign bit the same
            
007AD:      	AR=		CX
007AE:      	AX=		AX - AR
007AF:      	AR=		BX
007B0:      	DX=		DX - AR + C - 1
            
007B1:      	AR=		R0
007B2:      	SF=		AR - 3
007B3:      	if NE jmp	@sfx_cmpfp32_jg_label_1558
007B4:      	not		DX.b15
            @sfx_cmpfp32_jg_label_1558:
007B5:      	test		DX.b15
007B6:      	if ZR jmp	@sfx_comfp32_jg_label_1657
            
            @sfx_cmpfp32_jg_label_1641:
007B7:      	clr		Z		; ~~ false
007B8:      	rets
            
            @sfx_comfp32_jg_label_1657:
007B9:      	set		Z		; ~~ true
007BA:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : <
            ;                 0 : >=
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JL:
            sfx_CMPFP32_BCDA_JB:
007BB:      	call		sfx_FP32SWAP
            sfx_CMPFP32_JL:
            sfx_CMPFP32_JB:
            	; ~~ backup sign bit
007BC:      	R0=		0
007BD:      	AR=		DX
007BE:      	slz		AR, 1
007BF:      	slc		R0, 1
007C0:      	AR=		BX
007C1:      	slz		AR, 1
007C2:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
007C3:      	call		sfx_FP32CHKZERO
007C4:      	if ZR jmp	@sfx_cmpfp32_jl_label_1641
007C5:      	call		sfx_FP32CMPU32
007C6:      	if ZR jmp	@sfx_cmpfp32_jl_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
007C7:      	AR=		R0
007C8:      	if EQ jmp	@sfx_comfp32_jl_label_1645
007C9:      	SF=		AR - 3
007CA:      	if EQ jmp	@sfx_comfp32_jl_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
007CB:      	SF=		AR - 1
007CC:      	if EQ jmp	@sfx_cmpfp32_jl_label_1641
            	; ~~ 2  =  -  vs  +   = <
007CD:      	jmp		@sfx_comfp32_jl_label_1657
            
            @sfx_comfp32_jl_label_1645:
            	; ~~ sign bit the same
            
007CE:      	AR=		CX
007CF:      	AX=		AX - AR
007D0:      	AR=		BX
007D1:      	DX=		DX - AR + C - 1
            
007D2:      	AR=		R0
007D3:      	SF=		AR - 3
007D4:      	if NE jmp	@sfx_cmpfp32_jl_label_1558
007D5:      	not		DX.b15
            @sfx_cmpfp32_jl_label_1558:
007D6:      	test		DX.b15
007D7:      	if NZ jmp	@sfx_comfp32_jl_label_1657
            
            @sfx_cmpfp32_jl_label_1641:
007D8:      	clr		Z		; ~~ false
007D9:      	rets
            
            @sfx_comfp32_jl_label_1657:
007DA:      	set		Z		; ~~ true
007DB:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP32_JNE:
007DC:      	call		sfx_CMPFP32_JE
007DD:      	if ZR jmp	@sfx_cmpfp32_jne_label_false
007DE:      	set		Z
007DF:      	rets
            @sfx_cmpfp32_jne_label_false:
007E0:      	clr		Z
007E1:      	rets
            
            
            ; --------------------------
            ; BX:CX		- in (fp32)
            ; DX:AX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP32_BCDA_JNE:
007E2:      	call		sfx_CMPFP32_BCDA_JE
007E3:      	if ZR jmp	@sfx_cmpfp32_bcda_jne_label_false
007E4:      	set		Z
007E5:      	rets
            @sfx_cmpfp32_bcda_jne_label_false:
007E6:      	clr		Z
007E7:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : <=
            ;                 0 : >
            ; --------------------------
            
            sfx_CMPFP32_JLE:
            sfx_CMPFP32_JBE:
007E8:      	call		sfx_CMPFP32_JG
007E9:      	if ZR jmp	@sfx_cmpfp32_jle_label_false
007EA:      	set		Z
007EB:      	rets
            @sfx_cmpfp32_jle_label_false:
007EC:      	clr		Z
007ED:      	rets
            
            
            sfx_CMPFP32_BCDA_JLE:
            sfx_CMPFP32_BCDA_JBE:
007EE:      	call		sfx_CMPFP32_BCDA_JG
007EF:      	if ZR jmp	@sfx_cmpfp32_bcda_jle_label_false
007F0:      	set		Z
007F1:      	rets
            @sfx_cmpfp32_bcda_jle_label_false:
007F2:      	clr		Z
007F3:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; BX:CX		- in (fp32)
            ; --------------------------
            ; AX		- 1 : >=
            ;                 0 : <
            ; --------------------------
            
            sfx_CMPFP32_JGE:
            sfx_CMPFP32_JAE:
007F4:      	call		sfx_CMPFP32_JL
007F5:      	if ZR jmp	@sfx_cmpfp32_jge_label_false
007F6:      	set		Z
007F7:      	rets
            @sfx_cmpfp32_jge_label_false:
007F8:      	clr		Z
007F9:      	rets
            
            
            sfx_CMPFP32_BCDA_JGE:
            sfx_CMPFP32_BCDA_JAE:
007FA:      	call		sfx_CMPFP32_BCDA_JL
007FB:      	if ZR jmp	@sfx_cmpfp32_bcda_jge_label_false
007FC:      	set		Z
007FD:      	rets
            @sfx_cmpfp32_bcda_jge_label_false:
007FE:      	clr		Z
007FF:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; --------------------------
            sfx_FP32NEG:
00800:      	not		DX.b15
00801:      	rets
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\FP32RT.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\FP16RT.ASM> Start=========================
            
            ; ~~-----------------------------------------------------
            ; half precision number (16-bit) float point support for DSP
            ; -------------------------------------------------------
            
            ; -------------------------------------------------------
            ; -------------------------------------------------------
            
            ; +-----------------------------------------------------+
            ; | AX (CX)                                             |
            ; +------+---------------+------------------------------+
            ; |  0   | 4  3  2  1  0 | 9  8  7  6  5  4  3  2  1  0 |
            ; +------+---------------+------------------------------+
            ; | sign | e  e  e  e  e | m  m  m  m  m  m  m  m  m  m |
            ; +------+----------------------------------------------+
            ;    15   14 13 12 11 10   9  8  7  6  5  4  3  2  1  0
            
            
            
            ; ~~ float -> sign / exp / mantissa
            
            ; ~~ AX / CX - mantissa
            
            ; +-------------------------------------------------+
            ; | AX (CX)                                         |
            ; +---+---------------------------------------------+
            ; | 1 | m  m  m  m  m  m  m  m  m  m  0  0  0  0  0 |
            ; +---+---------------------------------------------+
            ;   H   9  8  7  6  5  4  3  2  1  0  -  -  -  -  -
            ;
            
            ; ~~ R0    / R1    - sign and exp
            ; +------------------------+---------+---------------+
            ; | S  -  -  -  -  -  -  - | 0  0  0 | e  e  e  e  e |
            ; +------------------------+---------+---------------+
            ;  15 14 13 12 11 10  9  8   7  6  5   4  3  2  1  0
            
            ; ~~ --
            
            sfx_GETARG_ANS_FP16:
00802:      	AR=		AX
00803:      	xchg		AR
00804:      	sra		AR, 2
00805:      	AR=		AR & 0x1F
00806:      	R0=		AR
00807:      	test		AX.b15
00808:      	if ZR jmp	@sfx_getarg_aFP16_label_1736
00809:      	set		R0.b15
            @sfx_getarg_aFP16_label_1736:
0080A:      	AR=		0x03FF
0080C:      	AX=		AX & AR
0080D:      	set		AX.b10		; ~~ HIDDEN 1
0080E:      	rets
            
            
            sfx_GETARG_A_FP16:
0080F:      	call		sfx_GETARG_ANS_FP16
00810:      	slz		AX, 2
00811:      	slz		AX, 2
00812:      	slz		AX, 1
00813:      	rets
            
            ; ~~ -----------
            
            ; ~~ --
            
            sfx_GETARG_CNS_FP16:
00814:      	AR=		CX
00815:      	xchg		AR
00816:      	sra		AR, 2
00817:      	AR=		AR & 0x1F
00818:      	R1=		AR
00819:      	test		CX.b15
0081A:      	if ZR jmp	@sfx_getarg_cFP16_label_1736
0081B:      	set		R1.b15
            @sfx_getarg_cFP16_label_1736:
0081C:      	AR=		0x03FF
0081E:      	CX=		CX & AR
0081F:      	set		CX.b10		; ~~ HIDDEN 1
00820:      	rets
            
            
            sfx_GETARG_C_FP16:
00821:      	call		sfx_GETARG_CNS_FP16
00822:      	slz		CX, 2
00823:      	slz		CX, 2
00824:      	slz		CX, 1
00825:      	rets
            
            ; ~~ -----------
            ; ~~ AX    - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_Normalize_A_FP16:
            ; {
00826:      	push		CX
00827:      	CX=		15
            @sfx_normalize_aFP16_loop_1609:
00828:      	test		AX.b15
00829:      	if NZ jmp	@sfx_normalize_aFP16_label_1609
0082A:      	slz		AX, 1
0082B:      	R0--
0082C:      	AR=		R0
0082D:      	clr		AR.b15
0082E:      	if ZR jmp	@sfx_normalize_aFP16_label_1609
0082F:      	loop		@sfx_normalize_aFP16_loop_1609
            @sfx_normalize_aFP16_label_1609:
00830:      	pop		CX
00831:      	rets
            ; }
            
            
            ; ~~ AX    - mantissa
            ; ~~ R0    - sign and exp
            
            sfx_RoundRet_A_FP16:
            ; {
            	; ~~ for register save
            
            	; ~~ round lowest 5-bit to increase accuracy ??
            
            	; AR=		AX
            	; AR=		AR & 0x1F
            	; AR=		AR - 0x0F
            	; if LE jmp	@sfx_roundret_aFP16_label_1033
            
            	; test		AX.b5
            	; if ZR jmp	@sfx_roundret_aFP16_label_1033
            
            	; ~~ +1
            
00832:      	AR=		0x10
00833:      	AX=		AX + AR
00834:      	if NC jmp	@sfx_roundret_aFP16_label_1033
            	; ~~ overflow
00835:      	AX.h=		0x80
00836:      	R0++
            @sfx_roundret_aFP16_label_1033:
00837:      	AR=		0xFFE0
00839:      	AR=		AR & AX
0083A:      	if NZ jmp	sfx_DirectRet_A_FP16
            
            sfx_RetZero_A_FP16:
            	; ~~ float 0.0
0083B:      	AX=		0
0083C:      	rets
            
            
            sfx_DirectRet_A_FP16:
            	; ~~ drop 1-bit  (1.xxx)
0083D:      	slz		AX, 1
            
            	; 5-bit exp
            
0083E:      	AR=		R0
0083F:      	sra		AR, 2
00840:      	src		AX, 2
00841:      	sra		AR, 2
00842:      	src		AX, 2
00843:      	sra		AR, 1
00844:      	src		AX, 1
            
            	; ~~ sign bit (sra duplicate)
            
00845:      	slz		AR, 1
00846:      	src		AX, 1
00847:      	rets
            
            sfx_ReturnINF_A_FP16:
00848:      	AX=		0xF800
0084A:      	AR=		R0
0084B:      	slz		AR, 1
0084C:      	src		AX, 1
0084D:      	rets
            
            sfx_ReturnNaN_A_FP16:
0084E:      	AX=		0x7E00
00850:      	rets
            ; }
            
            
            
            ; --------------------------
            ; ~~ int type -> float point
            ; --------------------------
            
            
            ; --------------------------
            ; DX:AX		- in  (long)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_LONGTOFP16:
00851:      	R0=		0x001E		; ~~ E+15
            
            ; sfx_LONG2FP16_CORE:
00852:      	test		DX.b15
00853:      	if ZR jmp	@sfx_long2FP16_label_1416
            
            	; ~~ make it positive if value is negative
            
00854:      	set		R0.b15		; ~~ sign
00855:      	AR=		0
00856:      	AX=		AR - AX
00857:      	DX=		AR - DX + C - 1
            
            @sfx_long2FP16_label_1416:
            	; ~~ check INF
00858:      	AR=		DX
00859:      	if NZ jmp	sfx_ReturnINF_A_FP16
0085A:      	call		sfx_Normalize_A_FP16
0085B:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_LONGTOFP16_CX:
0085C:      	call		sfx_FP16SWAP
0085D:      	call		sfx_LONGTOFP16
0085E:      	call		sfx_FP16SWAP
0085F:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in  (unsigned long)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_ULONGTOFP16:
            ; {
00860:      	R0=		0x001E		; ~~ E+31
            ; sfx_ULONG2FP16_CORE:
00861:      	AR=		DX
00862:      	if NZ jmp	sfx_ReturnINF_A_FP16
00863:      	call		sfx_Normalize_A_FP16
00864:      	jmp		sfx_RoundRet_A_FP16
            ; }
            
            ; --------------------------
            
            sfx_ULONGTOFP16_CX:
00865:      	call		sfx_FP16SWAP
00866:      	call		sfx_ULONGTOFP16
00867:      	call		sfx_FP16SWAP
00868:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_INTTOFP16:
00869:      	R0=		0x001E		; ~~ E+15
            
            ; sfx_INT2FS_CORE:
0086A:      	test		AX.b15
0086B:      	if ZR jmp	@sfx_int2FP16_label_1004
            
0086C:      	set		R0.b15
0086D:      	AR=		0
0086E:      	AX=		AR - AX
            @sfx_int2FP16_label_1004:
0086F:      	call		sfx_Normalize_A_FP16
00870:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_INTTOFP16_CX:
00871:      	call		sfx_FP16SWAP
00872:      	call		sfx_INTTOFP16
00873:      	call		sfx_FP16SWAP
00874:      	rets
            
            
            ; --------------------------
            ; AX		- in  (int)
            ; AX		- out (fp32)
            ; --------------------------
            sfx_UINTTOFP16:
00875:      	R0=		0x001E		; ~~ E+15
00876:      	call		sfx_Normalize_A_FP16
00877:      	jmp		sfx_RoundRet_A_FP16
            
            ; --------------------------
            
            sfx_UINTTOFP16_CX:
00878:      	call		sfx_FP16SWAP
00879:      	call		sfx_UINTTOFP16
0087A:      	call		sfx_FP16SWAP
0087B:      	rets
            
            ; ~~--------------------------------------------------------------------
            
            ; --------------------------
            ; AX    - mantissa
            ; R0    - sign & exp
            ; CX    - shift count
            ; --------------------------
            sfx_RSHIFT_A:
            	; ~~ check if 0 shift count
            
0087C:      	if ZR jmp	@sfx_rshifta_label_1132
            
            	; ~~ adjust exp
0087D:      	push		CX
0087E:      	CX=		AR
0087F:      	AR=		AR + R0
00880:      	test		AR.b5
00881:      	if ZR jmp	@sfx_rshifta_label_1333
            
00882:      	AR=		R0
00883:      	AL=		0x1F
            
            @sfx_rshifta_label_1333:
00884:      	R0=		AR
00885:      	jmp		@sfx_rshifta_label_1335
            @sfx_rshifta_loop_1335:
00886:      	clr		C
00887:      	src		AX, 1
            @sfx_rshifta_label_1335:
00888:      	loop		@sfx_rshifta_loop_1335
00889:      	pop		CX
            @sfx_rshifta_label_1132:
0088A:      	rets
            
            
            ; ~~--
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (long)
            ; --------------------------
            sfx_FP16TOLONG:
0088B:      	call		sfx_GETARG_A_FP16
0088C:      	AR=		0x001E
0088D:      	AR=		AR - R0
0088E:      	test		AR.b5
0088F:      	if NZ jmp	@sfx_FP162long_label_1709		; ~~ |X| >= 2^16
            
            	; ~~ lowest 5-bit already zero
            
00890:      	AH=		0
00891:      	CX=		AR
00892:      	call		sfx_RSHIFT_A
            
00893:      	DX=		0
            
00894:      	test		R0.b15
00895:      	if ZR jmp	@sfx_FP162long_label_1339
            
            	; ~~ negative
            
00896:      	AR=		0
00897:      	AX=		AR - AX
00898:      	AR=		AR - 0 + C - 1
            
            	; ~~ x < -0x80000000
00899:      	if AN jmp	@sfx_FP162long_label_1420
0089A:      	rets
            
            @sfx_FP162long_label_1339:
            	; ~~ postive
0089B:      	test		DX.b15
0089C:      	if NZ jmp	@sfx_FP162long_label_1421
0089D:      	rets
            
            @sfx_FP162long_label_1709:
            	; ~~ fs2slong_maxval
0089E:      	test		R0.b15
0089F:      	if ZR jmp	@sfx_FP162long_label_1421
            
            @sfx_FP162long_label_1420:
            	; ~~ check sign bit
008A0:      	test		DX.b15
008A1:      	if ZR jmp	@sfx_FP162long_label_1118
008A2:      	rets
            @sfx_FP162long_label_1118:
            	; ~~ fs2slong_maxval_neg
008A3:      	AX=		0
008A4:      	DX=		0x8000
008A6:      	rets
            
            @sfx_FP162long_label_1421:
            	; ~~ fs2long_maxval_pos
008A7:      	AX=		0xFFFF
008A9:      	DX=		0x7FFF
008AB:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOLONG_CX:
008AC:      	call		sfx_FP16SWAP
008AD:      	call		sfx_FP16TOLONG
008AE:      	call		sfx_FP16SWAP
008AF:      	rets
            
            ; ~~--
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP16TOULONG:
008B0:      	call		sfx_GETARG_A_FP16
008B1:      	DX=		0
008B2:      	test		R0.b15
008B3:      	if ZR jmp	@sfx_FP162ulong_label_1536
            
            	; ~~ return 0
008B4:      	AX=		0
008B5:      	rets
            
            @sfx_FP162ulong_label_1536:
            	; ~~ fs2ulong_int
            
008B6:      	AR=		0x001E
008B7:      	AR=		AR - R0
008B8:      	test		AR.b5
008B9:      	if ZR jmp	@sfx_FP162ulong_label_1541
            
            	; ~~ x >= 2^16
            
008BA:      	AX=		0xFF		; ~~ 0xFFFF
008BB:      	DX=		0xFF		; ~~ 0xFFFF
008BC:      	rets
            
            @sfx_FP162ulong_label_1541:
008BD:      	AH=		0
008BE:      	CX=		AR
008BF:      	call		sfx_RSHIFT_A
008C0:      	rets
            
            ; --------------------------
            
            sfx_FP16TOULONG_CX:
008C1:      	call		sfx_FP16SWAP
008C2:      	call		sfx_FP16TOULONG
008C3:      	call		sfx_FP16SWAP
008C4:      	rets
            
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; AX		- out (short)
            ; --------------------------
            sfx_FP16TOINT:
008C5:      	call		sfx_GETARG_A_FP16
008C6:      	AR=		0x001E
008C7:      	AR=		AR - R0
008C8:      	test		AR.b5
008C9:      	if NZ jmp	@sfx_FP162int_label_1709		; ~~ |X| >= 2^16
            
            	; ~~ lowest 5-bit already zero
            
008CA:      	AH=		0
008CB:      	CX=		AR
008CC:      	call		sfx_RSHIFT_A
            
008CD:      	test		R0.b15
008CE:      	if ZR jmp	@sfx_FP162int_label_1339
            
            	; ~~ negative
            
008CF:      	AR=		0
008D0:      	AX=		AR - AX
008D1:      	if NZ jmp	@sfx_FP162int_label_1406
008D2:      	rets
            @sfx_FP162int_label_1406:
008D3:      	test		AX.b15
008D4:      	if ZR jmp	@sfx_FP162int_label_1420
008D5:      	rets
            
            @sfx_FP162int_label_1339:
            	; ~~ postive
008D6:      	test		AX.b15
008D7:      	if NZ jmp	@sfx_FP162int_label_1421
008D8:      	rets
            
            
            @sfx_FP162int_label_1709:
            	; ~~ fs2slong_maxval
008D9:      	test		R0.b15
008DA:      	if ZR jmp	@sfx_FP162int_label_1421
            
            @sfx_FP162int_label_1420:
            	; ~~ FP162int_maxval_neg
008DB:      	AX=		0x8000
008DD:      	rets
            
            @sfx_FP162int_label_1421:
            	; ~~ FP162int_maxval_pos
008DE:      	AX=		0x7FFF
008E0:      	rets
            
            ; --------------------------
            
            sfx_FP16TOINT_CX:
008E1:      	call		sfx_FP16SWAP
008E2:      	call		sfx_FP16TOINT
008E3:      	call		sfx_FP16SWAP
008E4:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (ulong)
            ; --------------------------
            sfx_FP16TOUINT:
008E5:      	call		sfx_GETARG_A_FP16
008E6:      	test		R0.b15
008E7:      	if ZR jmp	@sfx_FP162uint_label_1536
            
            	; ~~ return 0
008E8:      	AX=		0
008E9:      	rets
            
            @sfx_FP162uint_label_1536:
            	; ~~ fs2ulong_int
            
008EA:      	AR=		0x001E
008EB:      	AR=		AR - R0
008EC:      	test		AR.b5
008ED:      	if ZR jmp	@sfx_FP162uint_label_1541
            
            	; ~~ x >= 2^16
            
008EE:      	AX=		0xFF		; ~~ 0xFFFF
008EF:      	rets
            
            @sfx_FP162uint_label_1541:
008F0:      	AH=		0
008F1:      	CX=		AR
008F2:      	call		sfx_RSHIFT_A
008F3:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOUINT_CX:
008F4:      	call		sfx_FP16SWAP
008F5:      	call		sfx_FP16TOUINT
008F6:      	call		sfx_FP16SWAP
008F7:      	rets
            
            
            ; ~~-------------------------------
            ; AX		- in (fp16)
            ; DX:AX		- out (fp32)
            ; ~~-------------------------------
            sfx_FP16TOFP32:
            	; ~~ wait code .....  NaN / INF check
            
008F8:      	call		sfx_GETARG_A_FP16
008F9:      	AR=		0x70
008FA:      	R0=		R0 + AR
            
            	; ~~ drop hidden 1
008FB:      	slz		AX, 1
            
008FC:      	AR=		AX
008FD:      	DX=		AR
008FE:      	AX=		0
            
            	; ~~ generate fp32 format
            
008FF:      	AR=		R0
00900:      	sra		AR, 2
00901:      	src		DX, 2
00902:      	src		AX, 2
00903:      	sra		AR, 2
00904:      	src		DX, 2
00905:      	src		AX, 2
00906:      	sra		AR, 2
00907:      	src		DX, 2
00908:      	src		AX, 2
00909:      	sra		AR, 2
0090A:      	src		DX, 2
0090B:      	src		AX, 2
            	; ~~ sign bit (sra duplicate)
0090C:      	slz		AR, 1
0090D:      	src		DX, 1
0090E:      	src		AX, 1
0090F:      	rets
            
            
            ; --------------------------
            
            sfx_FP16TOFP32_CX:
00910:      	call		sfx_FP16SWAP
00911:      	call		sfx_FP16TOFP32
00912:      	call		sfx_FP16SWAP
00913:      	rets
            
            
            ; -------------------------------------------
            ; ~~ swap two fp16 value
            ; R0:AX  <-> R1:CX
            ; -------------------------------------------
            
            sfx_FP16SWAP_AB:
00914:      	push		R0
00915:      	push		R1
00916:      	pop		R0
00917:      	pop		R1
00918:      	push		AX
00919:      	push		CX
0091A:      	pop		AX
0091B:      	pop		CX
0091C:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            
            sfx_FP16ADD:
0091D:      	call		sfx_GETARG_A_FP16
0091E:      	call		sfx_GETARG_C_FP16
            
            	; ~~ which exponent is greater ?
            
0091F:      	AR=		R1
00920:      	push		R0
00921:      	pop		R2
00922:      	clr		AR.b15
00923:      	clr		R2.b15
00924:      	SF=		AR - R2
00925:      	if GE jmp	@sfx_fp16add_label_1043
            
00926:      	call		sfx_FP16SWAP_AB
            
            @sfx_fp16add_label_1043:
00927:      	AR=		R1
00928:      	push		R0
00929:      	pop		R2
0092A:      	clr		AR.b15
0092B:      	clr		R2.b15
0092C:      	AR=		AR - R2
0092D:      	call		sfx_RSHIFT_A
            
            	; ~~ decide if we need to add or subtract
            
0092E:      	AR=		R0
0092F:      	AR=		AR ^ R1
00930:      	slz		AR, 1
00931:      	if AC jmp	@sfx_fp16add_label_1714
            
            	; ~~ add the mantissa (both positive or both negative)
            
00932:      	AR=		CX
00933:      	AX=		AX + AR
00934:      	if NC jmp	@sfx_fp16add_label_1718
00935:      	AR=		1
00936:      	call		sfx_RSHIFT_A
00937:      	set		AX.b15			; ~~ hidden 1
            @sfx_fp16add_label_1718:
00938:      	jmp		@sfx_fp16add_label_1720
            
            @sfx_fp16add_label_1714:
            
            	; ~~ subtract the mantissa (one of them is negative)
            
00939:      	AR=		CX
0093A:      	AX=		AX - AR
0093B:      	AR=		0
0093C:      	AR=		AR - 0 + C - 1
0093D:      	if AC jmp	@sfx_fp16add_label_1720
            
0093E:      	AR=		0
0093F:      	AX=		AR - AX
00940:      	not		R0.b15
            @sfx_fp16add_label_1720:
00941:      	call		sfx_Normalize_A_FP16
00942:      	jmp		sfx_RoundRet_A_FP16
            
            ; ~~ --
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            
            sfx_FP16SUB:
00943:      	not		CX.b15
00944:      	jmp		sfx_FP16ADD
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_FP16MUL:
            	; ~~ first check if either input is zero
            
00945:      	AR=		AX
00946:      	if ZR jmp	sfx_RetZero_A_FP16
00947:      	AR=		CX
00948:      	if ZR jmp	sfx_RetZero_A_FP16
            
00949:      	call		sfx_GETARG_A_FP16
0094A:      	call		sfx_GETARG_C_FP16
            
            	; ~~ compare final sign bit
            
0094B:      	test		R1.b15
0094C:      	if ZR jmp	@sfx_fp16mul_label_1410
            
0094D:      	not		R0.b15
            @sfx_fp16mul_label_1410:
            
            	; ~~ check if either input is infinity
            
0094E:      	AR=		R1
0094F:      	clr		AR.b15
00950:      	SF=		AR - 0x1F
00951:      	if EQ jmp	sfx_ReturnINF_A_FP16
            
00952:      	AR=		R0
00953:      	clr		AR.b15
00954:      	SF=		AR - 0x1F
00955:      	if EQ jmp	sfx_ReturnINF_A_FP16
            
            	; ~~ add the exponent
            
00956:      	AR=		R1
00957:      	clr		AR.b15
00958:      	AR=		AR + R0
00959:      	test		AR.b5
0095A:      	if NZ jmp	@sfx_fp16mul_label_1413
            
            	; ~~ + 17 ??
            
0095B:      	AR=		AR - 14
0095C:      	test		AR.b5
0095D:      	if ZR jmp	@sfx_fp16mul_label_1501
            
0095E:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16mul_label_1413:
            
0095F:      	AR=		AR - 14
00960:      	test		AR.b5
00961:      	if ZR jmp	@sfx_fp16mul_label_1501
            
00962:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16mul_label_1501:
00963:      	R0=		AR
            
            	; ~~ unsigned multiplay (32-bit)
00964:      	PCH=		sfx_MUL_AX_CX
00965:      	lcall		sfx_MUL_AX_CX
            
            	; ~~ drop 16-bit
00966:      	AR=		DX
00967:      	AX=		AR
            
00968:      	test		AX.b15
00969:      	if NZ jmp	@sfx_fs16mul_label_1531
            
0096A:      	call		sfx_Normalize_A_FP16
            @sfx_fs16mul_label_1531:
0096B:      	jmp		sfx_RoundRet_A_FP16
            
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; AX		- out (fp16)
            ; --------------------------
            sfx_FP16DIV:
            	; ~~ compare final sign bit
            
0096C:      	test		CX.b15
0096D:      	if ZR jmp	@sfx_fp16div_label_1629
            
0096E:      	not		AX.b15
            @sfx_fp16div_label_1629:
            
            	; ~~ if divisor is zero, ...
0096F:      	AR=		CX
00970:      	if NZ jmp	@sfx_fp16div_label_1639
            	; ~~ if dividend is also zero, return NaN
00971:      	AR=		AX
00972:      	if NZ jmp	@sfx_fp16div_label_1641
00973:      	jmp		sfx_ReturnNaN_A_FP16
            @sfx_fp16div_label_1641:
            	; ~~ but dividend is non-zero, return infinity
00974:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16div_label_1639:
            	; ~~ if dividend is zero, return zero
00975:      	AR=		AX
00976:      	if NZ jmp	@sfx_fp16div_label_1644
00977:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16div_label_1644:
00978:      	call		sfx_GETARG_ANS_FP16
00979:      	call		sfx_GETARG_CNS_FP16
            
            	; ~~ if divisor is infinity, ...
0097A:      	AR=		R1
0097B:      	AH=		0
0097C:      	SF=		AR - 0x1F
0097D:      	if NE jmp	@sfx_fp16div_label_1646
0097E:      	AR=		R0
0097F:      	AH=		0
00980:      	SF=		AR - 0x1F
00981:      	if NE jmp	@sfx_fp16div_label_1647
00982:      	jmp		sfx_ReturnNaN_A_FP16
            @sfx_fp16div_label_1647:
00983:      	jmp		sfx_RetZero_A_FP16
            
            @sfx_fp16div_label_1646:
            	; ~~ subtract exponents
            
00984:      	AR=		R1
00985:      	clr		AR.b15
00986:      	AR=		R0 - AR
00987:      	test		AR.b5
00988:      	if ZR jmp	@sfx_fp16div_label_1649
            
00989:      	AR=		AR + 15
0098A:      	test		AR.b5
0098B:      	if ZR jmp	@sfx_fp16div_label_1753
0098C:      	jmp		sfx_RetZero_A_FP16
            @sfx_fp16div_label_1649:
            
0098D:      	AR=		AR + 15
0098E:      	test		AR.b5
0098F:      	if ZR jmp	@sfx_fp16div_label_1753
00990:      	jmp		sfx_ReturnINF_A_FP16
            @sfx_fp16div_label_1753:
00991:      	R0=		AR
            
            	; ~~ unsigned check !!
            
00992:      	AR=		AX
00993:      	AR=		AR - CX
00994:      	test		AR.b15
00995:      	if ZR jmp	@sfx_fp16div_label_1638
            
00996:      	slz		AX, 1
00997:      	R0--				; ~~ exponent
            
            @sfx_fp16div_label_1638:
            
            	; ~~ now we perform repeated substraction of float2 from float1
            
            	; ~~ result - AX
            	; ~~ using 12-bit to make float more accuracy
            
00998:      	push		AX
00999:      	pop		DX
0099A:      	AX=		0
0099B:      	P1=		12
            @sfx_fp16div_loop_1642:
0099C:      	slz		AX, 1
            
            	; ~~ mant1 < mant2
0099D:      		AR=		DX
0099E:      		R2=		AR
0099F:      		AR=		CX
009A0:      		R2=		R2 - AR
009A1:      		test		R2.b15
009A2:      		if NZ jmp	@sfx_fp16div_label_1651
            
            	; result |= mask;
009A3:      		set		AX.b4
            
            	; mant1 -= mant2
009A4:      		AR=		CX
009A5:      		DX=		DX - AR
            @sfx_fp16div_label_1651:
            
            	; mant1 <<= 1;
009A6:      		slz		DX, 1
            
009A7:      	P1--
009A8:      	if NZ jmp	@sfx_fp16div_loop_1642
            
009A9:      	call		sfx_Normalize_A_FP16
009AA:      	jmp		sfx_RoundRet_A_FP16
            
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    internal                     ~~ ;
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            
            sfx_FP16CMPU16:
009AB:      	clr		AX.b15
009AC:      	clr		CX.b15
009AD:      	AR=		AX
009AE:      	SF=		AR - CX
009AF:      	if NE jmp	@sfx_fp16cmpu16_label_1615
            
009B0:      	set		Z
009B1:      	rets
            @sfx_fp16cmpu16_label_1615:
009B2:      	clr		Z
009B3:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; Z		- EQU
            ; NZ		- not EQU
            ; --------------------------
            sfx_FP16CHKZERO:
009B4:      	AR=		AX
009B5:      	AR=		AR | CX
009B6:      	clr		AR.b15
009B7:      	AR=		AR + 0
009B8:      	if NZ jmp	@sfx_fp16chkzero_label_1620
009B9:      	set		Z
009BA:      	rets
            @sfx_fp16chkzero_label_1620:
009BB:      	clr		Z
009BC:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX  <-->   CX
            
            sfx_FP16SWAP:
009BD:      	push		AX
009BE:      	push		CX
009BF:      	pop		AX
009C0:      	pop		CX
009C1:      	rets
            
            
            ; ~~ -- compare support functions -- ~~ ;
            ; ~~    subcc                        ~~ ;
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : EQU
            ;                 0 : not EQU
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JE:
009C2:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JE:
009C3:      	call		sfx_FP16CHKZERO
009C4:      	if ZR jmp	@sfx_fp16equ_label_1622
009C5:      	call		sfx_FP16CMPU16
009C6:      	if ZR jmp	@sfx_fp16equ_label_1622
009C7:      	clr		Z
009C8:      	rets
            @sfx_fp16equ_label_1622:
009C9:      	set		Z
009CA:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : >
            ;                 0 : <=
            ; --------------------------
            sfx_CMPFP16_CX_AX_JG:
            sfx_CMPFP16_CX_AX_JA:
009CB:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JG:
            sfx_CMPFP16_JA:
            	; ~~ backup sign bit
009CC:      	R0=		0
009CD:      	AR=		AX
009CE:      	slz		AR, 1
009CF:      	slc		R0, 1
009D0:      	AR=		CX
009D1:      	slz		AR, 1
009D2:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
009D3:      	call		sfx_FP16CHKZERO
009D4:      	if ZR jmp	@sfx_cmpfp16_jg_label_1641
009D5:      	call		sfx_FP16CMPU16
009D6:      	if ZR jmp	@sfx_cmpfp16_jg_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
009D7:      	AR=		R0
009D8:      	if EQ jmp	@sfx_comfp16_jg_label_1645
009D9:      	SF=		AR - 3
009DA:      	if EQ jmp	@sfx_comfp16_jg_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
009DB:      	SF=		AR - 1
009DC:      	if EQ jmp	@sfx_comfp16_jg_label_1657
            	; ~~ 2  =  -  vs  +   = <
009DD:      	jmp		@sfx_cmpfp16_jg_label_1641
            @sfx_comfp16_jg_label_1645:
            	; ~~ sign bit the same
            
009DE:      	AR=		CX
009DF:      	AX=		AX - AR
            
009E0:      	AR=		R0
009E1:      	SF=		AR - 3
009E2:      	if NE jmp	@sfx_cmpfp16_jg_label_1558
009E3:      	not		AX.b15
            @sfx_cmpfp16_jg_label_1558:
009E4:      	test		AX.b15
009E5:      	if ZR jmp	@sfx_comfp16_jg_label_1657
            
            @sfx_cmpfp16_jg_label_1641:
009E6:      	clr		Z		; ~~ false
009E7:      	rets
            
            @sfx_comfp16_jg_label_1657:
009E8:      	set		Z		; ~~ true
009E9:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : <
            ;                 0 : >=
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JL:
            sfx_CMPFP16_CX_AX_JB:
009EA:      	call		sfx_FP16SWAP
            sfx_CMPFP16_JL:
            sfx_CMPFP16_JB:
            	; ~~ backup sign bit
009EB:      	R0=		0
009EC:      	AR=		AX
009ED:      	slz		AR, 1
009EE:      	slc		R0, 1
009EF:      	AR=		CX
009F0:      	slz		AR, 1
009F1:      	slc		R0, 1
            
            	; ~~ check zero and equ (sign bit gone)
            
009F2:      	call		sfx_FP16CHKZERO
009F3:      	if ZR jmp	@sfx_cmpfp16_jl_label_1641
009F4:      	call		sfx_FP16CMPU16
009F5:      	if ZR jmp	@sfx_cmpfp16_jl_label_1641
            
            	; ~~ check sign bit
            	; ~~ ---------------------
            	;          A      B
            	; ~~ ---------------------
            	; ~~ 0  =  +  vs  +
            	; ~~ 1  =  +  vs  -
            	; ~~ 2  =  -  vs  +
            	; ~~ 3  =  -  vs  -
            
009F6:      	AR=		R0
009F7:      	if EQ jmp	@sfx_comfp16_jl_label_1645
009F8:      	SF=		AR - 3
009F9:      	if EQ jmp	@sfx_comfp16_jl_label_1645
            
            	; ~~ sign bit different
            	; ~~ 1  =  +  vs  -   = >
009FA:      	SF=		AR - 1
009FB:      	if EQ jmp	@sfx_cmpfp16_jl_label_1641
            	; ~~ 2  =  -  vs  +   = <
009FC:      	jmp		@sfx_comfp16_jl_label_1657
            
            @sfx_comfp16_jl_label_1645:
            	; ~~ sign bit the same
            
009FD:      	AR=		CX
009FE:      	AX=		AX - AR
            
009FF:      	AR=		R0
00A00:      	SF=		AR - 3
00A01:      	if NE jmp	@sfx_cmpfp16_jl_label_1558
00A02:      	not		AX.b15
            @sfx_cmpfp16_jl_label_1558:
00A03:      	test		AX.b15
00A04:      	if NZ jmp	@sfx_comfp16_jl_label_1657
            
            @sfx_cmpfp16_jl_label_1641:
00A05:      	clr		Z		; ~~ false
00A06:      	rets
            
            @sfx_comfp16_jl_label_1657:
00A07:      	set		Z		; ~~ true
00A08:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP16_JNE:
00A09:      	call		sfx_CMPFP16_JE
00A0A:      	if ZR jmp	@sfx_cmpfp16_jne_label_false
00A0B:      	set		Z
00A0C:      	rets
            @sfx_cmpfp16_jne_label_false:
00A0D:      	clr		Z
00A0E:      	rets
            
            ; --------------------------
            ; CX		- in (fp16)
            ; AX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : not EQU
            ;                 0 : EQU
            ; --------------------------
            
            sfx_CMPFP16_CX_AX_JNE:
00A0F:      	call		sfx_CMPFP16_CX_AX_JE
00A10:      	if ZR jmp	@sfx_cmpfp16_ca_jne_label_false
00A11:      	set		Z
00A12:      	rets
            @sfx_cmpfp16_ca_jne_label_false:
00A13:      	clr		Z
00A14:      	rets
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : <=
            ;                 0 : >
            ; --------------------------
            
            sfx_CMPFP16_JLE:
            sfx_CMPFP16_JBE:
00A15:      	call		sfx_CMPFP16_JG
00A16:      	if ZR jmp	@sfx_cmpfp16_jle_label_false
00A17:      	set		Z
00A18:      	rets
            @sfx_cmpfp16_jle_label_false:
00A19:      	clr		Z
00A1A:      	rets
            
            
            sfx_CMPFP16_CX_AX_JLE:
            sfx_CMPFP16_CX_AX_JBE:
00A1B:      	call		sfx_CMPFP16_CX_AX_JG
00A1C:      	if ZR jmp	@sfx_cmpfp16_ca_jle_label_false
00A1D:      	set		Z
00A1E:      	rets
            @sfx_cmpfp16_ca_jle_label_false:
00A1F:      	clr		Z
00A20:      	rets
            
            
            ; --------------------------
            ; AX		- in (fp16)
            ; CX		- in (fp16)
            ; --------------------------
            ; AX		- 1 : >=
            ;                 0 : <
            ; --------------------------
            
            sfx_CMPFP16_JGE:
            sfx_CMPFP16_JAE:
00A21:      	call		sfx_CMPFP16_JL
00A22:      	if ZR jmp	@sfx_cmpfp16_jge_label_false
00A23:      	set		Z
00A24:      	rets
            @sfx_cmpfp16_jge_label_false:
00A25:      	clr		Z
00A26:      	rets
            
            
            sfx_CMPFP16_CX_AX_JGE:
            sfx_CMPFP16_CX_AX_JAE:
00A27:      	call		sfx_CMPFP16_CX_AX_JL
00A28:      	if ZR jmp	@sfx_cmpfp16_ca_jge_label_false
00A29:      	set		Z
00A2A:      	rets
            @sfx_cmpfp16_ca_jge_label_false:
00A2B:      	clr		Z
00A2C:      	rets
            
            ; --------------------------
            ; DX:AX		- in (fp32)
            ; --------------------------
            sfx_FP16NEG:
00A2D:      	not		AX.b15
00A2E:      	rets
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\FP16RT.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00A2F:      	PCH=	_WakeupProc94A410F9
00A30:      	ljmp	_WakeupProc94A410F9
            
            IntVectTable:
00A31:      	DW #EMPTY_INTENTRY
00A32:      	DW #EMPTY_INTENTRY
00A33:      	DW #EMPTY_INTENTRY
00A34:      	DW #EMPTY_INTENTRY
00A35:      	DW #EMPTY_INTENTRY
00A36:      	DW #_PWM99B23D7D
            
            // .code ends
            ;;FDSP-IDE V2.63
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
